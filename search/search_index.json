{"config":{"lang":["en","zh"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stemmer"]},"docs":[{"location":"","title":"\u7b80\u5355\u4f7f\u7528","text":""},{"location":"#_1","title":"\u57fa\u672c\u7528\u6cd5","text":"<p>1.\u5b9a\u4e49\u53ef\u5e8f\u5217\u5316\u7c7b\uff0c\u53ea\u8981\u7c7b\u4e2d\u7684\u5b57\u6bb5\u5177\u6709setter\u548cgetter\uff0c\u5c31\u53ef\u4ee5\u5e8f\u5217\u5316\u3002\u4f8b\u5982\uff1a</p> <pre><code>@Serializable  \ndata class Test(  \n    @SerialName(\"userName\")//\u6b64\u6ce8\u89e3\u4f1a\u6307\u5b9a\u5e8f\u5217\u5316/\u53cd\u5e8f\u5217\u5316\u65f6\u5b57\u6bb5\u7684\u540d\u79f0\n    val data:String=\"\",\n    @Transient //\u6b64\u6ce8\u89e3\u4f7f\u5f97\u5728\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u65f6\u5ffd\u7565\u6b64\u5b57\u6bb5\n    val time:String=\"\"\n)\n</code></pre> <p>Note</p> <p>@Transient   (\u4e0d\u8981\u4e0e[kotlin.jvm.Transient]\u6df7\u6dc6) \u4f7f\u5f97\u5728\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u65f6\u5ffd\u7565\u6b64\u5b57\u6bb5 \u4f46\u662f\u9700\u8981\u7ed9\u4e0e\u9ed8\u8ba4\u503c\uff0c\u5426\u5219\u62a5\u9519 \u5982\u679cjson\u4e2d\u5305\u542b\u4e86\u88ab\u5ffd\u7565\u7684\u5b57\u6bb5\uff0c\u9700\u8981\u914d\u7f6ecoerceInputValues\u4e3atrue\uff0c\u5426\u5219\u4f1a\u62a5\u9519</p> <p>2.\u914d\u7f6e\u5e8f\u5217\u5316\u5668\uff08\u53ef\u9009\uff09 <pre><code>object HttpSerializersModule {\n    //\u6307\u5b9a\u591a\u6001\u7ed3\u6784\n     private val pagerEntityModule = SerializersModule {  \n     //\u5b9a\u4e49PagerEntity\u6709\u4e24\u4e2a\u5b50\u7c7b\uff1aAPagerEntity\u548cAPagerEntity\n         polymorphic(PagerEntity::class) {  \n             subclass(APagerEntity::class)  \n             subclass(APagerEntity2::class)\n            }  \n    }\n    fun get() = responseModule\n}\n\nvar jsonUtil: Json = Json {  \n    ignoreUnknownKeys = true  //\u5ffd\u7565\u672a\u77e5\u5b57\u6bb5\n    coerceInputValues = true  //\u5f3a\u5236\u9ed8\u8ba4\u503c\n    serializersModule = HttpSerializersModule.get()  //\uff08\u53ef\u9009\uff09\u5982\u679c\u9700\u8981\u6307\u5b9a\u591a\u6001\u7ed3\u6784\n}\n</code></pre> 3.\u4f7f\u7528\u4e0a\u9762\u5b9a\u4e49\u7684jsonUtil\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316         \u5982\u679c\u4e0d\u5b9a\u7528jsonUtil,\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528<code>Json</code>\u8fd9\u4e2a\u9ed8\u8ba4\u9ed8\u8ba4\u5bf9\u8c61 <pre><code>//\u53cd\u5e8f\u5217\u5316\njsonUtil.decodeFromString&lt;T&gt;(\"\")\n//\u5e8f\u5217\u5316\njsonUtil.encodeToString(data)\n//\u751f\u6210json\u5bf9\u8c61\njsonUtil.encodeToJsonElement(data)\n//\u624b\u52a8\u6784\u5efajson\u5bf9\u8c61\nval jsonBody = buildJsonObject {  \n    put(\"id\", 1)  \n    put(\"name\", \"hello\")  \n    put(\"remark\", \"remark\")  \n}\n\n\n//\u4f8b\u5982\u4f7f\u7528\u9ed8\u8ba4\u7684Json\u8fdb\u884c\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\nJson.decodeFromString&lt;T&gt;(\"\")\n</code></pre></p>"},{"location":"#_2","title":"\u6cdb\u578b","text":"<p>\u5728\u7c7b\u4e0a\u4f7f\u7528\u6cdb\u578b\uff0c\u8fd9\u4e2a\u6cdb\u578b\u4ee3\u8868\u7684\u7c7b\u578b\u4e5f\u9700\u8981\u652f\u6301\u53ef\u5e8f\u5217\u5316 \u6bd4\u5982\u5199\u4e00\u4e2a\u901a\u7528\u7684http\u8bf7\u6c42response\u8fd4\u56de\u7c7b \u5982\u4e0b\u793a\u4f8b\uff0cdata class\uff0cclass\uff0c\u90fd\u662f\u53ef\u4ee5\u7684\uff0c\u4e0d\u8bba\u5728\u6784\u9020\u51fd\u6570\u4e2d\u8fd8\u662f\u7c7b\u4f53\u4e2d\u90fd\u884c\u3002\u6cdb\u578b\u4e3a<code>List&lt;SomeEntity&gt;</code>\u4e4b\u7c7b\u7684\uff0c\u53ea\u8981SomeEntity\u53ef\u5e8f\u5217\u5316\u5c31\u6ca1\u95ee\u9898\uff0cList\u4e4b\u7c7b\u7684kotlin\u662f\u6709\u9ed8\u8ba4\u652f\u6301\u7684\u3002</p> <pre><code>@Serializable  \ndata class BaseResponse3&lt;out T&gt;(  \n    val data: T? = null,  \n    var code: Int = 200,  \n    var msg: String = \"\",  \n){\n    var name:String =\"\"\n}\n\n@Serializable   \nclass BaseResponse3&lt;T&gt; (var data: T? = null\uff0c var code: Int = 200 ){  \n    var msg: String = \"\"  \n}\n</code></pre> <p>\u4f8b\u5982\uff1a <pre><code>//\u5e8f\u5217\u5316\nval a1 = BaseResponse3(data = UserInfo(), code = 633, msg = \"test msg\")  \nval a2 = BaseResponse3(  \n    data = ApkEntity(appName = \"app name1\", apkUrl = \"url......\", appVersion = \"1.0.236\"),  \n    code = 999,  \n    msg = \"test msg11111\"  \n)  \n//\u6253\u5370json\uff0c\u7ed3\u679c\u6b63\u5e38\nprintln(\" a1:${a1.toJson()} \\n a2: ${a2.toJson()}\")  \n\n\n//\u5b9a\u4e49\u4e00\u4e0bjosn\u6570\u636e\nval a2s =  \n    \"{\\\"data\\\":{\\\"apkName\\\":\\\"app name1\\\",\\\"apkDownloadUrl\\\":\\\"url......\\\",\\\"apkVersionName\\\":\\\"1.0.236\\\"},\\\"code\\\":999,\\\"msg\\\":\\\"test msg11111\\\"}\"  \nval a1s =  \n    \"{\\\"data\\\":{\\\"smsCode\\\":\\\"2564\\\",\\\"userName\\\":\\\"op\\\",\\\"appVersion\\\":\\\"1.56\\\",\\\"headPic\\\":\\\"kkkkkkkkkkkkkkkkkkkkk\\\",\\\"tel\\\":\\\"158496875632\\\",\\\"nickName\\\":\\\"tomjjj\\\",\\\"sex\\\":1},\\\"code\\\":633,\\\"msg\\\":\\\"test msg\\\"} \"  \n\n//\u53cd\u5e8f\u5217\u5316\uff0c\u4e0d\u4f1a\u62a5\u9519\njsonUtil.decodeFromString&lt;BaseResponse3&lt;SysUserEntity&gt;&gt;(a1s)  \njsonUtil.decodeFromString&lt;BaseResponse3&lt;ApkEntity&gt;&gt;(a2s)\n</code></pre></p>"},{"location":"#_3","title":"\u591a\u6001\u548c\u6cdb\u578b","text":"<p>\u5982\u679c\u6211\u6709\u4e00\u4e2a\u62bd\u8c61\u7c7b\u6216\u662f\u5bc6\u5c01\u7c7b\uff0c\u4ed6\u4eec\u90fd\u6709\u4e0d\u540c\u7684\u5b9e\u73b0\uff0c\u60f3\u4ee4\u8fd9\u4e9b\u5b9e\u73b0\u4e5f\u90fd\u652f\u6301\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\uff1a</p>"},{"location":"#_4","title":"\u5982\u679c\u662f\u7236\u7c7b\u662f\u62bd\u8c61\u7c7b\uff0c\u5939\u6742\u7740\u6cdb\u578b\u548c\u591a\u79cd\u5b50\u7c7b","text":"<ul> <li>\u5e8f\u5217\u5316\u53ef\u4ee5\u5904\u7406\u4efb\u610f\u7684 \u201c\u5f00\u653e \u201c\u7c7b\u6216 \u201c\u62bd\u8c61 \u201c\u7c7b\u3002\u4f46\u662f\uff0c\u7531\u4e8e\u8fd9\u79cd\u591a\u6001\u6027\u662f\u5f00\u653e\u7684\uff0c\u56e0\u6b64\u6709\u53ef\u80fd\u5728\u6e90\u4ee3\u7801\u7684\u4efb\u4f55\u5730\u65b9\uff0c\u751a\u81f3\u5728\u5176\u4ed6\u6a21\u5757\u4e2d\u5b9a\u4e49\u4e86\u5b50\u7c7b\uff0c\u56e0\u6b64\u5e8f\u5217\u5316\u7684\u5b50\u7c7b\u5217\u8868\u65e0\u6cd5\u5728\u7f16\u8bd1\u65f6\u786e\u5b9a\uff0c\u5fc5\u987b\u5728\u8fd0\u884c\u65f6\u663e\u5f0f\u6ce8\u518c\u3002</li> </ul> <p>\u4f8b\u5982\uff1a\u6211\u4eec\u6709\u5982\u4e0b\u51e0\u4e2a\u7c7b <pre><code>@Serializable  \nabstract class Response&lt;out T&gt;  \n\n@Serializable  \n@SerialName(\"OkResponse1\")  \nopen class OkResponse1&lt;T&gt;(var data: T? = null) : Response&lt;T&gt;(){  \n    var code: Int = 200  \n    var rtncode: Int = 200  \n    var msg: String = \"\"  \n}\n\n@Serializable  \n@SerialName(\"OkResponse2\")  \ndata class OkResponse2&lt;out T&gt;(  \n    val data: T? = null,  \n    var rtncode: Int = 200,  \n    var msg: String = \"\",  \n) : Response&lt;T&gt;()  \n</code></pre></p> <p>Note</p> <p>OkResponse1\u548cOkResponse2\u90fd\u662fResponse\u7684\u5b50\u7c7b\uff0c\u800c\u4e14\u90fd\u542b\u6709\u6cdb\u578b\u3002 OkResponse1\u662f\u4e2aopen class\uff0c\u6784\u9020\u51fd\u6570\u5305\u542b\u4e00\u4e2a\u5b57\u6bb5\uff0c\u5176\u4f59\u5728\u51fd\u6570\u4f53\u4e2d OkResponse2\u5219\u662f\u4e00\u4e2adata class\uff0c\u5b57\u6bb5\u90fd\u5728\u6784\u9020\u51fd\u6570\u4e2d  </p> <p>OkResponse1\u548cOkResponse2\u90fd\u662fResponse\u7684\u5b50\u7c7b\uff0c\u9700\u8981\u5728\u5e8f\u5217\u5316\u6a21\u5757\u4e2d\u6ce8\u518c\uff1a</p> <p>\u591a\u4e2aSerializersModule\u53ef\u4ee5\u76f4\u63a5\u7528<code>+</code>\u5408\u5e76</p> <pre><code>val responseModule2 = SerializersModule {  \n    //\u6307\u5b9aOkResponse1\u548cOkResponse2\u662fResponse\u7684\u5b50\u7c7b\uff0c\u4e14\u6cdb\u578b\u4e3aAny\uff0c\u5982\u6b64\uff0c\u6cdb\u578b\u53ef\u4f20\u4efb\u610f\u53ef\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u7684\u7c7b\u578b\u4e86\n    polymorphic(Response::class) {  \n        subclass(OkResponse1.serializer(PolymorphicSerializer(Any::class)))  \n        subclass(OkResponse2.serializer(PolymorphicSerializer(Any::class)))  \n    }  \n}\nvar jsonUtil: Json = Json {  \n    ignoreUnknownKeys = true  \n    coerceInputValues = true  \n    serializersModule =responseModule+ responseModule2  //\u5408\u5e76\u591a\u4e2aSerializersModule\n}\n</code></pre> <ul> <li>\u6d4b\u8bd51 <pre><code>//1. string\u7c7b\u578b  \nval data = OkResponse1&lt;String&gt;(\"oooo\")  \ndata.toJson()  \n\n//2. list\u7c7b\u578b  \nval s = mutableListOf&lt;SysUserEntity&gt;()  \ns.add(SysUserEntity())  \nval data2 = OkResponse1&lt;List&lt;SysUserEntity&gt;&gt;(s)  \ndata2.toJson()  \n\n//3. \u666e\u901a\u7c7b\u578b  \nval data23 = OkResponse1&lt;SysUserEntity&gt;()  \ndata23.data = SysUserEntity() \ndata23.toJson()  \n\nprintln(\"Page: ${data.toJson()} \\n ${data2.toJson()} \\n ${data23.toJson()}\")  \n\n\nval a1 = \"{\\\"data\\\":\\\"oooo\\\"}\"  \nval a2 =  \n    \"{\\\"data\\\":[{\\\"smsCode\\\":\\\"2564\\\",\\\"userName\\\":\\\"op\\\",\\\"appVersion\\\":\\\"1.56\\\",\\\"headPic\\\":\\\"kkkkkkkkkkkkkkkkkkkkk\\\",\\\"tel\\\":\\\"158496875632\\\",\\\"nickName\\\":\\\"tomjjj\\\",\\\"sex\\\":1}]}\"  \nval a3 =  \n    \"{\\\"data\\\":{\\\"smsCode\\\":\\\"2564\\\",\\\"userName\\\":\\\"op\\\",\\\"appVersion\\\":\\\"1.56\\\",\\\"headPic\\\":\\\"kkkkkkkkkkkkkkkkkkkkk\\\",\\\"tel\\\":\\\"158496875632\\\",\\\"nickName\\\":\\\"tomjjj\\\",\\\"sex\\\":1}}\"  \na1.cast&lt;OkResponse1&lt;String&gt;&gt;()  \na2.cast&lt;OkResponse1&lt;List&lt;SysUserEntity&gt;&gt;&gt;()  \na3.cast&lt;OkResponse1&lt;SysUserEntity&gt;&gt;()\n</code></pre></li> <li>\u6d4b\u8bd52\uff1a <pre><code>val data = OkResponse2(\"DDD\")  \ndata.toJson()  \nval s = mutableListOf&lt;SysUserEntity&gt;()  \ns.add(LoginPrefs.loginUserInfo)  \nval data2 = OkResponse2(s)  \ndata2.toJson()  \nval data23 = OkResponse2(SysUserEntity())  \ndata23.toJson()  \n\nprintln(\"Page: ${data.toJson()} \\n ${data2.toJson()} \\n ${data23.toJson()}\")\n</code></pre></li> </ul>"},{"location":"#_5","title":"\u5982\u679c\u662f\u5bc6\u5c01\u7c7b","text":"<p>\u5bc6\u5c01\u7c7b\u7684\u6240\u6709\u5b50\u7c7b\u90fd\u5fc5\u987b\u663e\u5f0f\u6807\u8bb0\u4e3a\u00a0<code>@Serializable</code>\u00a0\u3002</p> <pre><code>@Serializable\nsealed class Project {\n    abstract val name: String,\n    var status = \"open\",\n}\n\n@Serializable\nclass OwnedProject(override val name: String, val owner: String) : Project()\n\nfun main() {\n    val data: Project = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(Json.encodeToString(data)) // Serializing data of compile-time type Project\n}\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/","title":"JSON features\u00a0JSON \u529f\u80fd","text":"<p>This is the fifth chapter of the\u00a0Kotlin Serialization Guide. In this chapter, we\u2019ll walk through features of\u00a0JSON\u00a0serialization available in the\u00a0Json\u00a0class. \u8fd9\u662f\u300aKotlin \u5e8f\u5217\u5316\u6307\u5357\u300b\u7684\u7b2c\u4e94\u7ae0\u3002\u5728\u672c\u7ae0\u4e2d\uff0c\u6211\u4eec\u5c06\u6f14\u7ec3 Json \u7c7b\u4e2d\u63d0\u4f9b\u7684 JSON \u5e8f\u5217\u5316\u529f\u80fd\u3002</p> <p>Table of contents\u00a0\u76ee\u5f55</p> <ul> <li>Json configuration\u00a0Json \u914d\u7f6e<ul> <li>Pretty printing\u00a0\u6f02\u4eae\u7684\u5370\u5237</li> <li>Lenient parsing\u00a0\u5bbd\u677e\u89e3\u6790</li> <li>Ignoring unknown keys\u00a0\u5ffd\u7565\u672a\u77e5\u952e</li> <li>Alternative Json names\u00a0\u5907\u7528 Json \u540d\u79f0</li> <li>Coercing input values\u00a0\u5f3a\u5236\u8f93\u5165\u503c</li> <li>Encoding defaults\u00a0\u7f16\u7801\u9ed8\u8ba4\u503c</li> <li>Explicit nulls\u00a0\u663e\u5f0f null</li> <li>Allowing structured map keys     \u5141\u8bb8\u7ed3\u6784\u5316\u6620\u5c04\u952e</li> <li>Allowing special floating-point values     \u5141\u8bb8\u7279\u6b8a\u7684\u6d6e\u70b9\u503c</li> <li>Class discriminator for polymorphism     \u591a\u6001\u6027\u7684\u7c7b\u9274\u522b\u5668</li> <li>Class discriminator output mode     \u7c7b\u9274\u522b\u5668\u8f93\u51fa\u65b9\u5f0f</li> <li>Decoding enums in a case-insensitive manner     \u4ee5\u4e0d\u533a\u5206\u5927\u5c0f\u5199\u7684\u65b9\u5f0f\u89e3\u7801\u679a\u4e3e</li> <li>Global naming strategy\u00a0\u5168\u5c40\u547d\u540d\u7b56\u7565</li> </ul> </li> <li>Json elements\u00a0Json \u5143\u7d20<ul> <li>Parsing to Json element     \u89e3\u6790\u4e3a Json \u5143\u7d20</li> <li>Types of Json elements     Json \u5143\u7d20\u7684\u7c7b\u578b</li> <li>Json element builders\u00a0Json \u5143\u7d20\u751f\u6210\u5668</li> <li>Decoding Json elements\u00a0\u89e3\u7801 Json \u5143\u7d20</li> <li>Encoding literal Json content (experimental)     \u5bf9\u6587\u5b57 Json \u5185\u5bb9\u8fdb\u884c\u7f16\u7801\uff08\u5b9e\u9a8c\u6027\uff09<ul> <li>Serializing large decimal numbers     \u5e8f\u5217\u5316\u5927\u5341\u8fdb\u5236\u6570</li> <li>Using\u00a0<code>JsonUnquotedLiteral</code>\u00a0to create a literal unquoted value of\u00a0<code>null</code>\u00a0is forbidden     \u7981\u6b62\u7528\u4e8e\u00a0<code>JsonUnquotedLiteral</code>\u00a0\u521b\u5efa \u7684\u00a0<code>null</code>\u00a0\u6587\u5b57\u672a\u52a0\u5f15\u53f7\u7684\u503c</li> </ul> </li> </ul> </li> <li>Json transformations\u00a0Json \u8f6c\u6362<ul> <li>Array wrapping\u00a0\u6570\u7ec4\u5305\u88c5</li> <li>Array unwrapping\u00a0\u6570\u7ec4\u89e3\u5305</li> <li>Manipulating default values     \u64cd\u4f5c\u9ed8\u8ba4\u503c</li> <li>Content-based polymorphic deserialization     \u57fa\u4e8e\u5185\u5bb9\u7684\u591a\u6001\u53cd\u5e8f\u5217\u5316</li> <li>Under the hood (experimental)     \u5f15\u64ce\u76d6\u4e0b\uff08\u5b9e\u9a8c\u6027\uff09</li> <li>Maintaining custom JSON attributes     \u7ef4\u62a4\u81ea\u5b9a\u4e49 JSON \u5c5e\u6027</li> </ul> </li> </ul>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#json-configuration-json","title":"Json configuration\u00a0Json \u914d\u7f6e","text":"<p>The default\u00a0Json\u00a0implementation is quite strict with respect to invalid inputs. It enforces Kotlin type safety and restricts Kotlin values that can be serialized so that the resulting JSON representations are standard. Many non-standard JSON features are supported by creating a custom instance of a JSON\u00a0format. \u9ed8\u8ba4\u7684 Json \u5b9e\u73b0\u5bf9\u4e8e\u65e0\u6548\u8f93\u5165\u975e\u5e38\u4e25\u683c\u3002\u5b83\u5f3a\u5236\u5b9e\u65bd Kotlin \u7c7b\u578b\u5b89\u5168\u6027\uff0c\u5e76\u9650\u5236\u53ef\u5e8f\u5217\u5316\u7684 Kotlin \u503c\uff0c\u4ee5\u4fbf\u751f\u6210\u7684 JSON \u8868\u793a\u5f62\u5f0f\u662f\u6807\u51c6\u7684\u3002\u901a\u8fc7\u521b\u5efa JSON \u683c\u5f0f\u7684\u81ea\u5b9a\u4e49\u5b9e\u4f8b\u6765\u652f\u6301\u8bb8\u591a\u975e\u6807\u51c6 JSON \u529f\u80fd\u3002</p> <p>To use a custom JSON format configuration, create your own\u00a0Json\u00a0class instance from an existing instance, such as a default\u00a0<code>Json</code>\u00a0object, using the\u00a0Json()\u00a0builder function. Specify parameter values in the parentheses via the\u00a0JsonBuilder\u00a0DSL. The resulting\u00a0<code>Json</code>\u00a0format instance is immutable and thread-safe; it can be simply stored in a top-level property. \u8981\u4f7f\u7528\u81ea\u5b9a\u4e49 JSON \u683c\u5f0f\u914d\u7f6e\uff0c\u8bf7\u4f7f\u7528 Json\uff08\uff09 \u6784\u5efa\u5668\u51fd\u6570\u4ece\u73b0\u6709\u5b9e\u4f8b\uff08\u5982\u9ed8\u8ba4\u00a0<code>Json</code>\u00a0\u5bf9\u8c61\uff09\u521b\u5efa\u81ea\u5df1\u7684 Json \u7c7b\u5b9e\u4f8b\u3002\u901a\u8fc7 JsonBuilder DSL \u5728\u62ec\u53f7\u4e2d\u6307\u5b9a\u53c2\u6570\u503c\u3002\u751f\u6210\u00a0<code>Json</code>\u00a0\u7684\u683c\u5f0f\u5b9e\u4f8b\u662f\u4e0d\u53ef\u53d8\u7684\uff0c\u5e76\u4e14\u662f\u7ebf\u7a0b\u5b89\u5168\u7684;\u5b83\u53ef\u4ee5\u7b80\u5355\u5730\u5b58\u50a8\u5728\u9876\u7ea7\u5c5e\u6027\u4e2d\u3002</p> <p>We recommend that you store and reuse custom instances of formats for performance reasons because format implementations may cache format-specific additional information about the classes they serialize. \u51fa\u4e8e\u6027\u80fd\u539f\u56e0\uff0c\u6211\u4eec\u5efa\u8bae\u60a8\u5b58\u50a8\u548c\u91cd\u7528\u683c\u5f0f\u7684\u81ea\u5b9a\u4e49\u5b9e\u4f8b\uff0c\u56e0\u4e3a\u683c\u5f0f\u5b9e\u73b0\u53ef\u80fd\u4f1a\u7f13\u5b58\u6709\u5173\u5176\u5e8f\u5217\u5316\u7684\u7c7b\u7684\u7279\u5b9a\u4e8e\u683c\u5f0f\u7684\u9644\u52a0\u4fe1\u606f\u3002</p> <p>This chapter shows configuration features that\u00a0Json\u00a0supports. \u672c\u7ae0\u4ecb\u7ecd Json \u652f\u6301\u7684\u914d\u7f6e\u529f\u80fd\u3002</p>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#pretty-printing","title":"Pretty printing\u00a0\u6f02\u4eae\u7684\u5370\u5237","text":"<p>By default, the\u00a0Json\u00a0output is a single line. You can configure it to pretty print the output (that is, add indentations and line breaks for better readability) by setting the\u00a0prettyPrint\u00a0property to\u00a0<code>true</code>: \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cJson \u8f93\u51fa\u4e3a\u5355\u884c\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u5c06 prettyPrint \u5c5e\u6027\u8bbe\u7f6e\u4e3a\u00a0<code>true</code>\u00a0\uff1a</p> <pre><code>val format = Json { prettyPrint = true }\n\n@Serializable\ndata class Project(val name: String, val language: String)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\", \"Kotlin\")\n    println(format.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>It gives the following nice result: \u5b83\u7ed9\u51fa\u4e86\u4ee5\u4e0b\u4e0d\u9519\u7684\u7ed3\u679c\uff1a</p> <pre><code>{\n    \"name\": \"kotlinx.serialization\",\n    \"language\": \"Kotlin\"\n}\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#lenient-parsing","title":"Lenient parsing\u00a0\u5bbd\u677e\u89e3\u6790","text":"<p>By default,\u00a0Json\u00a0parser enforces various JSON restrictions to be as specification-compliant as possible (see\u00a0RFC-4627). Particularly, keys and string literals must be quoted. Those restrictions can be relaxed with the\u00a0isLenient\u00a0property. With\u00a0<code>isLenient = true</code>, you can parse quite freely-formatted data: \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cJson \u89e3\u6790\u5668\u5f3a\u5236\u6267\u884c\u5404\u79cd JSON \u9650\u5236\uff0c\u4ee5\u5c3d\u53ef\u80fd\u7b26\u5408\u89c4\u8303\uff08\u8bf7\u53c2\u9605 RFC-4627\uff09\u3002\u7279\u522b\u662f\uff0c\u952e\u548c\u5b57\u7b26\u4e32\u6587\u5b57\u5fc5\u987b\u52a0\u5f15\u53f7\u3002\u8fd9\u4e9b\u9650\u5236\u53ef\u4ee5\u901a\u8fc7 isLenient \u5c5e\u6027\u653e\u5bbd\u3002\u4f7f\u7528\u00a0<code>isLenient = true</code>\u00a0\uff0c\u60a8\u53ef\u4ee5\u89e3\u6790\u683c\u5f0f\u975e\u5e38\u81ea\u7531\u7684\u6570\u636e\uff1a</p> <pre><code>val format = Json { isLenient = true }\n\nenum class Status { SUPPORTED }\n\n@Serializable\ndata class Project(val name: String, val status: Status, val votes: Int)\n\nfun main() {\n    val data = format.decodeFromString&lt;Project&gt;(\"\"\"\n        {\n            name   : kotlinx.serialization,\n            status : SUPPORTED,\n            votes  : \"9000\"\n        }\n    \"\"\")\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>You get the object, even though all keys of the source JSON, string, and enum values are unquoted, while an integer is quoted: \u5373\u4f7f\u6e90 JSON\u3001\u5b57\u7b26\u4e32\u548c\u679a\u4e3e\u503c\u7684\u6240\u6709\u952e\u90fd\u4e0d\u5e26\u5f15\u53f7\uff0c\u800c\u6574\u6570\u5219\u7528\u5f15\u53f7\u5f15\u51fa\uff0c\u60a8\u4e5f\u4f1a\u5f97\u5230\u8be5\u5bf9\u8c61\uff1a</p> <pre><code>Project(name=kotlinx.serialization, status=SUPPORTED, votes=9000)\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#ignoring-unknown-keys","title":"Ignoring unknown keys\u00a0\u5ffd\u7565\u672a\u77e5\u952e","text":"<p>JSON format is often used to read the output of third-party services or in other dynamic environments where new properties can be added during the API evolution. By default, unknown keys encountered during deserialization produce an error. You can avoid this and just ignore such keys by setting the\u00a0ignoreUnknownKeys\u00a0property to\u00a0<code>true</code>: JSON \u683c\u5f0f\u901a\u5e38\u7528\u4e8e\u8bfb\u53d6\u7b2c\u4e09\u65b9\u670d\u52a1\u7684\u8f93\u51fa\uff0c\u6216\u8005\u7528\u4e8e\u5728 API \u6f14\u8fdb\u8fc7\u7a0b\u4e2d\u53ef\u4ee5\u6dfb\u52a0\u65b0\u5c5e\u6027\u7684\u5176\u4ed6\u52a8\u6001\u73af\u5883\u4e2d\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5728\u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\u9047\u5230\u7684\u672a\u77e5\u952e\u4f1a\u751f\u6210\u9519\u8bef\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u5c06 ignoreUnknownKeys \u5c5e\u6027\u8bbe\u7f6e\u4e3a\u00a0<code>true</code>\u00a0\uff1a</p> <pre><code>val format = Json { ignoreUnknownKeys = true }\n\n@Serializable\ndata class Project(val name: String)\n\nfun main() {\n    val data = format.decodeFromString&lt;Project&gt;(\"\"\"\n        {\"name\":\"kotlinx.serialization\",\"language\":\"Kotlin\"}\n    \"\"\")\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>It decodes the object despite the fact that the\u00a0<code>Project</code>\u00a0class doesn\u2019t have the\u00a0<code>language</code>\u00a0property: \u5b83\u5bf9\u5bf9\u8c61\u8fdb\u884c\u89e3\u7801\uff0c\u5c3d\u7ba1\u00a0<code>Project</code>\u00a0\u8be5\u7c7b\u6ca1\u6709\u4ee5\u4e0b\u00a0<code>language</code>\u00a0\u5c5e\u6027\uff1a</p> <pre><code>Project(name=kotlinx.serialization)\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#alternative-json-names-json","title":"Alternative Json names\u00a0\u5907\u7528 Json \u540d\u79f0","text":"<p>It\u2019s not a rare case when JSON fields are renamed due to a schema version change. You can use the\u00a0<code>@SerialName</code>\u00a0annotation\u00a0to change the name of a JSON field, but such renaming blocks the ability to decode data with the old name. To support multiple JSON names for the one Kotlin property, there is the\u00a0JsonNames\u00a0annotation: \u7531\u4e8e\u67b6\u6784\u7248\u672c\u66f4\u6539\u800c\u91cd\u547d\u540d JSON \u5b57\u6bb5\u7684\u60c5\u51b5\u5e76\u4e0d\u5c11\u89c1\u3002\u60a8\u53ef\u4ee5\u4f7f\u7528\u00a0<code>@SerialName</code>\u00a0\u6ce8\u89e3\u66f4\u6539 JSON \u5b57\u6bb5\u7684\u540d\u79f0\uff0c\u4f46\u6b64\u7c7b\u91cd\u547d\u540d\u4f1a\u963b\u6b62\u4f7f\u7528\u65e7\u540d\u79f0\u89e3\u7801\u6570\u636e\u3002\u4e3a\u4e86\u652f\u6301\u4e00\u4e2a Kotlin \u5c5e\u6027\u7684\u591a\u4e2a JSON \u540d\u79f0\uff0c\u53ef\u4ee5\u4f7f\u7528 JsonNames \u6ce8\u89e3\uff1a</p> <pre><code>@Serializable\ndata class Project(@JsonNames(\"title\") val name: String)\n\nfun main() {\n  val project = Json.decodeFromString&lt;Project&gt;(\"\"\"{\"name\":\"kotlinx.serialization\"}\"\"\")\n  println(project)\n  val oldProject = Json.decodeFromString&lt;Project&gt;(\"\"\"{\"title\":\"kotlinx.coroutines\"}\"\"\")\n  println(oldProject)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>As you can see, both\u00a0<code>name</code>\u00a0and\u00a0<code>title</code>\u00a0Json fields correspond to\u00a0<code>name</code>\u00a0property: \u5982\u60a8\u6240\u89c1\uff0c\u8fd9\u4e24\u4e2a\u00a0<code>name</code>\u00a0\u5b57\u6bb5\u548c\u00a0<code>title</code>\u00a0Json \u5b57\u6bb5\u90fd\u5bf9\u5e94\u4e8e\u00a0<code>name</code>\u00a0property\uff1a</p> <pre><code>Project(name=kotlinx.serialization)\nProject(name=kotlinx.coroutines)\n</code></pre> <p>Support for\u00a0JsonNames\u00a0annotation is controlled by the\u00a0JsonBuilder.useAlternativeNames\u00a0flag. Unlike most of the configuration flags, this one is enabled by default and does not need attention unless you want to do some fine-tuning. \u5bf9 JsonNames \u6ce8\u91ca\u7684\u652f\u6301\u7531 JsonBuilder.useAlternativeNames \u6807\u5fd7\u63a7\u5236\u3002\u4e0e\u5927\u591a\u6570\u914d\u7f6e\u6807\u5fd7\u4e0d\u540c\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6b64\u6807\u5fd7\u5904\u4e8e\u542f\u7528\u72b6\u6001\uff0c\u9664\u975e\u60a8\u60f3\u8fdb\u884c\u4e00\u4e9b\u5fae\u8c03\uff0c\u5426\u5219\u4e0d\u9700\u8981\u6ce8\u610f\u3002</p>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#coercing-input-values","title":"Coercing input values\u00a0\u5f3a\u5236\u8f93\u5165\u503c","text":"<p>JSON formats that from third parties can evolve, sometimes changing the field types. This can lead to exceptions during decoding when the actual values do not match the expected values. The default\u00a0Json\u00a0implementation is strict with respect to input types as was demonstrated in the\u00a0Type safety is enforced\u00a0section. You can relax this restriction using the\u00a0coerceInputValues\u00a0property. \u6765\u81ea\u7b2c\u4e09\u65b9\u7684 JSON \u683c\u5f0f\u53ef\u4ee5\u6f14\u53d8\uff0c\u6709\u65f6\u4f1a\u66f4\u6539\u5b57\u6bb5\u7c7b\u578b\u3002\u5f53\u5b9e\u9645\u503c\u4e0e\u9884\u671f\u503c\u4e0d\u5339\u914d\u65f6\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5bfc\u81f4\u89e3\u7801\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u5f02\u5e38\u3002\u9ed8\u8ba4\u7684 Json \u5b9e\u73b0\u5bf9\u8f93\u5165\u7c7b\u578b\u662f\u4e25\u683c\u7684\uff0c\u5982\u5f3a\u5236\u7c7b\u578b\u5b89\u5168\u90e8\u5206\u6240\u793a\u3002\u53ef\u4ee5\u4f7f\u7528 coerceInputValues \u5c5e\u6027\u653e\u5bbd\u6b64\u9650\u5236\u3002</p> <p>This property only affects decoding. It treats a limited subset of invalid input values as if the corresponding property was missing and uses the default value of the corresponding property instead. The current list of supported invalid values is: \u6b64\u5c5e\u6027\u4ec5\u5f71\u54cd\u89e3\u7801\u3002\u5b83\u5c06\u65e0\u6548\u8f93\u5165\u503c\u7684\u6709\u9650\u5b50\u96c6\u89c6\u4e3a\u7f3a\u5c11\u76f8\u5e94\u7684\u5c5e\u6027\uff0c\u5e76\u6539\u7528\u76f8\u5e94\u5c5e\u6027\u7684\u9ed8\u8ba4\u503c\u3002\u5f53\u524d\u652f\u6301\u7684\u65e0\u6548\u503c\u5217\u8868\u4e3a\uff1a</p> <ul> <li><code>null</code>\u00a0inputs for non-nullable types <code>null</code>\u00a0\u4e0d\u53ef\u4e3a null \u7c7b\u578b\u7684\u8f93\u5165</li> <li>unknown values for enums     \u679a\u4e3e\u7684\u672a\u77e5\u503c</li> </ul> <p>This list may be expanded in the future, so that\u00a0Json\u00a0instance configured with this property becomes even more permissive to invalid value in the input, replacing them with defaults. \u5c06\u6765\u53ef\u80fd\u4f1a\u6269\u5c55\u6b64\u5217\u8868\uff0c\u4ee5\u4fbf\u4f7f\u7528\u6b64\u5c5e\u6027\u914d\u7f6e\u7684 Json \u5b9e\u4f8b\u5bf9\u8f93\u5165\u4e2d\u7684\u65e0\u6548\u503c\u66f4\u52a0\u5bbd\u5bb9\uff0c\u5c06\u5176\u66ff\u6362\u4e3a\u9ed8\u8ba4\u503c\u3002</p> <p>See the example from the\u00a0Type safety is enforced\u00a0section: \u8bf7\u53c2\u9605\u5f3a\u5236\u6267\u884c\u7c7b\u578b\u5b89\u5168\u90e8\u5206\u4e2d\u7684\u793a\u4f8b\uff1a</p> <pre><code>val format = Json { coerceInputValues = true }\n\n@Serializable\ndata class Project(val name: String, val language: String = \"Kotlin\")\n\nfun main() {\n    val data = format.decodeFromString&lt;Project&gt;(\"\"\"\n        {\"name\":\"kotlinx.serialization\",\"language\":null}\n    \"\"\")\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The invalid\u00a0<code>null</code>\u00a0value for the\u00a0<code>language</code>\u00a0property was coerced into the default value: <code>language</code>\u00a0\u8be5\u5c5e\u6027\u7684\u65e0\u6548\u00a0<code>null</code>\u00a0\u503c\u88ab\u5f3a\u5236\u4e3a\u9ed8\u8ba4\u503c\uff1a</p> <pre><code>Project(name=kotlinx.serialization, language=Kotlin)\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#encoding-defaults","title":"Encoding defaults\u00a0\u7f16\u7801\u9ed8\u8ba4\u503c","text":"<p>Default values of properties are not encoded by default because they will be assigned to missing fields during decoding anyway. See the\u00a0Defaults are not encoded\u00a0section for details and an example. This is especially useful for nullable properties with null defaults and avoids writing the corresponding null values. The default behavior can be changed by setting the\u00a0encodeDefaults\u00a0property to\u00a0<code>true</code>: \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5c5e\u6027\u7684\u9ed8\u8ba4\u503c\u4e0d\u4f1a\u7f16\u7801\uff0c\u56e0\u4e3a\u5b83\u4eec\u65e0\u8bba\u5982\u4f55\u90fd\u4f1a\u5728\u89e3\u7801\u8fc7\u7a0b\u4e2d\u5206\u914d\u7ed9\u7f3a\u5931\u7684\u5b57\u6bb5\u3002\u6709\u5173\u8be6\u7ec6\u4fe1\u606f\u548c\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605\u9ed8\u8ba4\u503c\u672a\u7f16\u7801\u90e8\u5206\u3002\u8fd9\u5bf9\u4e8e\u9ed8\u8ba4\u503c\u4e3a null \u7684\u53ef\u4e3a null \u5c5e\u6027\u7279\u522b\u6709\u7528\uff0c\u5e76\u907f\u514d\u5199\u5165\u76f8\u5e94\u7684 null \u503c\u3002\u53ef\u4ee5\u901a\u8fc7\u5c06 encodeDefaults \u5c5e\u6027\u8bbe\u7f6e\u4e3a\u00a0<code>true</code>\u00a0\u4ee5\u4e0b\u503c\u6765\u66f4\u6539\u9ed8\u8ba4\u884c\u4e3a\uff1a</p> <pre><code>val format = Json { encodeDefaults = true }\n\n@Serializable\nclass Project(\n    val name: String,\n    val language: String = \"Kotlin\",\n    val website: String? = null\n)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\")\n    println(format.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>It produces the following output which encodes all the property values including the default ones: \u5b83\u751f\u6210\u4ee5\u4e0b\u8f93\u51fa\uff0c\u8be5\u8f93\u51fa\u5bf9\u6240\u6709\u5c5e\u6027\u503c\uff08\u5305\u62ec\u9ed8\u8ba4\u503c\uff09\u8fdb\u884c\u7f16\u7801\uff1a</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"language\":\"Kotlin\",\"website\":null}\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#explicit-nulls-null","title":"Explicit nulls\u00a0\u663e\u5f0f null","text":"<p>By default, all\u00a0<code>null</code>\u00a0values are encoded into JSON strings, but in some cases you may want to omit them. The encoding of\u00a0<code>null</code>\u00a0values can be controlled with the\u00a0explicitNulls\u00a0property. \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6240\u6709\u00a0<code>null</code>\u00a0\u503c\u90fd\u7f16\u7801\u4e3a JSON \u5b57\u7b26\u4e32\uff0c\u4f46\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u5e0c\u671b\u7701\u7565\u5b83\u4eec\u3002\u53ef\u4ee5\u4f7f\u7528 explicitNulls \u5c5e\u6027\u63a7\u5236\u503c\u7684\u00a0<code>null</code>\u00a0\u7f16\u7801\u3002</p> <p>If you set property to\u00a0<code>false</code>, fields with\u00a0<code>null</code>\u00a0values are not encoded into JSON even if the property does not have a default\u00a0<code>null</code>\u00a0value. When decoding such JSON, the absence of a property value is treated as\u00a0<code>null</code>\u00a0for nullable properties without a default value. \u5982\u679c\u5c06 property \u8bbe\u7f6e\u4e3a\u00a0<code>false</code>\u00a0\uff0c\u5219\u5373\u4f7f\u5c5e\u6027\u6ca1\u6709\u9ed8\u8ba4\u00a0<code>null</code>\u00a0\u503c\uff0c\u4e5f\u4e0d\u4f1a\u5c06\u5177\u6709\u00a0<code>null</code>\u00a0\u503c\u7684\u5b57\u6bb5\u7f16\u7801\u4e3a JSON\u3002\u89e3\u7801\u6b64\u7c7b JSON \u65f6\uff0c\u5bf9\u4e8e\u6ca1\u6709\u9ed8\u8ba4\u503c\u7684\u53ef\u4e3a null \u7684\u5c5e\u6027\uff0c\u5c06\u7f3a\u5c11\u5c5e\u6027\u503c\u89c6\u4e3a\u00a0<code>null</code>\u00a0\u7f3a\u5c11\u5c5e\u6027\u503c\u3002</p> <pre><code>val format = Json { explicitNulls = false }\n\n@Serializable\ndata class Project(\n    val name: String,\n    val language: String,\n    val version: String? = \"1.2.2\",\n    val website: String?,\n    val description: String? = null\n)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\", \"Kotlin\", null, null, null)\n    val json = format.encodeToString(data)\n    println(json)\n    println(format.decodeFromString&lt;Project&gt;(json))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>As you can see,\u00a0<code>version</code>,\u00a0<code>website</code>\u00a0and\u00a0<code>description</code>\u00a0fields are not present in output JSON on the first line. After decoding, the missing nullable property\u00a0<code>website</code>\u00a0without a default values has received a\u00a0<code>null</code>\u00a0value, while nullable properties\u00a0<code>version</code>\u00a0and\u00a0<code>description</code>\u00a0are filled with their default values: \u5982\u60a8\u6240\u89c1\uff0c\u00a0<code>version</code>\u00a0\u7b2c\u4e00\u884c\u7684\u8f93\u51fa JSON \u4e2d\u4e0d\u5b58\u5728 \u3001\u00a0<code>website</code>\u00a0\u548c\u00a0<code>description</code>\u00a0\u5b57\u6bb5\u3002\u89e3\u7801\u540e\uff0c\u7f3a\u5c11\u7684\u6ca1\u6709\u9ed8\u8ba4\u503c\u7684\u53ef\u4e3a null \u5c5e\u6027\u00a0<code>website</code>\u00a0\u5df2\u6536\u5230\u4e00\u4e2a\u00a0<code>null</code>\u00a0\u503c\uff0c\u800c\u53ef\u4e3a null \u7684\u5c5e\u6027\u00a0<code>version</code>\u00a0\u5219\u00a0<code>description</code>\u00a0\u7528\u5176\u9ed8\u8ba4\u503c\u586b\u5145\uff1a</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"language\":\"Kotlin\"}\nProject(name=kotlinx.serialization, language=Kotlin, version=1.2.2, website=null, description=null)\n</code></pre> <p><code>explicitNulls</code>\u00a0is\u00a0<code>true</code>\u00a0by default as it is the default behavior across different versions of the library. <code>explicitNulls</code>\u00a0\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u00a0<code>true</code>\u00a0\u56e0\u4e3a\u5b83\u662f\u5e93\u4e0d\u540c\u7248\u672c\u7684\u9ed8\u8ba4\u884c\u4e3a\u3002</p>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#allowing-structured-map-keys","title":"Allowing structured map keys  \u5141\u8bb8\u7ed3\u6784\u5316\u6620\u5c04\u952e","text":"<p>JSON format does not natively support the concept of a map with structured keys. Keys in JSON objects are strings and can be used to represent only primitives or enums by default. You can enable non-standard support for structured keys with the\u00a0allowStructuredMapKeys\u00a0property. JSON \u683c\u5f0f\u672c\u8eab\u4e0d\u652f\u6301\u5177\u6709\u7ed3\u6784\u5316\u952e\u7684\u6620\u5c04\u7684\u6982\u5ff5\u3002JSON \u5bf9\u8c61\u4e2d\u7684\u952e\u662f\u5b57\u7b26\u4e32\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u53ea\u80fd\u7528\u4e8e\u8868\u793a\u57fa\u5143\u6216\u679a\u4e3e\u3002\u53ef\u4ee5\u4f7f\u7528 allowStructuredMapKeys \u5c5e\u6027\u542f\u7528\u5bf9\u7ed3\u6784\u5316\u952e\u7684\u975e\u6807\u51c6\u652f\u6301\u3002</p> <p>This is how you can serialize a map with keys of a user-defined class: \u4ee5\u4e0b\u662f\u4f7f\u7528\u7528\u6237\u5b9a\u4e49\u7c7b\u7684\u952e\u5e8f\u5217\u5316\u6620\u5c04\u7684\u65b9\u6cd5\uff1a</p> <pre><code>val format = Json { allowStructuredMapKeys = true }\n\n@Serializable\ndata class Project(val name: String)\n\nfun main() {\n    val map = mapOf(\n        Project(\"kotlinx.serialization\") to \"Serialization\",\n        Project(\"kotlinx.coroutines\") to \"Coroutines\"\n    )\n    println(format.encodeToString(map))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The map with structured keys gets represented as JSON array with the following items:\u00a0<code>[key1, value1, key2, value2,...]</code>. \u5177\u6709\u7ed3\u6784\u5316\u952e\u7684\u6620\u5c04\u8868\u793a\u4e3a\u5305\u542b\u4ee5\u4e0b\u9879\u7684 JSON \u6570\u7ec4\uff1a\u00a0<code>[key1, value1, key2, value2,...]</code>\u00a0.</p> <pre><code>[{\"name\":\"kotlinx.serialization\"},\"Serialization\",{\"name\":\"kotlinx.coroutines\"},\"Coroutines\"]\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#allowing-special-floating-point-values","title":"Allowing special floating-point values  \u5141\u8bb8\u7279\u6b8a\u7684\u6d6e\u70b9\u503c","text":"<p>By default, special floating-point values like\u00a0Double.NaN\u00a0and infinities are not supported in JSON because the JSON specification prohibits it. You can enable their encoding using the\u00a0allowSpecialFloatingPointValues\u00a0property: \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cJSON \u4e0d\u652f\u6301 Double.NaN \u548c\u65e0\u7a77\u5927\u7b49\u7279\u6b8a\u6d6e\u70b9\u503c\uff0c\u56e0\u4e3a JSON \u89c4\u8303\u7981\u6b62\u8fd9\u6837\u505a\u3002\u53ef\u4ee5\u4f7f\u7528 allowSpecialFloatingPointValues \u5c5e\u6027\u542f\u7528\u5176\u7f16\u7801\uff1a</p> <pre><code>val format = Json { allowSpecialFloatingPointValues = true }\n\n@Serializable\nclass Data(\n    val value: Double\n)\n\nfun main() {\n    val data = Data(Double.NaN)\n    println(format.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>This example produces the following non-stardard JSON output, yet it is a widely used encoding for special values in JVM world: \u6b64\u793a\u4f8b\u751f\u6210\u4ee5\u4e0b\u975e stardard JSON \u8f93\u51fa\uff0c\u4f46\u5b83\u662f JVM \u4e16\u754c\u4e2d\u5e7f\u6cdb\u4f7f\u7528\u7684\u7279\u6b8a\u503c\u7684\u7f16\u7801\uff1a</p> <pre><code>{\"value\":NaN}\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#class-discriminator-for-polymorphism","title":"Class discriminator for polymorphism  \u591a\u6001\u6027\u7684\u7c7b\u9274\u522b\u5668","text":"<p>A key name that specifies a type when you have a polymorphic data can be specified in the\u00a0classDiscriminator\u00a0property: \u53ef\u4ee5\u5728 classDiscriminator \u5c5e\u6027\u4e2d\u6307\u5b9a\u5177\u6709\u591a\u6001\u6570\u636e\u65f6\u6307\u5b9a\u7c7b\u578b\u7684\u952e\u540d\u79f0\uff1a</p> <pre><code>val format = Json { classDiscriminator = \"#class\" }\n\n@Serializable\nsealed class Project {\n    abstract val name: String\n}\n\n@Serializable\n@SerialName(\"owned\")\nclass OwnedProject(override val name: String, val owner: String) : Project()\n\nfun main() {\n    val data: Project = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(format.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>In combination with an explicitly specified\u00a0SerialName\u00a0of the class it provides full control over the resulting JSON object: \u7ed3\u5408\u663e\u5f0f\u6307\u5b9a\u7684\u7c7b\u7684 SerialName\uff0c\u5b83\u63d0\u4f9b\u5bf9\u751f\u6210\u7684 JSON \u5bf9\u8c61\u7684\u5b8c\u5168\u63a7\u5236\uff1a</p> <pre><code>{\"#class\":\"owned\",\"name\":\"kotlinx.coroutines\",\"owner\":\"kotlin\"}\n</code></pre> <p>It is also possible to specify different class discriminators for different hierarchies. Instead of Json instance property, use\u00a0JsonClassDiscriminator\u00a0annotation directly on base serializable class: \u4e5f\u53ef\u4ee5\u4e3a\u4e0d\u540c\u7684\u5c42\u6b21\u7ed3\u6784\u6307\u5b9a\u4e0d\u540c\u7684\u7c7b\u9274\u522b\u5668\u3002\u76f4\u63a5\u5728\u57fa\u53ef\u5e8f\u5217\u5316\u7c7b\u4e0a\u4f7f\u7528 JsonClassDiscriminator \u6ce8\u91ca\uff0c\u800c\u4e0d\u662f Json \u5b9e\u4f8b\u5c5e\u6027\uff1a</p> <pre><code>@Serializable\n@JsonClassDiscriminator(\"message_type\")\nsealed class Base\n</code></pre> <p>This annotation is\u00a0inheritable, so all subclasses of\u00a0<code>Base</code>\u00a0will have the same discriminator: \u8fd9\u4e2a\u6ce8\u89e3\u662f\u53ef\u7ee7\u627f\u7684\uff0c\u6240\u4ee5 \u7684\u6240\u6709\u00a0<code>Base</code>\u00a0\u5b50\u7c7b\u90fd\u5177\u6709\u76f8\u540c\u7684\u9274\u522b\u5668\uff1a</p> <pre><code>@Serializable // Class discriminator is inherited from Base\nsealed class ErrorClass: Base()\n</code></pre> <p>To learn more about inheritable serial annotations, see documentation for\u00a0InheritableSerialInfo. \u82e5\u8981\u4e86\u89e3\u6709\u5173\u53ef\u7ee7\u627f\u4e32\u884c\u6ce8\u89e3\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 InheritableSerialInfo \u7684\u6587\u6863\u3002</p> <p>Note that it is not possible to explicitly specify different class discriminators in subclasses of\u00a0<code>Base</code>. Only hierarchies with empty intersections can have different discriminators. \u8bf7\u6ce8\u610f\uff0c\u4e0d\u53ef\u80fd\u5728 \u7684\u00a0<code>Base</code>\u00a0\u5b50\u7c7b\u4e2d\u663e\u5f0f\u6307\u5b9a\u4e0d\u540c\u7684\u7c7b\u9274\u522b\u5668\u3002\u53ea\u6709\u5177\u6709\u7a7a\u4ea4\u96c6\u7684\u5c42\u6b21\u7ed3\u6784\u624d\u80fd\u5177\u6709\u4e0d\u540c\u7684\u9274\u522b\u5668\u3002</p> <p>Discriminator specified in the annotation has priority over discriminator in Json configuration: \u5728 Json \u914d\u7f6e\u4e2d\uff0c\u6ce8\u89e3\u4e2d\u6307\u5b9a\u7684\u9274\u522b\u5668\u4f18\u5148\u4e8e\u9274\u522b\u5668\uff1a</p> <pre><code>val format = Json { classDiscriminator = \"#class\" }\n\nfun main() {\n    val data = Message(BaseMessage(\"not found\"), GenericError(404))\n    println(format.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>As you can see, discriminator from the\u00a0<code>Base</code>\u00a0class is used: \u6b63\u5982\u4f60\u6240\u770b\u5230\u7684\uff0c\u4f7f\u7528\u4e86\u7c7b\u4e2d\u7684\u00a0<code>Base</code>\u00a0\u9274\u522b\u5668\uff1a</p> <pre><code>{\"message\":{\"message_type\":\"my.app.BaseMessage\",\"message\":\"not found\"},\"error\":{\"message_type\":\"my.app.GenericError\",\"error_code\":404}}\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#class-discriminator-output-mode","title":"Class discriminator output mode  \u7c7b\u9274\u522b\u5668\u8f93\u51fa\u65b9\u5f0f","text":"<p>Class discriminator provides information for serializing and deserializing\u00a0polymorphic class hierarchies. As shown above, it is only added for polymorphic classes by default. In case you want to encode more or less information for various third party APIs about types in the output, it is possible to control addition of the class discriminator with the\u00a0JsonBuilder.classDiscriminatorMode\u00a0property. \u7c7b\u9274\u522b\u5668\u63d0\u4f9b\u7528\u4e8e\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u591a\u6001\u7c7b\u5c42\u6b21\u7ed3\u6784\u7684\u4fe1\u606f\u3002\u5982\u4e0a\u6240\u793a\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u4ec5\u4e3a\u591a\u6001\u7c7b\u6dfb\u52a0\u5b83\u3002\u5982\u679c\u8981\u5bf9\u6709\u5173\u8f93\u51fa\u4e2d\u7c7b\u578b\u7684\u5404\u79cd\u7b2c\u4e09\u65b9 API \u7684\u66f4\u591a\u6216\u66f4\u5c11\u4fe1\u606f\u8fdb\u884c\u7f16\u7801\uff0c\u5219\u53ef\u4ee5\u4f7f\u7528 JsonBuilder.classDiscriminatorMode \u5c5e\u6027\u63a7\u5236\u7c7b\u9274\u522b\u5668\u7684\u6dfb\u52a0\u3002</p> <p>For example,\u00a0ClassDiscriminatorMode.NONE\u00a0does not add class discriminator at all, in case the receiving party is not interested in Kotlin types: \u4f8b\u5982\uff0cClassDiscriminatorMode.NONE \u6839\u672c\u4e0d\u6dfb\u52a0\u7c7b\u9274\u522b\u5668\uff0c\u4ee5\u9632\u63a5\u6536\u65b9\u5bf9 Kotlin \u7c7b\u578b\u4e0d\u611f\u5174\u8da3\uff1a</p> <pre><code>val format = Json { classDiscriminatorMode = ClassDiscriminatorMode.NONE }\n\n@Serializable\nsealed class Project {\n    abstract val name: String\n}\n\n@Serializable\nclass OwnedProject(override val name: String, val owner: String) : Project()\n\nfun main() {\n    val data: Project = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(format.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Note that it would be impossible to deserialize this output back with kotlinx.serialization. \u8bf7\u6ce8\u610f\uff0c\u4e0d\u53ef\u80fd\u4f7f\u7528 kotlinx.serialization \u53cd\u5e8f\u5217\u5316\u6b64\u8f93\u51fa\u3002</p> <pre><code>{\"name\":\"kotlinx.coroutines\",\"owner\":\"kotlin\"}\n</code></pre> <p>Two other available values are\u00a0ClassDiscriminatorMode.POLYMORPHIC\u00a0(default behavior) and\u00a0ClassDiscriminatorMode.ALL_JSON_OBJECTS\u00a0(adds discriminator whenever possible). Consult their documentation for details. \u53e6\u5916\u4e24\u4e2a\u53ef\u7528\u503c\u662f ClassDiscriminatorMode.POLYMORPHIC\uff08\u9ed8\u8ba4\u884c\u4e3a\uff09\u548c ClassDiscriminatorMode.ALL_JSON_OBJECTS\uff08\u5c3d\u53ef\u80fd\u6dfb\u52a0\u9274\u522b\u5668\uff09\u3002\u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u5176\u6587\u6863\u3002</p>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#decoding-enums-in-a-case-insensitive-manner","title":"Decoding enums in a case-insensitive manner  \u4ee5\u4e0d\u533a\u5206\u5927\u5c0f\u5199\u7684\u65b9\u5f0f\u89e3\u7801\u679a\u4e3e","text":"<p>Kotlin\u2019s naming policy recommends\u00a0naming enum values using either uppercase underscore-separated names or upper camel case names.\u00a0Json\u00a0uses exact Kotlin enum values names for decoding by default. However, sometimes third-party JSONs have such values named in lowercase or some mixed case. In this case, it is possible to decode enum values in a case-insensitive manner using\u00a0JsonBuilder.decodeEnumsCaseInsensitive\u00a0property: Kotlin \u7684\u547d\u540d\u7b56\u7565\u5efa\u8bae\u4f7f\u7528\u5927\u5199\u4e0b\u5212\u7ebf\u5206\u9694\u7684\u540d\u79f0\u6216\u5927\u5199\u7684\u9a7c\u5cf0\u5927\u5c0f\u5199\u540d\u79f0\u6765\u547d\u540d\u679a\u4e3e\u503c\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cJson \u4f7f\u7528\u7cbe\u786e\u7684 Kotlin \u679a\u4e3e\u503c\u540d\u79f0\u8fdb\u884c\u89e3\u7801\u3002\u4f46\u662f\uff0c\u6709\u65f6\u7b2c\u4e09\u65b9 JSON \u5177\u6709\u4ee5\u5c0f\u5199\u6216\u6df7\u5408\u5927\u5c0f\u5199\u547d\u540d\u7684\u6b64\u7c7b\u503c\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u4f7f\u7528 JsonBuilder.decodeEnumsCaseInsensitive \u5c5e\u6027\u4ee5\u4e0d\u533a\u5206\u5927\u5c0f\u5199\u7684\u65b9\u5f0f\u89e3\u7801\u679a\u4e3e\u503c\uff1a</p> <pre><code>val format = Json { decodeEnumsCaseInsensitive = true }\n\nenum class Cases { VALUE_A, @JsonNames(\"Alternative\") VALUE_B }\n\n@Serializable\ndata class CasesList(val cases: List&lt;Cases&gt;)\n\nfun main() {\n  println(format.decodeFromString&lt;CasesList&gt;(\"\"\"{\"cases\":[\"value_A\", \"alternative\"]}\"\"\")) \n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>It affects serial names as well as alternative names specified with\u00a0JsonNames\u00a0annotation, so both values are successfully decoded: \u5b83\u4f1a\u5f71\u54cd\u5e8f\u5217\u5316\u540d\u79f0\u4ee5\u53ca\u4f7f\u7528 JsonNames \u6ce8\u91ca\u6307\u5b9a\u7684\u5907\u7528\u540d\u79f0\uff0c\u56e0\u6b64\u8fd9\u4e24\u4e2a\u503c\u90fd\u5df2\u6210\u529f\u89e3\u7801\uff1a</p> <pre><code>CasesList(cases=[VALUE_A, VALUE_B])\n</code></pre> <p>This property does not affect encoding in any way. \u6b64\u5c5e\u6027\u4e0d\u4f1a\u4ee5\u4efb\u4f55\u65b9\u5f0f\u5f71\u54cd\u7f16\u7801\u3002</p>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#global-naming-strategy","title":"Global naming strategy\u00a0\u5168\u5c40\u547d\u540d\u7b56\u7565","text":"<p>If properties\u2019 names in Json input are different from Kotlin ones, it is recommended to specify the name for each property explicitly using\u00a0<code>@SerialName</code>\u00a0annotation. However, there are certain situations where transformation should be applied to every serial name \u2014 such as migration from other frameworks or legacy codebase. For that cases, it is possible to specify a\u00a0namingStrategy\u00a0for a\u00a0Json\u00a0instance.\u00a0<code>kotlinx.serialization</code>\u00a0provides one strategy implementation out of the box, the\u00a0JsonNamingStrategy.SnakeCase: \u5982\u679c Json \u8f93\u5165\u4e2d\u7684\u5c5e\u6027\u540d\u79f0\u4e0e Kotlin \u5c5e\u6027\u540d\u79f0\u4e0d\u540c\uff0c\u5efa\u8bae\u4f7f\u7528\u00a0<code>@SerialName</code>\u00a0\u6ce8\u91ca\u663e\u5f0f\u6307\u5b9a\u6bcf\u4e2a\u5c5e\u6027\u7684\u540d\u79f0\u3002\u4f46\u662f\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5e94\u5c06\u8f6c\u6362\u5e94\u7528\u4e8e\u6bcf\u4e2a\u5e8f\u5217\u5316\u540d\u79f0\uff0c\u4f8b\u5982\u4ece\u5176\u4ed6\u6846\u67b6\u6216\u65e7\u4ee3\u7801\u5e93\u8fc1\u79fb\u3002\u5bf9\u4e8e\u8fd9\u79cd\u60c5\u51b5\uff0c\u53ef\u4ee5\u4e3a Json \u5b9e\u4f8b\u6307\u5b9a namingStrategy\u3002\u00a0<code>kotlinx.serialization</code>\u00a0\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5f00\u7bb1\u5373\u7528\u7684\u7b56\u7565\u5b9e\u73b0\uff0c\u5373 JsonNamingStrategy.SnakeCase\uff1a</p> <pre><code>@Serializable\ndata class Project(val projectName: String, val projectOwner: String)\n\nval format = Json { namingStrategy = JsonNamingStrategy.SnakeCase }\n\nfun main() {\n    val project = format.decodeFromString&lt;Project&gt;(\"\"\"{\"project_name\":\"kotlinx.coroutines\", \"project_owner\":\"Kotlin\"}\"\"\")\n    println(format.encodeToString(project.copy(projectName = \"kotlinx.serialization\")))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>As you can see, both serialization and deserialization work as if all serial names are transformed from camel case to snake case: \u6b63\u5982\u4f60\u6240\u770b\u5230\u7684\uff0c\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u7684\u5de5\u4f5c\u65b9\u5f0f\u5c31\u597d\u50cf\u6240\u6709\u5e8f\u5217\u5316\u540d\u79f0\u90fd\u4ece\u9a86\u9a7c\u5927\u5c0f\u5199\u8f6c\u6362\u4e3a\u86c7\u5927\u5c0f\u5199\u4e00\u6837\uff1a</p> <pre><code>{\"project_name\":\"kotlinx.serialization\",\"project_owner\":\"Kotlin\"}\n</code></pre> <p>There are some caveats one should remember while dealing with a\u00a0JsonNamingStrategy: \u5728\u5904\u7406 JsonNamingStrategy \u65f6\uff0c\u5e94\u8be5\u8bb0\u4f4f\u4e00\u4e9b\u6ce8\u610f\u4e8b\u9879\uff1a</p> <ul> <li> <p>Due to the nature of the\u00a0<code>kotlinx.serialization</code>\u00a0framework, naming strategy transformation is applied to all properties regardless of whether their serial name was taken from the property name or provided by\u00a0SerialName\u00a0annotation. Effectively, it means one cannot avoid transformation by explicitly specifying the serial name. To be able to deserialize non-transformed names,\u00a0JsonNames\u00a0annotation can be used instead.     \u7531\u4e8e\u00a0<code>kotlinx.serialization</code>\u00a0\u6846\u67b6\u7684\u6027\u8d28\uff0c\u547d\u540d\u7b56\u7565\u8f6c\u6362\u5c06\u5e94\u7528\u4e8e\u6240\u6709\u5c5e\u6027\uff0c\u65e0\u8bba\u5176\u5e8f\u5217\u5316\u540d\u79f0\u662f\u4ece\u5c5e\u6027\u540d\u79f0\u4e2d\u83b7\u53d6\u8fd8\u662f\u7531 SerialName \u6ce8\u89e3\u63d0\u4f9b\u3002\u5b9e\u9645\u4e0a\uff0c\u8fd9\u610f\u5473\u7740\u65e0\u6cd5\u901a\u8fc7\u663e\u5f0f\u6307\u5b9a\u5e8f\u5217\u5316\u540d\u79f0\u6765\u907f\u514d\u8f6c\u6362\u3002\u4e3a\u4e86\u80fd\u591f\u53cd\u5e8f\u5217\u5316\u672a\u8f6c\u6362\u7684\u540d\u79f0\uff0c\u53ef\u4ee5\u6539\u7528 JsonNames \u6ce8\u91ca\u3002</p> </li> <li> <p>Collision of the transformed name with any other (transformed) properties serial names or any alternative names specified with\u00a0JsonNames\u00a0will lead to a deserialization exception.     \u8f6c\u6362\u540e\u7684\u540d\u79f0\u4e0e\u4efb\u4f55\u5176\u4ed6\uff08\u8f6c\u6362\u540e\u7684\uff09\u5c5e\u6027\u3001\u5e8f\u5217\u5316\u540d\u79f0\u6216\u4f7f\u7528 JsonNames \u6307\u5b9a\u7684\u4efb\u4f55\u5907\u7528\u540d\u79f0\u53d1\u751f\u51b2\u7a81\u5c06\u5bfc\u81f4\u53cd\u5e8f\u5217\u5316\u5f02\u5e38\u3002</p> </li> <li> <p>Global naming strategies are very implicit: by looking only at the definition of the class, it is impossible to determine which names it will have in the serialized form. As a consequence, naming strategies are not friendly to actions like Find Usages/Rename in IDE, full-text search by grep, etc. For them, the original name and the transformed are two different things; changing one without the other may introduce bugs in many unexpected ways and lead to greater maintenance efforts for code with global naming strategies.     \u5168\u5c40\u547d\u540d\u7b56\u7565\u662f\u975e\u5e38\u9690\u542b\u7684\uff1a\u4ec5\u901a\u8fc7\u67e5\u770b\u7c7b\u7684\u5b9a\u4e49\uff0c\u65e0\u6cd5\u786e\u5b9a\u5b83\u5c06\u5728\u5e8f\u5217\u5316\u5f62\u5f0f\u4e2d\u5177\u6709\u54ea\u4e9b\u540d\u79f0\u3002\u56e0\u6b64\uff0c\u547d\u540d\u7b56\u7565\u5bf9 IDE \u4e2d\u7684 Find Usages/Rename\u3001grep \u5168\u6587\u641c\u7d22\u7b49\u64cd\u4f5c\u4e0d\u53cb\u597d\u3002\u5bf9\u4ed6\u4eec\u6765\u8bf4\uff0c\u539f\u540d\u548c\u6539\u9020\u540e\u662f\u4e24\u56de\u4e8b;\u66f4\u6539\u4e00\u4e2a\u800c\u4e0d\u66f4\u6539\u53e6\u4e00\u4e2a\u53ef\u80fd\u4f1a\u4ee5\u8bb8\u591a\u610f\u60f3\u4e0d\u5230\u7684\u65b9\u5f0f\u5f15\u5165 bug\uff0c\u5e76\u5bfc\u81f4\u5bf9\u5177\u6709\u5168\u5c40\u547d\u540d\u7b56\u7565\u7684\u4ee3\u7801\u8fdb\u884c\u66f4\u5927\u7684\u7ef4\u62a4\u5de5\u4f5c\u3002</p> </li> </ul> <p>Therefore, one should carefully weigh the pros and cons before considering adding global naming strategies to an application. \u56e0\u6b64\uff0c\u5728\u8003\u8651\u5411\u5e94\u7528\u7a0b\u5e8f\u6dfb\u52a0\u5168\u5c40\u547d\u540d\u7b56\u7565\u4e4b\u524d\uff0c\u5e94\u4ed4\u7ec6\u6743\u8861\u5229\u5f0a\u3002</p>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#json-elements-json","title":"Json elements\u00a0Json \u5143\u7d20","text":"<p>Aside from direct conversions between strings and JSON objects, Kotlin serialization offers APIs that allow other ways of working with JSON in the code. For example, you might need to tweak the data before it can parse or otherwise work with such an unstructured data that it does not readily fit into the typesafe world of Kotlin serialization. \u9664\u4e86\u5b57\u7b26\u4e32\u548c JSON \u5bf9\u8c61\u4e4b\u95f4\u7684\u76f4\u63a5\u8f6c\u6362\u5916\uff0cKotlin \u5e8f\u5217\u5316\u8fd8\u63d0\u4f9b\u4e86\u5141\u8bb8\u5728\u4ee3\u7801\u4e2d\u4ee5\u5176\u4ed6\u65b9\u5f0f\u5904\u7406 JSON \u7684 API\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u5148\u8c03\u6574\u6570\u636e\uff0c\u7136\u540e\u624d\u80fd\u89e3\u6790\u6570\u636e\u6216\u4ee5\u5176\u4ed6\u65b9\u5f0f\u5904\u7406\u6b64\u7c7b\u975e\u7ed3\u6784\u5316\u6570\u636e\uff0c\u4f7f\u5176\u4e0d\u5bb9\u6613\u9002\u5e94 Kotlin \u5e8f\u5217\u5316\u7684\u7c7b\u578b\u5b89\u5168\u4e16\u754c\u3002</p> <p>The main concept in this part of the library is\u00a0JsonElement. Read on to learn what you can do with it. \u5e93\u7684\u8fd9\u4e00\u90e8\u5206\u7684\u4e3b\u8981\u6982\u5ff5\u662f JsonElement\u3002\u8bf7\u7ee7\u7eed\u9605\u8bfb\uff0c\u4e86\u89e3\u60a8\u53ef\u4ee5\u7528\u5b83\u505a\u4ec0\u4e48\u3002</p>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#parsing-to-json-element-json","title":"Parsing to Json element\u00a0\u89e3\u6790\u4e3a Json \u5143\u7d20","text":"<p>A string can be\u00a0parsed\u00a0into an instance of\u00a0JsonElement\u00a0with the\u00a0Json.parseToJsonElement\u00a0function. It is called neither decoding nor deserialization because none of that happens in the process. It just parses a JSON and forms an object representing it: \u53ef\u4ee5\u4f7f\u7528 Json.parseToJsonElement \u51fd\u6570\u5c06\u5b57\u7b26\u4e32\u5206\u6790\u4e3a JsonElement \u7684\u5b9e\u4f8b\u3002\u5b83\u65e2\u4e0d\u88ab\u79f0\u4e3a\u89e3\u7801\u4e5f\u4e0d\u79f0\u4e3a\u53cd\u5e8f\u5217\u5316\uff0c\u56e0\u4e3a\u5728\u6b64\u8fc7\u7a0b\u4e2d\u4e0d\u4f1a\u53d1\u751f\u4efb\u4f55\u60c5\u51b5\u3002\u5b83\u53ea\u662f\u89e3\u6790\u4e00\u4e2a JSON \u5e76\u5f62\u6210\u4e00\u4e2a\u8868\u793a\u5b83\u7684\u5bf9\u8c61\uff1a</p> <pre><code>fun main() {\n    val element = Json.parseToJsonElement(\"\"\"\n        {\"name\":\"kotlinx.serialization\",\"language\":\"Kotlin\"}\n    \"\"\")\n    println(element)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>A\u00a0<code>JsonElement</code>\u00a0prints itself as a valid JSON: A\u00a0<code>JsonElement</code>\u00a0\u5c06\u81ea\u8eab\u6253\u5370\u4e3a\u6709\u6548\u7684 JSON\uff1a</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"language\":\"Kotlin\"}\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#types-of-json-elements-json","title":"Types of Json elements\u00a0Json \u5143\u7d20\u7684\u7c7b\u578b","text":"<p>A\u00a0JsonElement\u00a0class has three direct subtypes, closely following JSON grammar: JsonElement \u7c7b\u6709\u4e09\u4e2a\u76f4\u63a5\u5b50\u7c7b\u578b\uff0c\u4e25\u683c\u9075\u5faa JSON \u8bed\u6cd5\uff1a</p> <ul> <li> <p>JsonPrimitive\u00a0represents primitive JSON elements, such as string, number, boolean, and null. Each primitive has a simple string\u00a0content. There is also a\u00a0JsonPrimitive()\u00a0constructor function overloaded to accept various primitive Kotlin types and to convert them to\u00a0<code>JsonPrimitive</code>.     JsonPrimitive \u8868\u793a\u57fa\u5143 JSON \u5143\u7d20\uff0c\u4f8b\u5982\u5b57\u7b26\u4e32\u3001\u6570\u5b57\u3001\u5e03\u5c14\u503c\u548c null\u3002\u6bcf\u4e2a\u57fa\u5143\u90fd\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u5b57\u7b26\u4e32\u5185\u5bb9\u3002\u8fd8\u6709\u4e00\u4e2a JsonPrimitive\uff08\uff09 \u6784\u9020\u51fd\u6570\u91cd\u8f7d\uff0c\u7528\u4e8e\u63a5\u53d7\u5404\u79cd\u539f\u59cb Kotlin \u7c7b\u578b\u5e76\u5c06\u5b83\u4eec\u8f6c\u6362\u4e3a\u00a0<code>JsonPrimitive</code>\u00a0.</p> </li> <li> <p>JsonArray\u00a0represents a JSON\u00a0<code>[...]</code>\u00a0array. It is a Kotlin\u00a0List\u00a0of\u00a0<code>JsonElement</code>\u00a0items.     JsonArray \u8868\u793a JSON\u00a0<code>[...]</code>\u00a0\u6570\u7ec4\u3002\u5b83\u662f Kotlin \u9879\u76ee\u5217\u8868\u00a0<code>JsonElement</code>\u00a0\u3002</p> </li> <li> <p>JsonObject\u00a0represents a JSON\u00a0<code>{...}</code>\u00a0object. It is a Kotlin\u00a0Map\u00a0from\u00a0<code>String</code>\u00a0keys to\u00a0<code>JsonElement</code>\u00a0values.     JsonObject \u8868\u793a JSON\u00a0<code>{...}</code>\u00a0\u5bf9\u8c61\u3002\u5b83\u662f\u4ece\u00a0<code>String</code>\u00a0\u952e\u5230\u00a0<code>JsonElement</code>\u00a0\u503c\u7684 Kotlin \u6620\u5c04\u3002</p> </li> </ul> <p>The\u00a0<code>JsonElement</code>\u00a0class has extensions that cast it to its corresponding subtypes:\u00a0jsonPrimitive,\u00a0jsonArray,\u00a0jsonObject. The\u00a0<code>JsonPrimitive</code>\u00a0class, in turn, provides converters to Kotlin primitive types:\u00a0int,\u00a0intOrNull,\u00a0long,\u00a0longOrNull, and similar ones for other types. This is how you can use them for processing JSON whose structure you know: \u8be5\u00a0<code>JsonElement</code>\u00a0\u7c7b\u5177\u6709\u5c06\u5176\u8f6c\u6362\u4e3a\u5176\u76f8\u5e94\u5b50\u7c7b\u578b\u7684\u6269\u5c55\uff1ajsonPrimitive\u3001jsonArray\u3001jsonObject\u3002\u53cd\u8fc7\u6765\uff0c\u8be5\u00a0<code>JsonPrimitive</code>\u00a0\u7c7b\u63d0\u4f9b Kotlin \u57fa\u5143\u7c7b\u578b\u7684\u8f6c\u6362\u5668\uff1aint\u3001intOrNull\u3001long\u3001longOrNull \u548c\u5176\u4ed6\u7c7b\u578b\u7684\u7c7b\u4f3c\u8f6c\u6362\u5668\u3002\u4ee5\u4e0b\u662f\u5982\u4f55\u4f7f\u7528\u5b83\u4eec\u6765\u5904\u7406\u60a8\u77e5\u9053\u5176\u7ed3\u6784\u7684 JSON\uff1a</p> <pre><code>fun main() {\n    val element = Json.parseToJsonElement(\"\"\"\n        {\n            \"name\": \"kotlinx.serialization\",\n            \"forks\": [{\"votes\": 42}, {\"votes\": 9000}, {}]\n        }\n    \"\"\")\n    val sum = element\n        .jsonObject[\"forks\"]!!\n        .jsonArray.sumOf { it.jsonObject[\"votes\"]?.jsonPrimitive?.int ?: 0 }\n    println(sum)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The above example sums\u00a0<code>votes</code>\u00a0in all objects in the\u00a0<code>forks</code>\u00a0array, ignoring the objects that have no\u00a0<code>votes</code>: \u4e0a\u9762\u7684\u4f8b\u5b50\u5bf9\u00a0<code>votes</code> <code>forks</code>\u00a0\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5bf9\u8c61\u6c42\u548c\uff0c\u5ffd\u7565\u6ca1\u6709\u00a0<code>votes</code>\u00a0\u7684\u5bf9\u8c61\uff1a</p> <pre><code>9042\n</code></pre> <p>Note that the execution will fail if the structure of the data is otherwise different. \u8bf7\u6ce8\u610f\uff0c\u5982\u679c\u6570\u636e\u7ed3\u6784\u5728\u5176\u4ed6\u65b9\u9762\u4e0d\u540c\uff0c\u5219\u6267\u884c\u5c06\u5931\u8d25\u3002</p>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#json-element-builders-json","title":"Json element builders\u00a0Json \u5143\u7d20\u751f\u6210\u5668","text":"<p>You can construct instances of specific\u00a0JsonElement\u00a0subtypes using the respective builder functions\u00a0buildJsonArray\u00a0and\u00a0buildJsonObject. They provide a DSL to define the resulting JSON structure. It is similar to Kotlin standard library collection builders, but with a JSON-specific convenience of more type-specific overloads and inner builder functions. The following example shows all the key features: \u60a8\u53ef\u4ee5\u4f7f\u7528\u76f8\u5e94\u7684\u6784\u5efa\u5668\u51fd\u6570 buildJsonArray \u548c buildJsonObject \u6784\u9020\u7279\u5b9a JsonElement \u5b50\u7c7b\u578b\u7684\u5b9e\u4f8b\u3002\u5b83\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a DSL \u6765\u5b9a\u4e49\u751f\u6210\u7684 JSON \u7ed3\u6784\u3002\u5b83\u7c7b\u4f3c\u4e8e Kotlin \u6807\u51c6\u5e93\u96c6\u5408\u6784\u5efa\u5668\uff0c\u4f46\u5177\u6709\u7279\u5b9a\u4e8e JSON \u7684\u4fbf\u5229\u6027\uff0c\u5305\u62ec\u66f4\u591a\u7279\u5b9a\u4e8e\u7c7b\u578b\u7684\u91cd\u8f7d\u548c\u5185\u90e8\u6784\u5efa\u5668\u51fd\u6570\u3002\u4ee5\u4e0b\u793a\u4f8b\u663e\u793a\u4e86\u6240\u6709\u5173\u952e\u529f\u80fd\uff1a</p> <pre><code>fun main() {\n    val element = buildJsonObject {\n        put(\"name\", \"kotlinx.serialization\")\n        putJsonObject(\"owner\") {\n            put(\"name\", \"kotlin\")\n        }\n        putJsonArray(\"forks\") {\n            addJsonObject {\n                put(\"votes\", 42)\n            }\n            addJsonObject {\n                put(\"votes\", 9000)\n            }\n        }\n    }\n    println(element)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>As a result, you get a proper JSON string: \u56e0\u6b64\uff0c\u4f60\u4f1a\u5f97\u5230\u4e00\u4e2a\u6b63\u786e\u7684 JSON \u5b57\u7b26\u4e32\uff1a</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"owner\":{\"name\":\"kotlin\"},\"forks\":[{\"votes\":42},{\"votes\":9000}]}\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#decoding-json-elements-json","title":"Decoding Json elements\u00a0\u89e3\u7801 Json \u5143\u7d20","text":"<p>An instance of the\u00a0JsonElement\u00a0class can be decoded into a serializable object using the\u00a0Json.decodeFromJsonElement\u00a0function: \u53ef\u4ee5\u4f7f\u7528 Json.decodeFromJsonElement \u51fd\u6570\u5c06 JsonElement \u7c7b\u7684\u5b9e\u4f8b\u89e3\u7801\u4e3a\u53ef\u5e8f\u5217\u5316\u5bf9\u8c61\uff1a</p> <pre><code>@Serializable\ndata class Project(val name: String, val language: String)\n\nfun main() {\n    val element = buildJsonObject {\n        put(\"name\", \"kotlinx.serialization\")\n        put(\"language\", \"Kotlin\")\n    }\n    val data = Json.decodeFromJsonElement&lt;Project&gt;(element)\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The result is exactly what you would expect: \u7ed3\u679c\u6b63\u662f\u60a8\u6240\u671f\u671b\u7684\uff1a</p> <pre><code>Project(name=kotlinx.serialization, language=Kotlin)\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#encoding-literal-json-content-experimental","title":"Encoding literal Json content (experimental)","text":"<p>\u5bf9\u6587\u5b57 Json \u5185\u5bb9\u8fdb\u884c\u7f16\u7801\uff08\u5b9e\u9a8c\u6027\uff09</p> <p>This functionality is experimental and requires opting-in to\u00a0the experimental Kotlinx Serialization API. \u6b64\u529f\u80fd\u662f\u5b9e\u9a8c\u6027\u7684\uff0c\u9700\u8981\u9009\u62e9\u52a0\u5165\u5b9e\u9a8c\u6027\u7684 Kotlinx \u5e8f\u5217\u5316 API\u3002</p> <p>In some cases it might be necessary to encode an arbitrary unquoted value. This can be achieved with\u00a0JsonUnquotedLiteral. \u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u53ef\u80fd\u9700\u8981\u5bf9\u4efb\u610f\u4e0d\u5e26\u5f15\u53f7\u7684\u503c\u8fdb\u884c\u7f16\u7801\u3002\u8fd9\u53ef\u4ee5\u901a\u8fc7 JsonUnquotedLiteral \u5b9e\u73b0\u3002</p>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#serializing-large-decimal-numbers-large-decimal","title":"Serializing large decimal numbers  \u5e8f\u5217\u5316large decimal\u7c7b\u578b\u6570\u5b57","text":"<p>The JSON specification does not restrict the size or precision of numbers, however it is not possible to serialize numbers of arbitrary size or precision using\u00a0JsonPrimitive(). JSON \u89c4\u8303\u4e0d\u9650\u5236\u6570\u5b57\u7684\u5927\u5c0f\u6216\u7cbe\u5ea6\uff0c\u4f46\u662f\u65e0\u6cd5\u4f7f\u7528 JsonPrimitive\uff08\uff09 \u5e8f\u5217\u5316\u4efb\u610f\u5927\u5c0f\u6216\u7cbe\u5ea6\u7684\u6570\u5b57\u3002</p> <p>If\u00a0Double\u00a0is used, then the numbers are limited in precision, meaning that large numbers are truncated. When using Kotlin/JVM\u00a0BigDecimal\u00a0can be used instead, but\u00a0JsonPrimitive()\u00a0will encode the value as a string, not a number. \u5982\u679c\u4f7f\u7528 Double\uff0c\u5219\u6570\u5b57\u7684\u7cbe\u5ea6\u6709\u9650\uff0c\u8fd9\u610f\u5473\u7740\u5927\u6570\u5b57\u4f1a\u88ab\u622a\u65ad\u3002\u4f7f\u7528 Kotlin/JVM \u65f6\uff0c\u53ef\u4ee5\u6539\u7528 BigClimal\uff0c\u4f46 JsonPrimitive\uff08\uff09 \u4f1a\u5c06\u503c\u7f16\u7801\u4e3a\u5b57\u7b26\u4e32\uff0c\u800c\u4e0d\u662f\u6570\u5b57\u3002</p> <pre><code>import java.math.BigDecimal\n\nval format = Json { prettyPrint = true }\n\nfun main() {\n    val pi = BigDecimal(\"3.141592653589793238462643383279\")\n\n    val piJsonDouble = JsonPrimitive(pi.toDouble())\n    val piJsonString = JsonPrimitive(pi.toString())\n\n    val piObject = buildJsonObject {\n        put(\"pi_double\", piJsonDouble)\n        put(\"pi_string\", piJsonString)\n    }\n\n    println(format.encodeToString(piObject))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Even though\u00a0<code>pi</code>\u00a0was defined as a number with 30 decimal places, the resulting JSON does not reflect this. The\u00a0Double\u00a0value is truncated to 15 decimal places, and the String is wrapped in quotes - which is not a JSON number. \u5c3d\u7ba1\u00a0<code>pi</code>\u00a0\u88ab\u5b9a\u4e49\u4e3a\u5c0f\u6570\u70b9\u540e 30 \u4f4d\u7684\u6570\u5b57\uff0c\u4f46\u751f\u6210\u7684 JSON \u5e76\u672a\u53cd\u6620\u8fd9\u4e00\u70b9\u3002Double \u503c\u88ab\u622a\u65ad\u5230\u5c0f\u6570\u70b9\u540e 15 \u4f4d\uff0cString \u7528\u5f15\u53f7\u62ec\u8d77\u6765 - \u8fd9\u4e0d\u662f JSON \u6570\u5b57\u3002</p> <pre><code>{\n    \"pi_double\": 3.141592653589793,\n    \"pi_string\": \"3.141592653589793238462643383279\"\n}\n</code></pre> <p>To avoid precision loss, the string value of\u00a0<code>pi</code>\u00a0can be encoded using\u00a0JsonUnquotedLiteral. \u4e3a\u4e86\u907f\u514d\u7cbe\u5ea6\u635f\u5931\uff0c\u53ef\u4ee5\u4f7f\u7528 JsonUnquotedLiteral \u5bf9 \u7684\u00a0<code>pi</code>\u00a0\u5b57\u7b26\u4e32\u503c\u8fdb\u884c\u7f16\u7801\u3002</p> <pre><code>import java.math.BigDecimal\n\nval format = Json { prettyPrint = true }\n\nfun main() {\n    val pi = BigDecimal(\"3.141592653589793238462643383279\")\n\n    // use JsonUnquotedLiteral to encode raw JSON content\n    val piJsonLiteral = JsonUnquotedLiteral(pi.toString())\n\n    val piJsonDouble = JsonPrimitive(pi.toDouble())\n    val piJsonString = JsonPrimitive(pi.toString())\n\n    val piObject = buildJsonObject {\n        put(\"pi_literal\", piJsonLiteral)\n        put(\"pi_double\", piJsonDouble)\n        put(\"pi_string\", piJsonString)\n    }\n\n    println(format.encodeToString(piObject))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p><code>pi_literal</code>\u00a0now accurately matches the value defined. <code>pi_literal</code>\u00a0\u73b0\u5728\u4e0e\u5b9a\u4e49\u7684\u503c\u51c6\u786e\u5339\u914d\u3002</p> <pre><code>{\n    \"pi_literal\": 3.141592653589793238462643383279,\n    \"pi_double\": 3.141592653589793,\n    \"pi_string\": \"3.141592653589793238462643383279\"\n}\n</code></pre> <p>To decode\u00a0<code>pi</code>\u00a0back to a\u00a0BigDecimal, the string content of the\u00a0JsonPrimitive\u00a0can be used. \u82e5\u8981\u89e3\u7801\u00a0<code>pi</code>\u00a0\u56de BigDecimal\uff0c\u53ef\u4ee5\u4f7f\u7528 JsonPrimitive \u7684\u5b57\u7b26\u4e32\u5185\u5bb9\u3002</p> <p>(This demonstration uses a\u00a0JsonPrimitive\u00a0for simplicity. For a more re-usable method of handling serialization, see\u00a0Json Transformations\u00a0below.) \uff08\u4e3a\u7b80\u5355\u8d77\u89c1\uff0c\u6b64\u6f14\u793a\u4f7f\u7528 JsonPrimitive\u3002\u6709\u5173\u5904\u7406\u5e8f\u5217\u5316\u7684\u66f4\u53ef\u91cd\u7528\u7684\u65b9\u6cd5\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Json \u8f6c\u6362\u3002</p> <pre><code>import java.math.BigDecimal\n\nfun main() {\n    val piObjectJson = \"\"\"\n          {\n              \"pi_literal\": 3.141592653589793238462643383279\n          }\n      \"\"\".trimIndent()\n\n    val piObject: JsonObject = Json.decodeFromString(piObjectJson)\n\n    val piJsonLiteral = piObject[\"pi_literal\"]!!.jsonPrimitive.content\n\n    val pi = BigDecimal(piJsonLiteral)\n\n    println(pi)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The exact value of\u00a0<code>pi</code>\u00a0is decoded, with all 30 decimal places of precision that were in the source JSON. \u5bf9 \u7684\u00a0<code>pi</code>\u00a0\u786e\u5207\u503c\u8fdb\u884c\u89e3\u7801\uff0c\u5e76\u5177\u6709\u6e90 JSON \u4e2d\u7684\u6240\u6709 30 \u4f4d\u5c0f\u6570\u7cbe\u5ea6\u3002</p> <pre><code>3.141592653589793238462643383279\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#using-jsonunquotedliteral-to-create-a-literal-unquoted-value-of-null-is-forbidden-jsonunquotedliteral-null","title":"Using\u00a0<code>JsonUnquotedLiteral</code>\u00a0to create a literal unquoted value of\u00a0<code>null</code>\u00a0is forbidden  \u7981\u6b62\u7528\u4e8e\u00a0<code>JsonUnquotedLiteral</code>\u00a0\u521b\u5efa \u7684\u00a0<code>null</code>\u00a0\u6587\u5b57\u672a\u52a0\u5f15\u53f7\u7684\u503c","text":"<p>To avoid creating an inconsistent state, encoding a String equal to\u00a0<code>\"null\"</code>\u00a0is forbidden. Use\u00a0JsonNull\u00a0or\u00a0JsonPrimitive\u00a0instead. \u4e3a\u907f\u514d\u521b\u5efa\u4e0d\u4e00\u81f4\u7684\u72b6\u6001\uff0c\u7981\u6b62\u5bf9\u7b49\u4e8e \u7684\u00a0<code>\"null\"</code>\u00a0\u5b57\u7b26\u4e32\u8fdb\u884c\u7f16\u7801\u3002\u8bf7\u6539\u7528 JsonNull \u6216 JsonPrimitive\u3002</p> <pre><code>fun main() {\n    // caution: creating null with JsonUnquotedLiteral will cause an exception! \n    JsonUnquotedLiteral(\"null\")\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>Exception in thread \"main\" kotlinx.serialization.json.internal.JsonEncodingException: Creating a literal unquoted value of 'null' is forbidden. If you want to create JSON null literal, use JsonNull object, otherwise, use JsonPrimitive\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#json-transformations-json","title":"Json transformations\u00a0Json \u8f6c\u6362","text":"<p>To affect the shape and contents of JSON output after serialization, or adapt input to deserialization, it is possible to write a\u00a0custom serializer. However, it may be inconvenient to carefully follow\u00a0Encoder\u00a0and\u00a0Decoder\u00a0calling conventions, especially for relatively small and easy tasks. For that purpose, Kotlin serialization provides an API that can reduce the burden of implementing a custom serializer to a problem of manipulating a Json elements tree. \u82e5\u8981\u5728\u5e8f\u5217\u5316\u540e\u5f71\u54cd JSON \u8f93\u51fa\u7684\u5f62\u72b6\u548c\u5185\u5bb9\uff0c\u6216\u4f7f\u8f93\u5165\u9002\u5e94\u53cd\u5e8f\u5217\u5316\uff0c\u53ef\u4ee5\u7f16\u5199\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002\u4f46\u662f\uff0c\u4ed4\u7ec6\u9075\u5faa\u7f16\u7801\u5668\u548c\u89e3\u7801\u5668\u8c03\u7528\u7ea6\u5b9a\u53ef\u80fd\u4f1a\u5e26\u6765\u4e0d\u4fbf\uff0c\u5c24\u5176\u662f\u5bf9\u4e8e\u76f8\u5bf9\u8f83\u5c0f\u7684\u7b80\u5355\u4efb\u52a1\u3002\u4e3a\u6b64\uff0cKotlin \u5e8f\u5217\u5316\u63d0\u4f9b\u4e86\u4e00\u4e2a API\uff0c\u53ef\u4ee5\u5c06\u5b9e\u73b0\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u7684\u8d1f\u62c5\u51cf\u5c11\u5230\u64cd\u4f5c Json \u5143\u7d20\u6811\u7684\u95ee\u9898\u3002</p> <p>We recommend that you get familiar with the\u00a0Serializers\u00a0chapter: among other things, it explains how custom serializers are bound to classes. \u6211\u4eec\u5efa\u8bae\u60a8\u719f\u6089\u5e8f\u5217\u5316\u7a0b\u5e8f\u4e00\u7ae0\uff1a\u9664\u5176\u4ed6\u5185\u5bb9\u5916\uff0c\u5b83\u8fd8\u89e3\u91ca\u4e86\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u5982\u4f55\u7ed1\u5b9a\u5230\u7c7b\u3002</p> <p>Transformation capabilities are provided by the abstract\u00a0JsonTransformingSerializer\u00a0class which implements\u00a0KSerializer. Instead of direct interaction with\u00a0<code>Encoder</code>\u00a0or\u00a0<code>Decoder</code>, this class asks you to supply transformations for JSON tree represented by the\u00a0JsonElement\u00a0class using the<code>transformSerialize</code>\u00a0and\u00a0<code>transformDeserialize</code>\u00a0methods. Let\u2019s take a look at the examples. \u8f6c\u6362\u529f\u80fd\u7531\u5b9e\u73b0 KSerializer \u7684\u62bd\u8c61 JsonTransformingSerializer \u7c7b\u63d0\u4f9b\u3002\u6b64\u7c7b\u4e0d\u76f4\u63a5\u4e0e\u00a0<code>Encoder</code>\u00a0\u6216\u00a0<code>Decoder</code>\u00a0\u4ea4\u4e92\uff0c\u800c\u662f\u8981\u6c42\u60a8\u4f7f\u7528\u00a0<code>transformSerialize</code>\u00a0and\u00a0<code>transformDeserialize</code>\u00a0\u65b9\u6cd5\u4e3a JsonElement \u7c7b\u8868\u793a\u7684 JSON \u6811\u63d0\u4f9b\u8f6c\u6362\u3002\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e9b\u4f8b\u5b50\u3002</p>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#array-wrapping","title":"Array wrapping\u00a0\u6570\u7ec4\u5305\u88c5","text":"<p>The first example is an implementation of JSON array wrapping for lists. \u7b2c\u4e00\u4e2a\u793a\u4f8b\u662f\u5217\u8868\u7684 JSON \u6570\u7ec4\u5305\u88c5\u7684\u5b9e\u73b0\u3002</p> <p>Consider a REST API that returns a JSON array of\u00a0<code>User</code>\u00a0objects, or a single object (not wrapped into an array) if there is only one element in the result. \u8003\u8651\u8fd4\u56de\u00a0<code>User</code>\u00a0\u5bf9\u8c61\u7684 JSON \u6570\u7ec4\u7684 REST API\uff0c\u5982\u679c\u7ed3\u679c\u4e2d\u53ea\u6709\u4e00\u4e2a\u5143\u7d20\uff0c\u5219\u8fd4\u56de\u5355\u4e2a\u5bf9\u8c61\uff08\u672a\u5305\u88c5\u5230\u6570\u7ec4\u4e2d\uff09\u3002</p> <p>In the data model, use the\u00a0<code>@Serializable</code>\u00a0annotation to specify a custom serializer for a\u00a0<code>users: List&lt;User&gt;</code>\u00a0property. \u5728\u6570\u636e\u6a21\u578b\u4e2d\uff0c\u4f7f\u7528\u00a0<code>@Serializable</code>\u00a0\u6ce8\u89e3\u4e3a\u00a0<code>users: List&lt;User&gt;</code>\u00a0\u5c5e\u6027\u6307\u5b9a\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002</p> <pre><code>@Serializable\ndata class Project(\n    val name: String,\n    @Serializable(with = UserListSerializer::class)\n    val users: List&lt;User&gt;\n)\n\n@Serializable\ndata class User(val name: String)\n</code></pre> <p>Since this example covers only the deserialization case, you can implement\u00a0<code>UserListSerializer</code>\u00a0and override only the\u00a0<code>transformDeserialize</code>\u00a0function. The\u00a0<code>JsonTransformingSerializer</code>\u00a0constructor takes an original serializer as parameter (this approach is shown in the section\u00a0Constructing collection serializers): \u7531\u4e8e\u6b64\u793a\u4f8b\u4ec5\u6db5\u76d6\u53cd\u5e8f\u5217\u5316\u60c5\u51b5\uff0c\u56e0\u6b64\u53ea\u80fd\u5b9e\u73b0\u00a0<code>UserListSerializer</code>\u00a0\u548c\u91cd\u5199\u8be5\u00a0<code>transformDeserialize</code>\u00a0\u51fd\u6570\u3002\u00a0<code>JsonTransformingSerializer</code>\u00a0\u6784\u9020\u51fd\u6570\u91c7\u7528\u539f\u59cb\u5e8f\u5217\u5316\u7a0b\u5e8f\u4f5c\u4e3a\u53c2\u6570\uff08\u6b64\u65b9\u6cd5\u5728\u6784\u9020\u96c6\u5408\u5e8f\u5217\u5316\u7a0b\u5e8f\u4e00\u8282\u4e2d\u663e\u793a\uff09\uff1a</p> <pre><code>object UserListSerializer : JsonTransformingSerializer&lt;List&lt;User&gt;&gt;(ListSerializer(User.serializer())) {\n    // If response is not an array, then it is a single object that should be wrapped into the array\n    override fun transformDeserialize(element: JsonElement): JsonElement =\n        if (element !is JsonArray) JsonArray(listOf(element)) else element\n}\n</code></pre> <p>Now you can test the code with a JSON array or a single JSON object as inputs. \u73b0\u5728\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 JSON \u6570\u7ec4\u6216\u5355\u4e2a JSON \u5bf9\u8c61\u4f5c\u4e3a\u8f93\u5165\u6765\u6d4b\u8bd5\u4ee3\u7801\u3002</p> <pre><code>fun main() {\n    println(Json.decodeFromString&lt;Project&gt;(\"\"\"\n        {\"name\":\"kotlinx.serialization\",\"users\":{\"name\":\"kotlin\"}}\n    \"\"\"))\n    println(Json.decodeFromString&lt;Project&gt;(\"\"\"\n        {\"name\":\"kotlinx.serialization\",\"users\":[{\"name\":\"kotlin\"},{\"name\":\"jetbrains\"}]}\n    \"\"\"))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The output shows that both cases are correctly deserialized into a Kotlin\u00a0List. \u8f93\u51fa\u663e\u793a\uff0c\u8fd9\u4e24\u79cd\u60c5\u51b5\u90fd\u5df2\u6b63\u786e\u53cd\u5e8f\u5217\u5316\u4e3a Kotlin List\u3002</p> <pre><code>Project(name=kotlinx.serialization, users=[User(name=kotlin)])\nProject(name=kotlinx.serialization, users=[User(name=kotlin), User(name=jetbrains)])\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#array-unwrapping","title":"Array unwrapping\u00a0\u6570\u7ec4\u89e3\u5305","text":"<p>You can also implement the\u00a0<code>transformSerialize</code>\u00a0function to unwrap a single-element list into a single JSON object during serialization: \u60a8\u8fd8\u53ef\u4ee5\u5b9e\u73b0\u5728\u5e8f\u5217\u5316\u671f\u95f4\u5c06\u5355\u4e2a\u5143\u7d20\u5217\u8868\u89e3\u5305\u4e3a\u5355\u4e2a JSON \u5bf9\u8c61\u7684\u00a0<code>transformSerialize</code>\u00a0\u51fd\u6570\uff1a</p> <pre><code>    override fun transformSerialize(element: JsonElement): JsonElement {\n        require(element is JsonArray) // this serializer is used only with lists\n        return element.singleOrNull() ?: element\n    }\n</code></pre> <p>Now, if you serialize a single-element list of objects from Kotlin: \u73b0\u5728\uff0c\u5982\u679c\u60a8\u4ece Kotlin \u5e8f\u5217\u5316\u5bf9\u8c61\u7684\u5355\u5143\u7d20\u5217\u8868\uff1a</p> <pre><code>fun main() {\n    val data = Project(\"kotlinx.serialization\", listOf(User(\"kotlin\")))\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>You end up with a single JSON object, not an array with one element: \u4f60\u6700\u7ec8\u4f1a\u5f97\u5230\u4e00\u4e2a JSON \u5bf9\u8c61\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a\u5305\u542b\u4e00\u4e2a\u5143\u7d20\u7684\u6570\u7ec4\uff1a</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"users\":{\"name\":\"kotlin\"}}\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#manipulating-default-values","title":"Manipulating default values  \u64cd\u4f5c\u9ed8\u8ba4\u503c","text":"<p>Another kind of useful transformation is omitting specific values from the output JSON, for example, if it is used as default when missing or for other reasons. \u53e6\u4e00\u79cd\u6709\u7528\u7684\u8f6c\u6362\u662f\u4ece\u8f93\u51fa JSON \u4e2d\u7701\u7565\u7279\u5b9a\u503c\uff0c\u4f8b\u5982\uff0c\u5982\u679c\u7f3a\u5c11\u8be5\u503c\u6216\u51fa\u4e8e\u5176\u4ed6\u539f\u56e0\u5c06\u5176\u7528\u4f5c\u9ed8\u8ba4\u503c\u3002</p> <p>Imagine that you cannot specify a default value for the\u00a0<code>language</code>\u00a0property in the\u00a0<code>Project</code>\u00a0data model for some reason, but you need it omitted from the JSON when it is equal to\u00a0<code>Kotlin</code>\u00a0(we can all agree that Kotlin should be default anyway). You can fix it by writing the special\u00a0<code>ProjectSerializer</code>\u00a0based on the\u00a0Plugin-generated serializer\u00a0for the\u00a0<code>Project</code>\u00a0class. \u60f3\u8c61\u4e00\u4e0b\uff0c\u7531\u4e8e\u67d0\u79cd\u539f\u56e0\uff0c\u60a8\u65e0\u6cd5\u4e3a\u00a0<code>Project</code>\u00a0\u6570\u636e\u6a21\u578b\u4e2d\u7684\u00a0<code>language</code>\u00a0\u5c5e\u6027\u6307\u5b9a\u9ed8\u8ba4\u503c\uff0c\u4f46\u662f\u5f53\u5b83\u7b49\u4e8e\u65f6\u00a0<code>Kotlin</code>\u00a0\uff0c\u60a8\u9700\u8981\u4ece JSON \u4e2d\u7701\u7565\u5b83\uff08\u6211\u4eec\u90fd\u540c\u610f Kotlin \u65e0\u8bba\u5982\u4f55\u90fd\u5e94\u8be5\u662f\u9ed8\u8ba4\u503c\uff09\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u6839\u636e Plugin \u4e3a\u00a0<code>Project</code>\u00a0\u7c7b\u751f\u6210\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u7f16\u5199\u7279\u6b8a\u00a0<code>ProjectSerializer</code>\u00a0\u4ee3\u7801\u6765\u4fee\u590d\u5b83\u3002</p> <pre><code>@Serializable\nclass Project(val name: String, val language: String)\n\nobject ProjectSerializer : JsonTransformingSerializer&lt;Project&gt;(Project.serializer()) {\n    override fun transformSerialize(element: JsonElement): JsonElement =\n        // Filter out top-level key value pair with the key \"language\" and the value \"Kotlin\"\n        JsonObject(element.jsonObject.filterNot {\n            (k, v) -&gt; k == \"language\" &amp;&amp; v.jsonPrimitive.content == \"Kotlin\"\n        })\n}\n</code></pre> <p>In the example below, we are serializing the\u00a0<code>Project</code>\u00a0class at the top-level, so we explicitly pass the above\u00a0<code>ProjectSerializer</code>\u00a0to\u00a0Json.encodeToString\u00a0function as was shown in the\u00a0Passing a serializer manually\u00a0section: \u5728\u4e0b\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u5728\u9876\u5c42\u5e8f\u5217\u5316\u00a0<code>Project</code>\u00a0\u8be5\u7c7b\uff0c\u56e0\u6b64\u6211\u4eec\u5c06\u4e0a\u8ff0\u00a0<code>ProjectSerializer</code>\u00a0\u5185\u5bb9\u663e\u5f0f\u4f20\u9012\u7ed9 Json.encodeToString \u51fd\u6570\uff0c\u5982\u624b\u52a8\u4f20\u9012\u5e8f\u5217\u5316\u7a0b\u5e8f\u90e8\u5206\u6240\u793a\uff1a</p> <pre><code>fun main() {\n    val data = Project(\"kotlinx.serialization\", \"Kotlin\")\n    println(Json.encodeToString(data)) // using plugin-generated serializer\n    println(Json.encodeToString(ProjectSerializer, data)) // using custom serializer\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>See the effect of the custom serializer: \u67e5\u770b\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u7684\u6548\u679c\uff1a</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"language\":\"Kotlin\"}\n{\"name\":\"kotlinx.serialization\"}\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#content-based-polymorphic-deserialization","title":"Content-based polymorphic deserialization  \u57fa\u4e8e\u5185\u5bb9\u7684\u591a\u6001\u53cd\u5e8f\u5217\u5316","text":"<p>Typically,\u00a0polymorphic serialization\u00a0requires a dedicated\u00a0<code>\"type\"</code>\u00a0key (also known as\u00a0class discriminator) in the incoming JSON object to determine the actual serializer which should be used to deserialize Kotlin class. \u901a\u5e38\uff0c\u591a\u6001\u5e8f\u5217\u5316\u9700\u8981\u5728\u4f20\u5165\u7684 JSON \u5bf9\u8c61\u4e2d\u4f7f\u7528\u4e13\u7528\u00a0<code>\"type\"</code>\u00a0\u952e\uff08\u4e5f\u79f0\u4e3a\u7c7b\u9274\u522b\u5668\uff09\u6765\u786e\u5b9a\u5e94\u7528\u4e8e\u53cd\u5e8f\u5217\u5316 Kotlin \u7c7b\u7684\u5b9e\u9645\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002</p> <p>However, sometimes the\u00a0<code>type</code>\u00a0property may not be present in the input. In this case, you need to guess the actual type by the shape of JSON, for example by the presence of a specific key. \u4f46\u662f\uff0c\u6709\u65f6\u8be5\u00a0<code>type</code>\u00a0\u5c5e\u6027\u53ef\u80fd\u4e0d\u5b58\u5728\u4e8e\u8f93\u5165\u4e2d\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u9700\u8981\u901a\u8fc7 JSON \u7684\u5f62\u72b6\u6765\u731c\u6d4b\u5b9e\u9645\u7c7b\u578b\uff0c\u4f8b\u5982\u901a\u8fc7\u7279\u5b9a\u952e\u7684\u5b58\u5728\u6765\u731c\u6d4b\u3002</p> <p>JsonContentPolymorphicSerializer\u00a0provides a skeleton implementation for such a strategy. To use it, override its\u00a0<code>selectDeserializer</code>\u00a0method. Let\u2019s start with the following class hierarchy. JsonContentPolymorphicSerializer \u4e3a\u6b64\u7c7b\u7b56\u7565\u63d0\u4f9b\u4e86\u6846\u67b6\u5b9e\u73b0\u3002\u82e5\u8981\u4f7f\u7528\u5b83\uff0c\u8bf7\u91cd\u5199\u5176\u00a0<code>selectDeserializer</code>\u00a0\u65b9\u6cd5\u3002\u8ba9\u6211\u4eec\u4ece\u4ee5\u4e0b\u7c7b\u5c42\u6b21\u7ed3\u6784\u5f00\u59cb\u3002</p> <p>Note that is does not have to be\u00a0<code>sealed</code>\u00a0as recommended in the\u00a0Sealed classes\u00a0section, because we are not going to take advantage of the plugin-generated code that automatically selects the appropriate subclass, but are going to implement this code manually. \u8bf7\u6ce8\u610f\uff0c\u8fd9\u4e0d\u5fc5\u00a0<code>sealed</code>\u00a0\u6309\u7167 Sealed classes \u90e8\u5206\u7684\u5efa\u8bae\u8fdb\u884c\uff0c\u56e0\u4e3a\u6211\u4eec\u4e0d\u4f1a\u5229\u7528\u63d2\u4ef6\u751f\u6210\u7684\u4ee3\u7801\u6765\u81ea\u52a8\u9009\u62e9\u9002\u5f53\u7684\u5b50\u7c7b\uff0c\u800c\u662f\u5c06\u624b\u52a8\u5b9e\u73b0\u6b64\u4ee3\u7801\u3002</p> <pre><code>@Serializable\nabstract class Project {\n    abstract val name: String\n}\n\n@Serializable\ndata class BasicProject(override val name: String): Project()\n\n\n@Serializable\ndata class OwnedProject(override val name: String, val owner: String) : Project()\n</code></pre> <p>You can distinguish the\u00a0<code>BasicProject</code>\u00a0and\u00a0<code>OwnedProject</code>\u00a0subclasses by the presence of the\u00a0<code>owner</code>\u00a0key in the JSON object. \u60a8\u53ef\u4ee5\u901a\u8fc7 JSON \u5bf9\u8c61\u4e2d\u00a0<code>owner</code>\u00a0\u662f\u5426\u5b58\u5728\u952e\u6765\u533a\u5206\u00a0<code>BasicProject</code>\u00a0\u548c\u00a0<code>OwnedProject</code>\u00a0\u5b50\u7c7b\u3002</p> <pre><code>object ProjectSerializer : JsonContentPolymorphicSerializer&lt;Project&gt;(Project::class) {\n    override fun selectDeserializer(element: JsonElement) = when {\n        \"owner\" in element.jsonObject -&gt; OwnedProject.serializer()\n        else -&gt; BasicProject.serializer()\n    }\n}\n</code></pre> <p>When you use this serializer to serialize data, either\u00a0registered\u00a0or the default serializer is selected for the actual type at runtime: \u4f7f\u7528\u6b64\u5e8f\u5217\u5316\u7a0b\u5e8f\u5e8f\u5217\u5316\u6570\u636e\u65f6\uff0c\u5c06\u5728\u8fd0\u884c\u65f6\u4e3a\u5b9e\u9645\u7c7b\u578b\u9009\u62e9\u5df2\u6ce8\u518c\u6216\u9ed8\u8ba4\u5e8f\u5217\u5316\u7a0b\u5e8f\uff1a</p> <pre><code>fun main() {\n    val data = listOf(\n        OwnedProject(\"kotlinx.serialization\", \"kotlin\"),\n        BasicProject(\"example\")\n    )\n    val string = Json.encodeToString(ListSerializer(ProjectSerializer), data)\n    println(string)\n    println(Json.decodeFromString(ListSerializer(ProjectSerializer), string))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>No class discriminator is added in the JSON output: JSON \u8f93\u51fa\u4e2d\u672a\u6dfb\u52a0\u7c7b\u9274\u522b\u5668\uff1a</p> <pre><code>[{\"name\":\"kotlinx.serialization\",\"owner\":\"kotlin\"},{\"name\":\"example\"}]\n[OwnedProject(name=kotlinx.serialization, owner=kotlin), BasicProject(name=example)]\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#under-the-hood-experimental","title":"Under the hood (experimental)  \uff08\u5b9e\u9a8c\u6027\uff09","text":"<p>Although abstract serializers mentioned above can cover most of the cases, it is possible to implement similar machinery manually, using only the\u00a0KSerializer\u00a0class. If tweaking the abstract methods\u00a0<code>transformSerialize</code>/<code>transformDeserialize</code>/<code>selectDeserializer</code>\u00a0is not enough, then altering\u00a0<code>serialize</code>/<code>deserialize</code>\u00a0is a way to go. \u5c3d\u7ba1\u4e0a\u9762\u63d0\u5230\u7684\u62bd\u8c61\u5e8f\u5217\u5316\u7a0b\u5e8f\u53ef\u4ee5\u6db5\u76d6\u5927\u591a\u6570\u60c5\u51b5\uff0c\u4f46\u53ef\u4ee5\u4ec5\u4f7f\u7528 KSerializer \u7c7b\u624b\u52a8\u5b9e\u73b0\u7c7b\u4f3c\u7684\u673a\u5236\u3002\u5982\u679c\u8c03\u6574\u62bd\u8c61\u65b9\u6cd5\u00a0<code>transformSerialize</code>\u00a0/\u00a0<code>transformDeserialize</code>\u00a0/\u00a0<code>selectDeserializer</code>\u00a0\u8fd8\u4e0d\u591f\uff0c\u90a3\u4e48\u6539\u53d8\u00a0<code>serialize</code>\u00a0/\u00a0<code>deserialize</code>\u00a0\u662f\u4e00\u6761\u8def\u3002</p> <p>Here are some useful things about custom serializers with\u00a0Json: \u4ee5\u4e0b\u662f\u6709\u5173\u4f7f\u7528 Json \u7684\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u7684\u4e00\u4e9b\u6709\u7528\u4fe1\u606f\uff1a</p> <ul> <li>Encoder\u00a0can be cast to\u00a0JsonEncoder, and\u00a0Decoder\u00a0to\u00a0JsonDecoder, if the current format is\u00a0Json.     \u5982\u679c\u5f53\u524d\u683c\u5f0f\u4e3a Json\uff0c\u5219\u53ef\u4ee5\u5c06 Encoder \u8f6c\u6362\u4e3a JsonEncoder\uff0c\u5c06 Decoder \u8f6c\u6362\u4e3a JsonDecoder\u3002</li> <li><code>JsonDecoder</code>\u00a0has the\u00a0decodeJsonElement\u00a0method and\u00a0<code>JsonEncoder</code>\u00a0has the\u00a0encodeJsonElement\u00a0method, which basically retrieve an element from and insert an element to a current position in the stream. <code>JsonDecoder</code>\u00a0\u5177\u6709 decodeJsonElement \u65b9\u6cd5\u548c\u00a0<code>JsonEncoder</code>\u00a0encodeJsonElement \u65b9\u6cd5\uff0c\u8be5\u65b9\u6cd5\u57fa\u672c\u4e0a\u4ece\u6d41\u4e2d\u68c0\u7d22\u5143\u7d20\u5e76\u5c06\u5143\u7d20\u63d2\u5165\u5230\u6d41\u4e2d\u7684\u5f53\u524d\u4f4d\u7f6e\u3002</li> <li>Both\u00a0<code>JsonDecoder</code>\u00a0and\u00a0<code>JsonEncoder</code>\u00a0have the\u00a0<code>json</code>\u00a0property, which returns\u00a0Json\u00a0instance with all settings that are currently in use.     \u4e24\u8005\u90fd\u00a0<code>JsonDecoder</code> <code>JsonEncoder</code>\u00a0\u5177\u6709\u5c5e\u6027\u00a0<code>json</code>\u00a0\uff0c\u8be5\u5c5e\u6027\u8fd4\u56de\u5305\u542b\u5f53\u524d\u6b63\u5728\u4f7f\u7528\u7684\u6240\u6709\u8bbe\u7f6e\u7684 Json \u5b9e\u4f8b\u3002</li> <li>Json\u00a0has the\u00a0encodeToJsonElement\u00a0and\u00a0decodeFromJsonElement\u00a0methods.     Json \u5177\u6709 encodeToJsonElement \u548c decodeFromJsonElement \u65b9\u6cd5\u3002</li> </ul> <p>Given all that, it is possible to implement two-stage conversion\u00a0<code>Decoder -&gt; JsonElement -&gt; value</code>\u00a0or\u00a0<code>value -&gt; JsonElement -&gt; Encoder</code>. For example, you can implement a fully custom serializer for the following\u00a0<code>Response</code>\u00a0class so that its\u00a0<code>Ok</code>\u00a0subclass is represented directly, but the\u00a0<code>Error</code>\u00a0subclass is represented by an object with the error message: \u9274\u4e8e\u6240\u6709\u8fd9\u4e9b\uff0c\u53ef\u4ee5\u5b9e\u73b0\u4e24\u7ea7\u8f6c\u6362\u00a0<code>Decoder -&gt; JsonElement -&gt; value</code>\u00a0\u6216\u00a0<code>value -&gt; JsonElement -&gt; Encoder</code>\u00a0.\u4f8b\u5982\uff0c\u60a8\u53ef\u4ee5\u4e3a\u4ee5\u4e0b\u00a0<code>Response</code>\u00a0\u7c7b\u5b9e\u73b0\u5b8c\u5168\u81ea\u5b9a\u4e49\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u4ee5\u4fbf\u76f4\u63a5\u8868\u793a\u5176\u00a0<code>Ok</code>\u00a0\u5b50\u7c7b\uff0c\u4f46\u8be5\u00a0<code>Error</code>\u00a0\u5b50\u7c7b\u7531\u5e26\u6709\u9519\u8bef\u6d88\u606f\u7684\u5bf9\u8c61\u8868\u793a\uff1a</p> <pre><code>@Serializable(with = ResponseSerializer::class)\nsealed class Response&lt;out T&gt; {\n    data class Ok&lt;out T&gt;(val data: T) : Response&lt;T&gt;()\n    data class Error(val message: String) : Response&lt;Nothing&gt;()\n}\n\nclass ResponseSerializer&lt;T&gt;(private val dataSerializer: KSerializer&lt;T&gt;) : KSerializer&lt;Response&lt;T&gt;&gt; {\n    override val descriptor: SerialDescriptor = buildSerialDescriptor(\"Response\", PolymorphicKind.SEALED) {\n        element(\"Ok\", dataSerializer.descriptor)\n        element(\"Error\", buildClassSerialDescriptor(\"Error\") {\n          element&lt;String&gt;(\"message\")\n        })\n    }\n\n    override fun deserialize(decoder: Decoder): Response&lt;T&gt; {\n        // Decoder -&gt; JsonDecoder\n        require(decoder is JsonDecoder) // this class can be decoded only by Json\n        // JsonDecoder -&gt; JsonElement\n        val element = decoder.decodeJsonElement()\n        // JsonElement -&gt; value\n        if (element is JsonObject &amp;&amp; \"error\" in element)\n            return Response.Error(element[\"error\"]!!.jsonPrimitive.content)\n        return Response.Ok(decoder.json.decodeFromJsonElement(dataSerializer, element))\n    }\n\n    override fun serialize(encoder: Encoder, value: Response&lt;T&gt;) {\n        // Encoder -&gt; JsonEncoder\n        require(encoder is JsonEncoder) // This class can be encoded only by Json\n        // value -&gt; JsonElement\n        val element = when (value) {\n            is Response.Ok -&gt; encoder.json.encodeToJsonElement(dataSerializer, value.data)\n            is Response.Error -&gt; buildJsonObject { put(\"error\", value.message) }\n        }\n        // JsonElement -&gt; JsonEncoder\n        encoder.encodeJsonElement(element)\n    }\n}\n</code></pre> <p>Having this serializable\u00a0<code>Response</code>\u00a0implementation, you can take any serializable payload for its data and serialize or deserialize the corresponding responses: \u6709\u4e86\u8fd9\u4e2a\u53ef\u00a0<code>Response</code>\u00a0\u5e8f\u5217\u5316\u7684\u5b9e\u73b0\uff0c\u4f60\u53ef\u4ee5\u4e3a\u5176\u6570\u636e\u83b7\u53d6\u4efb\u4f55\u53ef\u5e8f\u5217\u5316\u7684\u6709\u6548\u8d1f\u8f7d\uff0c\u5e76\u5e8f\u5217\u5316\u6216\u53cd\u5e8f\u5217\u5316\u76f8\u5e94\u7684\u54cd\u5e94\uff1a</p> <pre><code>@Serializable\ndata class Project(val name: String)\n\nfun main() {\n    val responses = listOf(\n        Response.Ok(Project(\"kotlinx.serialization\")),\n        Response.Error(\"Not found\")\n    )\n    val string = Json.encodeToString(responses)\n    println(string)\n    println(Json.decodeFromString&lt;List&lt;Response&lt;Project&gt;&gt;&gt;(string))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>This gives you fine-grained control on the representation of the\u00a0<code>Response</code>\u00a0class in the JSON output: \u8fd9\u4f7f\u60a8\u53ef\u4ee5\u5bf9 JSON \u8f93\u51fa\u4e2d\u00a0<code>Response</code>\u00a0\u7c7b\u7684\u8868\u793a\u5f62\u5f0f\u8fdb\u884c\u7ec6\u7c92\u5ea6\u63a7\u5236\uff1a</p> <pre><code>[{\"name\":\"kotlinx.serialization\"},{\"error\":\"Not found\"}]\n[Ok(data=Project(name=kotlinx.serialization)), Error(message=Not found)]\n</code></pre>"},{"location":"JSON%E7%89%B9%E6%80%A7-5/#maintaining-custom-json-attributes-json","title":"Maintaining custom JSON attributes  \u7ef4\u62a4\u81ea\u5b9a\u4e49 JSON \u5c5e\u6027","text":"<p>A good example of custom JSON-specific serializer would be a deserializer that packs all unknown JSON properties into a dedicated field of\u00a0<code>JsonObject</code>\u00a0type. \u7279\u5b9a\u4e8e JSON \u7684\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u7684\u4e00\u4e2a\u5f88\u597d\u7684\u793a\u4f8b\u662f\u53cd\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u5b83\u5c06\u6240\u6709\u672a\u77e5\u7684 JSON \u5c5e\u6027\u6253\u5305\u5230\u4e00\u4e2a\u4e13\u7528\u7684\u00a0<code>JsonObject</code>\u00a0\u7c7b\u578b\u5b57\u6bb5\u4e2d\u3002</p> <p>Let\u2019s add\u00a0<code>UnknownProject</code>\u00a0\u2013 a class with the\u00a0<code>name</code>\u00a0property and arbitrary details flattened into the same object: \u8ba9\u6211\u4eec\u6dfb\u52a0\u00a0<code>UnknownProject</code>\u00a0\u4e00\u4e2a\u7c7b\uff0c\u00a0<code>name</code>\u00a0\u5176\u4e2d\u5c5e\u6027\u548c\u4efb\u610f\u7ec6\u8282\u88ab\u5e73\u5c55\u5230\u540c\u4e00\u4e2a\u5bf9\u8c61\u4e2d\uff1a</p> <pre><code>data class UnknownProject(val name: String, val details: JsonObject)\n</code></pre> <p>However, the default plugin-generated serializer requires details to be a separate JSON object and that\u2019s not what we want. \u4f46\u662f\uff0c\u9ed8\u8ba4\u63d2\u4ef6\u751f\u6210\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u8981\u6c42\u8be6\u7ec6\u4fe1\u606f\u662f\u5355\u72ec\u7684 JSON \u5bf9\u8c61\uff0c\u8fd9\u4e0d\u662f\u6211\u4eec\u60f3\u8981\u7684\u3002</p> <p>To mitigate that, write an own serializer that uses the fact that it works only with the\u00a0<code>Json</code>\u00a0format: \u4e3a\u4e86\u7f13\u89e3\u8fd9\u79cd\u60c5\u51b5\uff0c\u8bf7\u7f16\u5199\u4e00\u4e2a\u81ea\u5df1\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u8be5\u5e8f\u5217\u5316\u7a0b\u5e8f\u4f7f\u7528\u5b83\u4ec5\u9002\u7528\u4e8e\u4ee5\u4e0b\u00a0<code>Json</code>\u00a0\u683c\u5f0f\u7684\u4e8b\u5b9e\uff1a</p> <pre><code>object UnknownProjectSerializer : KSerializer&lt;UnknownProject&gt; {\n    override val descriptor: SerialDescriptor = buildClassSerialDescriptor(\"UnknownProject\") {\n        element&lt;String&gt;(\"name\")\n        element&lt;JsonElement&gt;(\"details\")\n    }\n\n    override fun deserialize(decoder: Decoder): UnknownProject {\n        // Cast to JSON-specific interface\n        val jsonInput = decoder as? JsonDecoder ?: error(\"Can be deserialized only by JSON\")\n        // Read the whole content as JSON\n        val json = jsonInput.decodeJsonElement().jsonObject\n        // Extract and remove name property\n        val name = json.getValue(\"name\").jsonPrimitive.content\n        val details = json.toMutableMap()\n        details.remove(\"name\")\n        return UnknownProject(name, JsonObject(details))\n    }\n\n    override fun serialize(encoder: Encoder, value: UnknownProject) {\n        error(\"Serialization is not supported\")\n    }\n}\n</code></pre> <p>Now it can be used to read flattened JSON details as\u00a0<code>UnknownProject</code>: \u73b0\u5728\uff0c\u5b83\u53ef\u4ee5\u7528\u6765\u8bfb\u53d6\u6241\u5e73\u5316\u7684JSON\u8be6\u7ec6\u4fe1\u606f\u00a0<code>UnknownProject</code>\u00a0\uff1a</p> <pre><code>fun main() {\n    println(Json.decodeFromString(UnknownProjectSerializer, \"\"\"{\"type\":\"unknown\",\"name\":\"example\",\"maintainer\":\"Unknown\",\"license\":\"Apache 2.0\"}\"\"\"))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>UnknownProject(name=example, details={\"type\":\"unknown\",\"maintainer\":\"Unknown\",\"license\":\"Apache 2.0\"})\n</code></pre> <p>The next chapter covers\u00a0Alternative and custom formats (experimental). \u4e0b\u4e00\u7ae0\u5c06\u4ecb\u7ecd\u66ff\u4ee3\u683c\u5f0f\u548c\u81ea\u5b9a\u4e49\u683c\u5f0f\uff08\u5b9e\u9a8c\u6027\uff09\u3002</p>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/","title":"Builtin classes\u00a0\u5185\u7f6e\u7c7b","text":"<p>This is the second chapter of the\u00a0Kotlin Serialization Guide. In addition to all the primitive types and strings, serialization for some classes from the Kotlin standard library, including the standard collections, is built into Kotlin Serialization. This chapter explains the details. \u8fd9\u662f\u300aKotlin \u5e8f\u5217\u5316\u6307\u5357\u300b\u7684\u7b2c\u4e8c\u7ae0\u3002\u9664\u4e86\u6240\u6709\u57fa\u5143\u7c7b\u578b\u548c\u5b57\u7b26\u4e32\u4e4b\u5916\uff0cKotlin \u6807\u51c6\u5e93\u4e2d\u67d0\u4e9b\u7c7b\uff08\u5305\u62ec\u6807\u51c6\u96c6\u5408\uff09\u7684\u5e8f\u5217\u5316\u4e5f\u5185\u7f6e\u4e8e Kotlin \u5e8f\u5217\u5316\u4e2d\u3002\u672c\u7ae0\u5c06\u4ecb\u7ecd\u8be6\u7ec6\u4fe1\u606f\u3002</p> <p>Table of contents\u00a0\u76ee\u5f55</p> <ul> <li>Primitives\u00a0\u539f<ul> <li>Numbers\u00a0\u6570\u5b57</li> <li>Long numbers\u00a0\u957f\u6570\u5b57</li> <li>Long numbers as strings     \u957f\u6570\u5b57\u4f5c\u4e3a\u5b57\u7b26\u4e32</li> <li>Enum classes\u00a0\u683c\u6d1b\u65af</li> <li>Serial names of enum entries     \u679a\u4e3e\u6761\u76ee\u7684\u5e8f\u5217\u5316\u540d\u79f0</li> </ul> </li> <li>Composites\u00a0\u590d\u5408\u6750\u6599<ul> <li>Pair and triple\u00a0\u6210\u5bf9\u548c\u4e09\u4eba</li> <li>Lists\u00a0\u5217\u8868</li> <li>Sets and other collections     \u5957\u88c5\u548c\u5176\u4ed6\u96c6\u5408</li> <li>Deserializing collections     \u53cd\u5e8f\u5217\u5316\u96c6\u5408</li> <li>Maps\u00a0\u5730\u56fe</li> <li>Unit and singleton objects     \u5355\u4f4d\u548c\u5355\u4e00\u5b9e\u4f8b\u5bf9\u8c61</li> <li>Duration\u00a0\u671f\u95f4</li> </ul> </li> <li>Nothing\u00a0\u65e0</li> </ul>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#primitives","title":"Primitives\u00a0\u57fa\u5143\uff08\u57fa\u672c\u6570\u636e\u7c7b\u578b\uff09","text":"<p>Kotlin Serialization has the following ten primitives:\u00a0<code>Boolean</code>,\u00a0<code>Byte</code>,\u00a0<code>Short</code>,\u00a0<code>Int</code>,\u00a0<code>Long</code>,\u00a0<code>Float</code>,\u00a0<code>Double</code>,\u00a0<code>Char</code>,\u00a0<code>String</code>, and enums. The other types in Kotlin Serialization are\u00a0composite\u2014composed of those primitive values. Kotlin \u5e8f\u5217\u5316\u5305\u542b\u4ee5\u4e0b\u5341\u4e2a\u57fa\u5143\uff1a\u00a0<code>Boolean</code>\u00a0\u3001\u3001\u00a0<code>Byte</code>\u00a0\u3001\u00a0<code>Short</code> <code>Int</code> <code>Long</code> <code>Float</code> <code>Double</code> <code>Char</code> <code>String</code>\u00a0Kotlin \u5e8f\u5217\u5316\u4e2d\u7684\u5176\u4ed6\u7c7b\u578b\u662f\u590d\u5408\u7684\uff0c\u7531\u8fd9\u4e9b\u57fa\u5143\u503c\u7ec4\u6210\u3002</p>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#numbers","title":"Numbers\u00a0\u6570\u5b57","text":"<p>All types of integer and floating-point Kotlin numbers can be serialized. \u6240\u6709\u7c7b\u578b\u7684\u6574\u6570\u548c\u6d6e\u70b9 Kotlin \u6570\u5b57\u90fd\u53ef\u4ee5\u5e8f\u5217\u5316\u3002</p> <pre><code>@Serializable\nclass Data(\n    val answer: Int,\n    val pi: Double\n)                     \n\nfun main() {\n    val data = Data(42, PI)\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Their natural representation in JSON is used. \u4f7f\u7528\u5b83\u4eec\u5728 JSON \u4e2d\u7684\u81ea\u7136\u8868\u793a\u5f62\u5f0f\u3002</p> <pre><code>{\"answer\":42,\"pi\":3.141592653589793}\n</code></pre>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#long-numbers","title":"Long numbers\u00a0\u957f\u6570\u5b57","text":"<p>Long integers are serializable, too. \u957f\u6574\u6570\u4e5f\u662f\u53ef\u5e8f\u5217\u5316\u7684\u3002</p> <pre><code>@Serializable\nclass Data(val signature: Long)\n\nfun main() {\n    val data = Data(0x1CAFE2FEED0BABE0)\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>By default they are serialized to JSON as numbers. \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5b83\u4eec\u4f5c\u4e3a\u6570\u5b57\u5e8f\u5217\u5316\u4e3a JSON\u3002</p> <pre><code>{\"signature\":2067120338512882656}\n</code></pre>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#long-numbers-as-strings","title":"Long numbers as strings\u00a0\u957f\u6570\u5b57\u4f5c\u4e3a\u5b57\u7b26\u4e32","text":"<p>The JSON output from the previous example will get decoded normally by Kotlin Serialization running on Kotlin/JS. However, if we try to parse this JSON by native JavaScript methods, we get this truncated result. \u4e0a\u4e00\u4e2a\u793a\u4f8b\u7684 JSON \u8f93\u51fa\u5c06\u7531\u5728 Kotlin/JS \u4e0a\u8fd0\u884c\u7684 Kotlin \u5e8f\u5217\u5316\u6b63\u5e38\u89e3\u7801\u3002\u4f46\u662f\uff0c\u5982\u679c\u6211\u4eec\u5c1d\u8bd5\u901a\u8fc7\u539f\u751f JavaScript \u65b9\u6cd5\u89e3\u6790\u6b64 JSON\uff0c\u6211\u4eec\u4f1a\u5f97\u5230\u8fd9\u4e2a\u622a\u65ad\u7684\u7ed3\u679c\u3002</p> <pre><code>JSON.parse(\"{\\\"signature\\\":2067120338512882656}\")\n\u25b6 {signature: 2067120338512882700} \n</code></pre> <p>The full range of a Kotlin Long does not fit in the JavaScript number, so its precision gets lost in JavaScript. A common workaround is to represent long numbers with full precision using the JSON string type. This approach is optionally supported by Kotlin Serialization with\u00a0LongAsStringSerializer, which can be specified for a given Long property using the\u00a0<code>@Serializable</code>\u00a0annotation:  </p> <p>Kotlin Long \u7684\u5b8c\u6574\u8303\u56f4\u4e0d\u9002\u5408 JavaScript \u7f16\u53f7\uff0c\u56e0\u6b64\u5176\u7cbe\u5ea6\u5728 JavaScript \u4e2d\u4e22\u5931\u3002\u4e00\u79cd\u5e38\u89c1\u7684\u89e3\u51b3\u65b9\u6cd5\u662f\u4f7f\u7528 JSON \u5b57\u7b26\u4e32\u7c7b\u578b\u4ee5\u5b8c\u5168\u7cbe\u5ea6\u8868\u793a\u957f\u6570\u5b57\u3002\u6b64\u65b9\u6cd5\u53ef\u7531 Kotlin Serialization with LongAsStringSerializer \u9009\u62e9\u6027\u5730\u652f\u6301\uff0c\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u00a0<code>@Serializable</code>\u00a0\u6ce8\u91ca\u4e3a\u7ed9\u5b9a\u7684 Long \u5c5e\u6027\u6307\u5b9a\u6b64\u65b9\u6cd5\uff1a</p> <pre><code>@Serializable\nclass Data(\n    @Serializable(with=LongAsStringSerializer::class)\n    val signature: Long\n)\n\nfun main() {\n    val data = Data(0x1CAFE2FEED0BABE0)\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>This JSON gets parsed natively by JavaScript without loss of precision. \u6b64 JSON \u7531 JavaScript \u672c\u673a\u89e3\u6790\uff0c\u800c\u4e0d\u4f1a\u635f\u5931\u7cbe\u5ea6\u3002</p> <pre><code>{\"signature\":\"2067120338512882656\"}\n</code></pre> <p>The section on\u00a0Specifying serializers for a file\u00a0explains how a serializer like\u00a0<code>LongAsStringSerializer</code>\u00a0can be specified for all properties in a file. \u4e3a\u6587\u4ef6\u6307\u5b9a\u5e8f\u5217\u5316\u7a0b\u5e8f\u4e00\u8282\u4ecb\u7ecd\u4e86\u5982\u4f55\u4e3a\u6587\u4ef6\u4e2d\u7684\u6240\u6709\u5c5e\u6027\u6307\u5b9a\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002\u00a0<code>LongAsStringSerializer</code></p>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#enum-classes","title":"Enum classes\u00a0\u679a\u4e3e\u7c7b","text":"<p>All enum classes are serializable out of the box without having to mark them\u00a0<code>@Serializable</code>, as the following example shows. \u6240\u6709\u679a\u4e3e\u7c7b\u90fd\u662f\u5f00\u7bb1\u5373\u7528\u7684\u53ef\u5e8f\u5217\u5316\uff0c\u65e0\u9700\u6807\u8bb0\u5b83\u4eec\u00a0<code>@Serializable</code>\u00a0\uff0c\u5982\u4ee5\u4e0b\u793a\u4f8b\u6240\u793a\u3002</p> <pre><code>// The @Serializable annotation is not needed for enum classes\nenum class Status { SUPPORTED }\n\n@Serializable\nclass Project(val name: String, val status: Status) \n\nfun main() {\n    val data = Project(\"kotlinx.serialization\", Status.SUPPORTED)\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>In JSON an enum gets encoded as a string. \u5728 JSON \u4e2d\uff0c\u679a\u4e3e\u88ab\u7f16\u7801\u4e3a\u5b57\u7b26\u4e32\u3002</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"status\":\"SUPPORTED\"}\n</code></pre> <p>Note: On Kotlin/JS and Kotlin/Native,\u00a0<code>@Serializable</code>\u00a0annotation is needed for enum class if you want to use it as a root object \u2014 i.e. use\u00a0<code>encodeToString&lt;Status&gt;(Status.SUPPORTED)</code>. \u6ce8\u610f\uff1a\u5728 Kotlin/JS \u548c Kotlin/Native \u4e0a\uff0c\u00a0<code>@Serializable</code>\u00a0\u5982\u679c\u60a8\u60f3\u5c06\u679a\u4e3e\u7c7b\u7528\u4f5c\u6839\u5bf9\u8c61\uff0c\u5219\u9700\u8981\u5bf9\u679a\u4e3e\u7c7b\u8fdb\u884c\u6ce8\u91ca\u2014\u2014\u5373\u4f7f\u7528\u00a0<code>encodeToString&lt;Status&gt;(Status.SUPPORTED)</code>\u00a0.</p>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#serial-names-of-enum-entries","title":"Serial names of enum entries  \u679a\u4e3e\u7c7b\u7684\u5e8f\u5217\u5316\u540d","text":"<p>Serial names of enum entries can be customized with the\u00a0SerialName\u00a0annotation just like it was shown for properties in the\u00a0Serial field names\u00a0section. However, in this case, the whole enum class must be marked with the\u00a0<code>@Serializable</code>\u00a0annotation. \u53ef\u4ee5\u4f7f\u7528 SerialName \u6ce8\u89e3\u81ea\u5b9a\u4e49\u679a\u4e3e\u6761\u76ee\u7684\u5e8f\u5217\u5316\u540d\u79f0\uff0c\u5c31\u50cf\u5728\u201c\u4e32\u884c\u5b57\u6bb5\u540d\u79f0\u201d\u90e8\u5206\u4e2d\u4e3a\u5c5e\u6027\u663e\u793a\u7684\u90a3\u6837\u3002\u4f46\u662f\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5fc5\u987b\u7528\u00a0<code>@Serializable</code>\u00a0\u6ce8\u91ca\u6807\u8bb0\u6574\u4e2a\u679a\u4e3e\u7c7b\u3002</p> <pre><code>@Serializable // required because of @SerialName\nenum class Status { @SerialName(\"maintained\") SUPPORTED }\n\n@Serializable\nclass Project(val name: String, val status: Status) \n\nfun main() {\n    val data = Project(\"kotlinx.serialization\", Status.SUPPORTED)\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>We see that the specified serial name is now used in the resulting JSON. \u6211\u4eec\u770b\u5230\uff0c\u5728\u751f\u6210\u7684 JSON \u4e2d\u73b0\u5728\u4f7f\u7528\u4e86\u6307\u5b9a\u7684\u5e8f\u5217\u5316\u540d\u79f0\u3002</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"status\":\"maintained\"}\n</code></pre>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#composites","title":"Composites\u00a0\u590d\u5408\u7c7b\u578b","text":"<p>A number of composite types from the standard library are supported by Kotlin Serialization. Kotlin \u5e8f\u5217\u5316\u652f\u6301\u6807\u51c6\u5e93\u4e2d\u7684\u8bb8\u591a\u590d\u5408\u7c7b\u578b\u3002</p>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#pair-and-triple","title":"Pair and triple","text":"<p>The simple data classes\u00a0Pair\u00a0and\u00a0Triple\u00a0from the Kotlin standard library are serializable. Kotlin \u6807\u51c6\u5e93\u4e2d\u7684\u7b80\u5355\u6570\u636e\u7c7b Pair \u548c Triple \u662f\u53ef\u5e8f\u5217\u5316\u7684\u3002</p> <pre><code>@Serializable\nclass Project(val name: String)\n\nfun main() {\n    val pair = 1 to Project(\"kotlinx.serialization\")\n    println(Json.encodeToString(pair))\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>{\"first\":1,\"second\":{\"name\":\"kotlinx.serialization\"}}\n</code></pre> <p>Not all classes from the Kotlin standard library are serializable. In particular, ranges and the\u00a0Regex\u00a0class are not serializable at the moment. Support for their serialization may be added in the future. \u5e76\u975e Kotlin \u6807\u51c6\u5e93\u4e2d\u7684\u6240\u6709\u7c7b\u90fd\u662f\u53ef\u5e8f\u5217\u5316\u7684\u3002\u7279\u522b\u662f\uff0c\u8303\u56f4\u548c\u6b63\u5219\u8868\u8fbe\u5f0f\u7c7b\u76ee\u524d\u4e0d\u53ef\u5e8f\u5217\u5316\u3002\u5c06\u6765\u53ef\u80fd\u4f1a\u6dfb\u52a0\u5bf9\u5176\u5e8f\u5217\u5316\u7684\u652f\u6301\u3002</p>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#lists","title":"Lists","text":"<p>A\u00a0List\u00a0of serializable classes can be serialized. \u53ef\u4ee5\u5e8f\u5217\u5316\u53ef\u5e8f\u5217\u5316\u7c7b\u7684\u5217\u8868\u3002</p> <pre><code>@Serializable\nclass Project(val name: String)\n\nfun main() {\n    val list = listOf(\n        Project(\"kotlinx.serialization\"),\n        Project(\"kotlinx.coroutines\")    \n    )\n    println(Json.encodeToString(list))\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The result is represented as a list in JSON. \u7ed3\u679c\u4ee5 JSON \u5f62\u5f0f\u8868\u793a\u4e3a\u5217\u8868\u3002</p> <pre><code>[{\"name\":\"kotlinx.serialization\"},{\"name\":\"kotlinx.coroutines\"}]\n</code></pre>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#sets-and-other-collections","title":"Sets and other collections","text":"<p>Other collections, like\u00a0Set, are also serializable. \u5176\u4ed6\u96c6\u5408\uff08\u5982 Set\uff09\u4e5f\u662f\u53ef\u5e8f\u5217\u5316\u7684\u3002</p> <pre><code>@Serializable\nclass Project(val name: String)\n\nfun main() {\n    val set = setOf(\n        Project(\"kotlinx.serialization\"),\n        Project(\"kotlinx.coroutines\")    \n    )\n    println(Json.encodeToString(set))\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Set\u00a0is also represented as a list in JSON, like all other collections. \u4e0e\u6240\u6709\u5176\u4ed6\u96c6\u5408\u4e00\u6837\uff0cSet \u4e5f\u4ee5 JSON \u8868\u793a\u4e3a\u5217\u8868\u3002</p> <pre><code>[{\"name\":\"kotlinx.serialization\"},{\"name\":\"kotlinx.coroutines\"}]\n</code></pre>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#deserializing-collections","title":"Deserializing collections  \u53cd\u5e8f\u5217\u5316\u96c6\u5408","text":"<p>During deserialization, the type of the resulting object is determined by the static type that was specified in the source code\u2014either as the type of the property or as the type parameter of the decoding function. The following example shows how the same JSON list of integers is deserialized into two properties of different Kotlin types. \u5728\u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\uff0c\u751f\u6210\u5bf9\u8c61\u7684\u7c7b\u578b\u7531\u6e90\u4ee3\u7801\u4e2d\u6307\u5b9a\u7684\u9759\u6001\u7c7b\u578b\u786e\u5b9a\uff0c\u8be5\u7c7b\u578b\u53ef\u4ee5\u662f\u5c5e\u6027\u7684\u7c7b\u578b\uff0c\u4e5f\u53ef\u4ee5\u662f\u89e3\u7801\u51fd\u6570\u7684\u7c7b\u578b\u53c2\u6570\u3002\u4ee5\u4e0b\u793a\u4f8b\u663e\u793a\u4e86\u5982\u4f55\u5c06\u76f8\u540c\u7684\u6574\u6570 JSON \u5217\u8868\u53cd\u5e8f\u5217\u5316\u4e3a\u4e0d\u540c Kotlin \u7c7b\u578b\u7684\u4e24\u4e2a\u5c5e\u6027\u3002</p> <pre><code>@Serializable\ndata class Data(\n    val a: List&lt;Int&gt;,\n    val b: Set&lt;Int&gt;\n)\n\nfun main() {\n    val data = Json.decodeFromString&lt;Data&gt;(\"\"\"\n        {\n            \"a\": [42, 42],\n            \"b\": [42, 42]\n        }\n    \"\"\")\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Because the\u00a0<code>data.b</code>\u00a0property is a\u00a0Set, the duplicate values from it disappeared. \u7531\u4e8e\u8be5\u00a0<code>data.b</code>\u00a0\u5c5e\u6027\u662f Set\uff0c\u56e0\u6b64\u8be5\u5c5e\u6027\u4e2d\u7684\u91cd\u590d\u503c\u5c06\u6d88\u5931\u3002</p> <pre><code>Data(a=[42, 42], b=[42])\n</code></pre>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#maps","title":"Maps","text":"<p>A\u00a0Map\u00a0with primitive or enum keys and arbitrary serializable values can be serialized. \u53ef\u4ee5\u5e8f\u5217\u5316\u5177\u6709\u57fa\u5143\u6216\u679a\u4e3e\u952e\u4ee5\u53ca\u4efb\u610f\u53ef\u5e8f\u5217\u5316\u503c\u7684\u6620\u5c04\u3002</p> <pre><code>@Serializable\nclass Project(val name: String)\n\nfun main() {\n    val map = mapOf(\n        1 to Project(\"kotlinx.serialization\"),\n        2 to Project(\"kotlinx.coroutines\")    \n    )\n    println(Json.encodeToString(map))\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Kotlin maps in JSON are represented as objects. In JSON object keys are always strings, so keys are encoded as strings even if they are numbers in Kotlin, as we can see below. JSON \u4e2d\u7684 Kotlin \u5730\u56fe\u8868\u793a\u4e3a\u5bf9\u8c61\u3002\u5728 JSON \u5bf9\u8c61\u4e2d\uff0c\u952e\u59cb\u7ec8\u662f\u5b57\u7b26\u4e32\uff0c\u56e0\u6b64\u952e\u88ab\u7f16\u7801\u4e3a\u5b57\u7b26\u4e32\uff0c\u5373\u4f7f\u5b83\u4eec\u5728 Kotlin \u4e2d\u662f\u6570\u5b57\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002</p> <pre><code>{\"1\":{\"name\":\"kotlinx.serialization\"},\"2\":{\"name\":\"kotlinx.coroutines\"}}\n</code></pre> <p>It is a JSON-specific limitation that keys cannot be composite. It can be lifted as shown in the\u00a0Allowing structured map keys\u00a0section. \u952e\u4e0d\u80fd\u662f\u590d\u5408\u7684\uff0c\u8fd9\u662f\u7279\u5b9a\u4e8e JSON \u7684\u9650\u5236\u3002\u53ef\u4ee5\u6309\u7167\u5141\u8bb8\u7ed3\u6784\u5316\u6620\u5c04\u952e\u90e8\u5206\u4e2d\u6240\u793a\u7684\u65b9\u5f0f\u5c06\u5176\u89e3\u9664\u3002</p>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#unit-and-singleton-objects-unit","title":"Unit and singleton objects  Unit\u548c\u5355\u4f8b\u5bf9\u8c61","text":"<p>The Kotlin builtin\u00a0<code>Unit</code>\u00a0type is also serializable.\u00a0<code>Unit</code>\u00a0is a Kotlin\u00a0singleton object, and is handled equally with other Kotlin objects. Kotlin \u5185\u7f6e\u00a0<code>Unit</code>\u00a0\u7c7b\u578b\u4e5f\u662f\u53ef\u5e8f\u5217\u5316\u7684\u3002\u00a0<code>Unit</code>\u00a0\u662f\u4e00\u4e2a Kotlin \u5355\u4f8b\u5bf9\u8c61\uff0c\u4e0e\u5176\u4ed6 Kotlin \u5bf9\u8c61\u5904\u7406\u65b9\u5f0f\u76f8\u540c\u3002</p> <p>Conceptually, a singleton is a class with only one instance, meaning that state does not define the object, but the object defines its state. In JSON, objects are serialized as empty structures. \u4ece\u6982\u5ff5\u4e0a\u8bb2\uff0c\u5355\u4f8b\u662f\u4e00\u4e2a\u53ea\u6709\u4e00\u4e2a\u5b9e\u4f8b\u7684\u7c7b\uff0c\u8fd9\u610f\u5473\u7740\u72b6\u6001\u4e0d\u5b9a\u4e49\u5bf9\u8c61\uff0c\u4f46\u5bf9\u8c61\u5b9a\u4e49\u5176\u72b6\u6001\u3002\u5728 JSON \u4e2d\uff0c\u5bf9\u8c61\u88ab\u5e8f\u5217\u5316\u4e3a\u7a7a\u7ed3\u6784\u3002</p> <pre><code>@Serializable\nobject SerializationVersion {\n    val libraryVersion: String = \"1.0.0\"\n}\n\nfun main() {\n    println(Json.encodeToString(SerializationVersion))\n    println(Json.encodeToString(Unit))\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>While it may seem useless at first glance, this comes in handy for sealed class serialization, which is explained in the\u00a0Polymorphism. Objects\u00a0section. \u867d\u7136\u4e4d\u4e00\u770b\u4f3c\u4e4e\u6beb\u65e0\u7528\u5904\uff0c\u4f46\u8fd9\u5bf9\u4e8e\u5bc6\u5c01\u7c7b\u5e8f\u5217\u5316\u975e\u5e38\u6709\u7528\uff0c\u8fd9\u5728\u591a\u6001\u6027\u4e2d\u8fdb\u884c\u4e86\u89e3\u91ca\u3002\u201c\u5bf9\u8c61\u201d\u90e8\u5206\u3002</p> <pre><code>{}\n{}\n</code></pre> <p>Serialization of objects is format specific. Other formats may represent objects differently, e.g. using their fully-qualified names. \u5bf9\u8c61\u7684\u5e8f\u5217\u5316\u662f\u7279\u5b9a\u4e8e\u683c\u5f0f\u7684\u3002\u5176\u4ed6\u683c\u5f0f\u53ef\u80fd\u4ee5\u4e0d\u540c\u7684\u65b9\u5f0f\u8868\u793a\u5bf9\u8c61\uff0c\u4f8b\u5982\u4f7f\u7528\u5176\u5b8c\u5168\u9650\u5b9a\u7684\u540d\u79f0\u3002</p>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#duration","title":"Duration","text":"<p>Since Kotlin\u00a0<code>1.7.20</code>\u00a0the\u00a0Duration\u00a0class has become serializable. \u4ece Kotlin\u00a0<code>1.7.20</code>\u00a0\u5f00\u59cb\uff0cDuration \u7c7b\u53d8\u5f97\u53ef\u5e8f\u5217\u5316\u3002</p> <pre><code>fun main() {\n    val duration = 1000.toDuration(DurationUnit.SECONDS)\n    println(Json.encodeToString(duration))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Duration is serialized as a string in the ISO-8601-2 format. \u6301\u7eed\u65f6\u95f4\u4ee5 ISO-8601-2 \u683c\u5f0f\u5e8f\u5217\u5316\u4e3a\u5b57\u7b26\u4e32\u3002</p> <pre><code>\"PT16M40S\"\n</code></pre>"},{"location":"%E5%86%85%E7%BD%AE%E7%B1%BB-2/#nothing","title":"Nothing","text":"<p>By default,\u00a0Nothing\u00a0is a serializable class. However, since there are no instances of this class, it is impossible to encode or decode its values - any attempt will cause an exception. \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cNothing \u662f\u53ef\u5e8f\u5217\u5316\u7684\u7c7b\u3002\u4f46\u662f\uff0c\u7531\u4e8e\u6ca1\u6709\u6b64\u7c7b\u7684\u5b9e\u4f8b\uff0c\u56e0\u6b64\u65e0\u6cd5\u5bf9\u5176\u503c\u8fdb\u884c\u7f16\u7801\u6216\u89e3\u7801 - \u4efb\u4f55\u5c1d\u8bd5\u90fd\u4f1a\u5bfc\u81f4\u5f02\u5e38\u3002</p> <p>This serializer is used when syntactically some type is needed, but it is not actually used in serialization. For example, when using parameterized polymorphic base classes: \u5f53\u8bed\u6cd5\u4e0a\u9700\u8981\u67d0\u79cd\u7c7b\u578b\u65f6\uff0c\u4f1a\u4f7f\u7528\u6b64\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u4f46\u5b9e\u9645\u4e0a\u5e76\u672a\u5728\u5e8f\u5217\u5316\u4e2d\u4f7f\u7528\u3002\u4f8b\u5982\uff0c\u4f7f\u7528\u53c2\u6570\u5316\u591a\u6001\u57fa\u7c7b\u65f6\uff1a</p> <pre><code>@Serializable\nsealed class ParametrizedParent&lt;out R&gt; {\n    @Serializable\n    data class ChildWithoutParameter(val value: Int) : ParametrizedParent&lt;Nothing&gt;()\n}\n\nfun main() {\n    println(Json.encodeToString(ParametrizedParent.ChildWithoutParameter(42)))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>When encoding, the serializer for the\u00a0<code>Nothing</code>\u00a0was not used \u7f16\u7801\u65f6\uff0c\u672a\u4f7f\u7528 \u7684\u00a0<code>Nothing</code></p> <pre><code>{\"value\":42}\n</code></pre> <p>The next chapter covers\u00a0Serializers. \u4e0b\u4e00\u7ae0\u5c06\u4ecb\u7ecd\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002</p>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/","title":"Basic Serialization\u00a0\u57fa\u672c\u5e8f\u5217\u5316","text":"<p>This is the first chapter of the\u00a0Kotlin Serialization Guide. This chapter shows the basic use of Kotlin Serialization and explains its core concepts. \u8fd9\u662f\u300aKotlin \u5e8f\u5217\u5316\u6307\u5357\u300b\u7684\u7b2c\u4e00\u7ae0\u3002\u672c\u7ae0\u4ecb\u7ecd\u4e86 Kotlin \u5e8f\u5217\u5316\u7684\u57fa\u672c\u7528\u6cd5\uff0c\u5e76\u89e3\u91ca\u4e86\u5176\u6838\u5fc3\u6982\u5ff5\u3002</p> <p>Table of contents\u00a0\u76ee\u5f55</p> <ul> <li>Basics\u00a0\u57fa\u672c<ul> <li>JSON encoding\u00a0JSON \u7f16\u7801</li> <li>JSON decoding\u00a0JSON\u89e3\u7801</li> </ul> </li> <li>Serializable classes\u00a0\u53ef\u5e8f\u5217\u5316\u7c7b<ul> <li>Backing fields are serialized     \u652f\u6301\u5b57\u6bb5\u5df2\u5e8f\u5217\u5316</li> <li>Constructor properties requirement     \u6784\u9020\u51fd\u6570\u5c5e\u6027\u8981\u6c42</li> <li>Data validation\u00a0\u6570\u636e\u9a8c\u8bc1</li> <li>Optional properties\u00a0\u53ef\u9009\u5c5e\u6027</li> <li>Optional property initializer call     \u53ef\u9009\u5c5e\u6027\u521d\u59cb\u503c\u8bbe\u5b9a\u9879\u8c03\u7528</li> <li>Required properties\u00a0\u5fc5\u9700\u7684\u5c5e\u6027</li> <li>Transient properties\u00a0\u77ac\u6001\u7279\u6027</li> <li>Defaults are not encoded by default     \u9ed8\u8ba4\u60c5\u51b5\u4e0b\u4e0d\u5bf9\u9ed8\u8ba4\u503c\u8fdb\u884c\u7f16\u7801</li> <li>Nullable properties\u00a0\u53ef\u4e3a null \u7684\u5c5e\u6027</li> <li>Type safety is enforced     \u5f3a\u5236\u6267\u884c\u578b\u5f0f\u5b89\u5168</li> <li>Referenced objects\u00a0\u5f15\u7528\u7684\u5bf9\u8c61</li> <li>No compression of repeated references     \u4e0d\u538b\u7f29\u91cd\u590d\u5f15\u7528</li> <li>Generic classes\u00a0\u6cdb\u578b\u7c7b</li> <li>Serial field names\u00a0\u4e32\u884c\u5b57\u6bb5\u540d\u79f0</li> </ul> </li> </ul>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#basics","title":"Basics\u00a0\u57fa\u672c","text":"<p>To convert an object tree to a string or to a sequence of bytes, it must come through two mutually intertwined processes. In the first step, an object is\u00a0serialized\u2014it is converted into a serial sequence of its constituting primitive values. This process is common for all data formats and its result depends on the object being serialized. A\u00a0serializer\u00a0controls this process. The second step is called\u00a0encoding\u2014it is the conversion of the corresponding sequence of primitives into the output format representation. An\u00a0encoder\u00a0controls this process. Whenever the distinction is not important, both the terms of encoding and serialization are used interchangeably. \u8981\u5c06\u5bf9\u8c61\u6811\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u6216\u5b57\u8282\u5e8f\u5217\uff0c\u5b83\u5fc5\u987b\u7ecf\u8fc7\u4e24\u4e2a\u76f8\u4e92\u4ea4\u7ec7\u7684\u8fc7\u7a0b\u3002\u5728\u7b2c\u4e00\u6b65\u4e2d\uff0c\u5bf9\u8c61\u88ab\u5e8f\u5217\u5316\uff0c\u5373\u5c06\u5176\u8f6c\u6362\u4e3a\u5176\u6784\u6210\u57fa\u5143\u503c\u7684\u5e8f\u5217\u3002\u6b64\u8fc7\u7a0b\u5bf9\u4e8e\u6240\u6709\u6570\u636e\u683c\u5f0f\u90fd\u662f\u901a\u7528\u7684\uff0c\u5176\u7ed3\u679c\u53d6\u51b3\u4e8e\u8981\u5e8f\u5217\u5316\u7684\u5bf9\u8c61\u3002\u5e8f\u5217\u5316\u7a0b\u5e8f\u63a7\u5236\u6b64\u8fc7\u7a0b\u3002\u7b2c\u4e8c\u6b65\u79f0\u4e3a\u7f16\u7801\uff0c\u5b83\u662f\u5c06\u76f8\u5e94\u7684\u57fa\u5143\u5e8f\u5217\u8f6c\u6362\u4e3a\u8f93\u51fa\u683c\u5f0f\u8868\u793a\u5f62\u5f0f\u3002\u7f16\u7801\u5668\u63a7\u5236\u6b64\u8fc7\u7a0b\u3002\u6bcf\u5f53\u533a\u522b\u4e0d\u91cd\u8981\u65f6\uff0c\u7f16\u7801\u548c\u5e8f\u5217\u5316\u7684\u672f\u8bed\u53ef\u4ee5\u4e92\u6362\u4f7f\u7528\u3002</p> <pre><code>+---------+  Serialization  +------------+  Encoding  +---------------+\n| Objects | --------------&gt; | Primitives | ---------&gt; | Output format |\n+---------+                 +------------+            +---------------+\n</code></pre> <p>The reverse process starts with parsing of the input format and\u00a0decoding\u00a0of primitive values, followed by\u00a0deserialization\u00a0of the resulting stream into objects. We\u2019ll see details of this process later. \u53cd\u5411\u8fc7\u7a0b\u4ece\u89e3\u6790\u8f93\u5165\u683c\u5f0f\u548c\u89e3\u7801\u57fa\u5143\u503c\u5f00\u59cb\uff0c\u7136\u540e\u5c06\u751f\u6210\u7684\u6d41\u53cd\u5e8f\u5217\u5316\u4e3a\u5bf9\u8c61\u3002\u6211\u4eec\u7a0d\u540e\u5c06\u770b\u5230\u6b64\u8fc7\u7a0b\u7684\u8be6\u7ec6\u4fe1\u606f\u3002</p> <p>For now, we start with\u00a0JSON\u00a0encoding. \u73b0\u5728\uff0c\u6211\u4eec\u4eceJSON\u7f16\u7801\u5f00\u59cb\u3002</p>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#json-encoding-json","title":"JSON encoding\u00a0JSON \u7f16\u7801","text":"<p>The whole process of converting data into a specific format is called\u00a0encoding. For JSON we encode data using the\u00a0Json.encodeToString\u00a0extension function. It serializes the object that is passed as its parameter under the hood and encodes it to a JSON string. \u5c06\u6570\u636e\u8f6c\u6362\u4e3a\u7279\u5b9a\u683c\u5f0f\u7684\u6574\u4e2a\u8fc7\u7a0b\u79f0\u4e3a\u7f16\u7801\u3002\u5bf9\u4e8e JSON\uff0c\u6211\u4eec\u4f7f\u7528 Json.encodeToString \u6269\u5c55\u51fd\u6570\u5bf9\u6570\u636e\u8fdb\u884c\u7f16\u7801\u3002\u5b83\u5e8f\u5217\u5316\u5728\u540e\u53f0\u4f5c\u4e3a\u5176\u53c2\u6570\u4f20\u9012\u7684\u5bf9\u8c61\uff0c\u5e76\u5c06\u5176\u7f16\u7801\u4e3a JSON \u5b57\u7b26\u4e32\u3002</p> <p>Let\u2019s start with a class describing a project and try to get its JSON representation. \u8ba9\u6211\u4eec\u4ece\u4e00\u4e2a\u63cf\u8ff0\u9879\u76ee\u7684\u7c7b\u5f00\u59cb\uff0c\u5e76\u5c1d\u8bd5\u83b7\u53d6\u5176 JSON \u8868\u793a\u5f62\u5f0f\u3002</p> <pre><code>class Project(val name: String, val language: String)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\", \"Kotlin\")\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>When we run this code we get the exception. \u5f53\u6211\u4eec\u8fd0\u884c\u6b64\u4ee3\u7801\u65f6\uff0c\u6211\u4eec\u5f97\u5230\u5f02\u5e38\u3002</p> <pre><code>Exception in thread \"main\" kotlinx.serialization.SerializationException: Serializer for class 'Project' is not found.\nPlease ensure that class is marked as '@Serializable' and that the serialization compiler plugin is applied.\n</code></pre> <p>Serializable classes have to be explicitly marked. Kotlin Serialization does not use reflection, so you cannot accidentally deserialize a class which was not supposed to be serializable. We fix it by adding the\u00a0<code>@Serializable</code>\u00a0annotation. \u901a\u8fc7\u6dfb\u52a0\u00a0<code>@Serializable</code>\u00a0\u6ce8\u89e3\u6765\u6807\u660e\u6b64\u7c7b\u662f\u4e00\u4e2a\u53ef\u5e8f\u5217\u5316\u7c7b\u3002Kotlin \u5e8f\u5217\u5316\u4e0d\u4f7f\u7528\u53cd\u5c04\uff0c\u56e0\u6b64\u60a8\u4e0d\u4f1a\u610f\u5916\u5730\u53cd\u5e8f\u5217\u5316\u4e0d\u5e94\u8be5\u53ef\u5e8f\u5217\u5316\u7684\u7c7b\u3002</p> <pre><code>@Serializable\nclass Project(val name: String, val language: String)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\", \"Kotlin\")\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The\u00a0<code>@Serializable</code>\u00a0annotation instructs the Kotlin Serialization plugin to automatically generate and hook up a\u00a0serializer\u00a0for this class. Now the output of the example is the corresponding JSON. <code>@Serializable</code>\u00a0\u6ce8\u89e3\u4f1a\u4f7f \u201cKotlin \u5e8f\u5217\u5316\u63d2\u4ef6\u201d \u81ea\u52a8\u751f\u6210\u5e76\u6302\u63a5\u6b64\u7c7b\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002\u6b64\u65f6\uff0c\u793a\u4f8b\u7684\u8f93\u51fa\u4e0d\u4f1a\u62a5\u9519\u4e86\uff0c\u4f1a\u8f93\u51fa\u76f8\u5e94\u7684 JSON\u3002</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"language\":\"Kotlin\"}\n</code></pre> <p>There is a whole chapter about the\u00a0Serializers. For now, it is enough to know that they are automatically generated by the Kotlin Serialization plugin. \u6709\u4e00\u6574\u7ae0\u662f\u5173\u4e8e\u5e8f\u5217\u5316\u7a0b\u5e8f\u7684\u3002\u73b0\u5728\uff0c\u53ea\u8981\u77e5\u9053\u5b83\u4eec\u662f\u7531 Kotlin \u5e8f\u5217\u5316\u63d2\u4ef6\u81ea\u52a8\u751f\u6210\u7684\u5c31\u8db3\u591f\u4e86\u3002</p>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#json-decoding-json","title":"JSON decoding\u00a0JSON\u89e3\u7801","text":"<p>The reverse process is called\u00a0decoding. To decode a JSON string into an object, we\u2019ll use the\u00a0Json.decodeFromString\u00a0extension function. To specify which type we want to get as a result, we provide a type parameter to this function. \u53cd\u5411\u8fc7\u7a0b\u79f0\u4e3a\u89e3\u7801\uff08\u53cd\u5e8f\u5217\u5316\uff09\u3002\u82e5\u8981\u5c06 JSON \u5b57\u7b26\u4e32\u89e3\u7801\u4e3a\u5bf9\u8c61\uff0c\u6211\u4eec\u5c06\u4f7f\u7528 Json.decodeFromString \u6269\u5c55\u51fd\u6570\u3002\u4e3a\u4e86\u6307\u5b9a\u6211\u4eec\u60f3\u8981\u83b7\u5f97\u7684\u7c7b\u578b\uff0c\u6211\u4eec\u4e3a\u6b64\u51fd\u6570\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7c7b\u578b\u53c2\u6570\u3002</p> <p>As we\u2019ll see later, serialization works with different kinds of classes. Here we are marking our\u00a0<code>Project</code>\u00a0class as a\u00a0<code>data class</code>, not because it is required, but because we want to print its contents to verify how it decodes. \u6b63\u5982\u6211\u4eec\u7a0d\u540e\u5c06\u770b\u5230\u7684\uff0c\u5e8f\u5217\u5316\u53ef\u7528\u4e8e\u4e0d\u540c\u7c7b\u578b\u7684\u7c7b\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u5c06\u6211\u4eec\u7684\u00a0<code>Project</code>\u00a0\u7c7b\u6807\u8bb0\u4e3a\u00a0<code>data class</code>\u00a0\uff0c\u4e0d\u662f\u56e0\u4e3a\u5b83\u662f\u5fc5\u9700\u7684\uff0c\u800c\u662f\u56e0\u4e3a\u6211\u4eec\u60f3\u8981\u6253\u5370\u5176\u5185\u5bb9\u4ee5\u9a8c\u8bc1\u5b83\u662f\u5982\u4f55\u89e3\u7801\u7684\u3002</p> <pre><code>@Serializable\ndata class Project(val name: String, val language: String)\n\nfun main() {\n    val data = Json.decodeFromString&lt;Project&gt;(\"\"\"\n        {\"name\":\"kotlinx.serialization\",\"language\":\"Kotlin\"}\n    \"\"\")\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Running this code we get back the object. \u8fd0\u884c\u6b64\u4ee3\u7801\uff0c\u5c06\u5f97\u5230\u5e8f\u5217\u5316\u4e4b\u540e\u7684\u5bf9\u8c61\u3002</p> <pre><code>Project(name=kotlinx.serialization, language=Kotlin)\n</code></pre>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#serializable-classes","title":"Serializable classes\u00a0\u53ef\u5e8f\u5217\u5316\u7c7b","text":"<p>This section goes into more details on how different\u00a0<code>@Serializable</code>\u00a0classes are handled. \u672c\u8282\u5c06\u66f4\u8be6\u7ec6\u5730\u4ecb\u7ecd\u5982\u4f55\u5904\u7406\u4e0d\u540c\u7684\u00a0<code>@Serializable</code>\u00a0\u7c7b\u3002</p>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#backing-fields-are-serialized","title":"Backing fields are serialized","text":"<p>\u5e55\u540e\u5b57\u6bb5\u53ef\u5e8f\u5217\u5316</p> <p>Only a class\u2019s properties with backing fields are serialized, so properties with a getter/setter that don\u2019t have a backing field and delegated properties are not serialized, as the following example shows.  </p> <p>Note</p> <p>backing fields\uff1a\u5f88\u591a\u8bd1\u6587\u5c06\u5176\u7ffb\u8bd1\u4e3a\u5e55\u540e\u5c5e\u6027\u6216\u5e55\u540e\u5b57\u6bb5 \u5982\u679c\u5728kotlin\u7c7b\u4e2d\u5b9a\u4e49\u4e00\u4e2a\u6210\u5458\u53d8\u91cf\uff0cKotlin\u5c06\u81ea\u52a8\u751f\u6210\u9ed8\u8ba4setter/getter\u65b9\u6cd5\u3002\u800cKotlin\u63d0\u4f9b\u4e86\u4e00\u79cd\u975e\u5e38\u7279\u6b8a\u7684\u65b9\u5f0f\u58f0\u660esetter/getter\u65b9\u6cd5\uff1a</p> <pre><code>  var name: String? = null\n        //setter\u65b9\u6cd5\n        set(value) {\n            field = value\n        }\n        //getter\u65b9\u6cd5\n        get() = field\n</code></pre> <p>setter\u548cgetter\u4e2d\u7684field\u5b57\u6bb5\u5c31\u662fbacking fields\u3002</p> <p>\u6240\u4ee5\uff0c\u6587\u6863\u4e0a\u8bb2\u6709backing fields == \u6709setter\u548cgetter\u65b9\u6cd5</p> <p>\u5728\u67d0\u4e2a\u7c7b\u4e2d\uff0c\u5177\u6709setter\u548cgetter\u7684\u5c5e\u6027\u624d\u4f1a\u88ab\u5e8f\u5217\u5316\u3002\u4e0d\u5177\u6709 geter/setter \u548c\u59d4\u6258\u5c5e\u6027\u7684\u5c5e\u6027\u90fd\u4e0d\u4f1a\u88ab\u5e8f\u5217\u5316\uff0c\u5982\u4ee5\u4e0b\u793a\u4f8b\u6240\u793a\u3002</p> <pre><code>@Serializable\nclass Project(\n    // name is a property with backing field -- serialized\n    // name \u5177\u6709backing fields --\u53ef\u5e8f\u5217\u5316\n    var name: String\n) {\n    // property with a backing field -- serialized\n    // stars \u5177\u6709backing fields --\u53ef\u5e8f\u5217\u5316\n    var stars: Int = 0 \n\n    // getter only, no backing field -- not serialized\n    // \u53ea\u6709getter\uff0c\u6ca1\u6709setter\uff0c\u4e0d\u80fd\u88ab\u5e8f\u5217\u5316\n    val path: String \n        get() = \"kotlin/$name\"\n\n    // delegated property -- not serialized\n    // \u59d4\u6258\u5c5e\u6027 --\u4e0d\u53ef\u88ab\u5e8f\u5217\u5316\n    var id by ::name \n}\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\").apply { stars = 9000 }\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>We can clearly see that only the\u00a0<code>name</code>\u00a0and\u00a0<code>stars</code>\u00a0properties are present in the JSON output. \u6211\u4eec\u53ef\u4ee5\u6e05\u695a\u5730\u770b\u5230\uff0cJSON \u8f93\u51fa\u4e2d\u53ea\u5b58\u5728\u00a0<code>name</code>\u00a0and\u00a0<code>stars</code>\u00a0\u5c5e\u6027\u3002</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"stars\":9000}\n</code></pre>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#constructor-properties-requirement","title":"Constructor properties requirement","text":"<p>\u6784\u9020\u51fd\u6570\u5c5e\u6027\u8981\u6c42</p> <p>If we want to define the\u00a0<code>Project</code>\u00a0class so that it takes a path string, and then deconstructs it into the corresponding properties, we might be tempted to write something like the code below. \u5982\u679c\u6211\u4eec\u60f3\u5b9a\u4e49\u4e00\u4e2a\u7c7b\uff1a<code>Project</code>\u00a0\uff0c\u4ee5\u4fbf\u5c06\u6784\u9020\u51fd\u6570\u4e2d\u4f20\u5165\u7684\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u76f8\u5e94\u7684\u5c5e\u6027\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u60f3\u7f16\u5199\u5982\u4e0b\u4ee3\u7801\uff1a</p> <pre><code>@Serializable\nclass Project(path: String) {\n    val owner: String = path.substringBefore('/')\n    val name: String = path.substringAfter('/')\n}\n</code></pre> <p>This class does not compile because the\u00a0<code>@Serializable</code>\u00a0annotation requires that all parameters of the class\u2019s primary constructor be properties. A simple workaround is to define a private primary constructor with the class\u2019s properties, and turn the constructor we wanted into the secondary one. \u6b64\u7c7b\u65e0\u6cd5\u88ab\u7f16\u8bd1\uff0c\u56e0\u4e3a\u00a0<code>@Serializable</code>\u00a0\u6ce8\u89e3\u8981\u6c42\u7c7b\u7684\u4e3b\u6784\u9020\u51fd\u6570\u7684\u6240\u6709\u53c2\u6570\u90fd\u662f\u5c5e\u6027\u3002\u4e00\u4e2a\u7b80\u5355\u7684\u89e3\u51b3\u65b9\u6cd5\u662f\uff1a\u5b9a\u4e49\u4e00\u4e2a\u5177\u6709\u6240\u9700\u5b57\u6bb5\u7684\u79c1\u6709\u7684\u4e3b\u6784\u9020\u51fd\u6570\uff0c\u5e76\u4f7f\u7528\u8f85\u52a9\u6784\u9020\u51fd\u6570\u95f4\u63a5\u8c03\u7528\u4e3b\u6784\u9020\u51fd\u6570\u3002</p> <pre><code>@Serializable\nclass Project private constructor(val owner: String, val name: String) {\n    constructor(path: String) : this(\n        owner = path.substringBefore('/'),\n        name = path.substringAfter('/')\n    )\n\n    val path: String\n        get() = \"$owner/$name\"\n}\n</code></pre> <p>Serialization works with a private primary constructor, and still serializes only backing fields. \u5bf9\u4e8e\u8fd9\u6837\u5177\u6709\u79c1\u6709\u6784\u9020\u51fd\u6570\u7684\u7c7b\uff0c\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u53ef\u4ee5\u6b63\u5e38\u5de5\u4f5c\uff0c\u800c\u4e14\uff0c\u4f9d\u65e7\u53ea\u80fd\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u5177\u6709\u5e55\u540e\u5b57\u6bb5\u7684\u5c5e\u6027</p> <pre><code>fun main() {\n    println(Json.encodeToString(Project(\"kotlin/kotlinx.serialization\")))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>This example produces the expected output. \u6b64\u793a\u4f8b\u751f\u6210\u9884\u671f\u7684\u8f93\u51fa\u3002</p> <pre><code>{\"owner\":\"kotlin\",\"name\":\"kotlinx.serialization\"}\n</code></pre>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#data-validation","title":"Data validation\u00a0\u6570\u636e\u9a8c\u8bc1","text":"<p>Another case where you might want to introduce a primary constructor parameter without a property is when you want to validate its value before storing it to a property. To make it serializable you shall replace it with a property in the primary constructor, and move the validation to an\u00a0<code>init { ... }</code>\u00a0block. \u53e6\u4e00\u79cd\u53ef\u80fd\uff0c\u60f3\u5728\u4e0d\u521b\u5efa\u5c5e\u6027\u7684\u60c5\u51b5\u4e0b\uff0c\u8ba9\u4e3b\u6784\u9020\u5668\u63a5\u6536\u6570\u636e\uff0c\u5e76\u5728\u5176\u5b58\u50a8\u5230\u5c5e\u6027\u4e4b\u524d\u6821\u9a8c\u4f20\u5165\u6570\u636e\u3002\u4e3a\u4e86\u4f7f\u5176\u53ef\u5e8f\u5217\u5316\uff0c\u4f60\u5e94\u8be5\u5728\u4e3b\u6784\u9020\u5668\u4e2d\u7528\u5c5e\u6027\u66ff\u6362\u5b83\uff0c\u5e76\u5c06\u9a8c\u8bc1\u79fb\u52a8\u5230<code>init { ... }</code>\u5757\u4e2d\u3002</p> <pre><code>@Serializable\nclass Project(val name: String) {\n    init {\n        require(name.isNotEmpty()) { \"name cannot be empty\" }\n    }\n}\n</code></pre> <p>A deserialization process works like a regular constructor in Kotlin and calls all\u00a0<code>init</code>\u00a0blocks, ensuring that you cannot get an invalid class as a result of deserialization. Let\u2019s try it. \u5728 Kotlin \u4e2d\uff0c\u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e0e\u5e38\u89c4\u6784\u9020\u5668\u7684\u5de5\u4f5c\u65b9\u5f0f\u7c7b\u4f3c\uff0c\u5b83\u4f1a\u8c03\u7528\u6240\u6709\u7684\u00a0<code>init</code>\u00a0\u5757\uff0c\u786e\u4fdd\u53cd\u5e8f\u5217\u5316\u540e\u4e0d\u4f1a\u5f97\u5230\u65e0\u6548\u7684\u7c7b\u5b9e\u4f8b\u3002\u8ba9\u6211\u4eec\u8bd5\u8bd5\u5427\u3002</p> <pre><code>fun main() {\n    val data = Json.decodeFromString&lt;Project&gt;(\"\"\"\n        {\"name\":\"\"}\n    \"\"\")\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Running this code produces the exception: \u8fd0\u884c\u6b64\u4ee3\u7801\u5c06\u751f\u6210\u5f02\u5e38\uff1a</p> <pre><code>Exception in thread \"main\" java.lang.IllegalArgumentException: name cannot be empty\n</code></pre>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#optional-properties","title":"Optional properties\u00a0\u53ef\u9009\u5c5e\u6027","text":"<p>An object can be deserialized only when all its properties are present in the input. For example, run the following code. \u53ea\u6709\u5f53\u8f93\u5165\u4e2d\u5b58\u5728\u5bf9\u8c61\u7684\u6240\u6709\u5c5e\u6027\u65f6\uff0c\u624d\u80fd\u53cd\u5e8f\u5217\u5316\u5bf9\u8c61\u3002\u4f8b\u5982\uff0c\u8fd0\u884c\u4ee5\u4e0b\u4ee3\u7801\u3002</p> <pre><code>@Serializable\ndata class Project(val name: String, val language: String)\n\nfun main() {\n    val data = Json.decodeFromString&lt;Project&gt;(\"\"\"\n        {\"name\":\"kotlinx.serialization\"}\n    \"\"\")\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>It produces the exception: \u5b83\u4f1a\u4ea7\u751f\u5f02\u5e38\uff1a</p> <pre><code>Exception in thread \"main\" kotlinx.serialization.MissingFieldException: Field 'language' is required for type with serial name 'example.exampleClasses04.Project', but it was missing at path: $\n</code></pre> <p>This problem can be fixed by adding a default value to the property, which automatically makes it optional for serialization. \u53ef\u4ee5\u901a\u8fc7\u5411\u5c5e\u6027\u6dfb\u52a0\u9ed8\u8ba4\u503c\u6765\u89e3\u51b3\u6b64\u95ee\u9898\uff0c\u8be5\u503c\u4f1a\u81ea\u52a8\u4f7f\u5176\u6210\u4e3a\u5e8f\u5217\u5316\u7684\u53ef\u9009\u503c\u3002</p> <pre><code>@Serializable\ndata class Project(val name: String, val language: String = \"Kotlin\")\n\nfun main() {\n    val data = Json.decodeFromString&lt;Project&gt;(\"\"\"\n        {\"name\":\"kotlinx.serialization\"}\n    \"\"\")\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>It produces the following output with the default value for the\u00a0<code>language</code>\u00a0property. \u5b83\u5c06\u751f\u6210\u4ee5\u4e0b\u8f93\u51fa\uff0c\u5176\u4e2d\u5305\u542b\u00a0<code>language</code>\u00a0\u8be5\u5c5e\u6027\u7684\u9ed8\u8ba4\u503c\u3002</p> <pre><code>Project(name=kotlinx.serialization, language=Kotlin)\n</code></pre>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#optional-property-initializer-call","title":"Optional property initializer call","text":"<p>\u53ef\u9009\u5c5e\u6027\u521d\u59cb\u5316\u5668\u8c03\u7528</p> <p>Note</p> <p>\u53ef\u9009\u5c5e\u6027\u521d\u59cb\u5316\u5668\u8c03\u7528\uff08Optional property initializer call\uff09\u662f\u6307\u5728 Kotlin \u4e2d\uff0c\u5bf9\u4e8e\u7c7b\u7684\u5c5e\u6027\uff0c\u4f60\u53ef\u4ee5\u9009\u62e9\u6027\u5730\u63d0\u4f9b\u4e00\u4e2a\u521d\u59cb\u5316\u5668\uff08initializer\uff09\uff0c\u8fd9\u4e2a\u521d\u59cb\u5316\u5668\u4f1a\u5728\u6784\u9020\u5668\u6267\u884c\u65f6\u521d\u59cb\u5316\u5c5e\u6027\u7684\u503c\u3002\u5982\u679c\u67d0\u4e2a\u5c5e\u6027\u4e0d\u662f\u5fc5\u9700\u7684\uff0c\u6216\u8005\u5176\u521d\u59cb\u5316\u4f9d\u8d56\u4e8e\u67d0\u4e9b\u6761\u4ef6\uff0c\u90a3\u4e48\u4f60\u53ef\u4ee5\u5c06\u5176\u521d\u59cb\u5316\u5668\u8bbe\u4e3a\u53ef\u9009\u7684\u3002\u8fd9\u610f\u5473\u7740\u4f60\u53ef\u4ee5\u9009\u62e9\u5728\u7279\u5b9a\u7684\u6784\u9020\u5668\u6216\u521d\u59cb\u5316\u5757\u4e2d\u521d\u59cb\u5316\u8be5\u5c5e\u6027\uff0c\u800c\u4e0d\u662f\u5728\u58f0\u660e\u5c5e\u6027\u65f6\u5c31\u7acb\u5373\u521d\u59cb\u5316\u3002</p> <p>When an optional property is present in the input, the corresponding initializer for this property is not even called. This is a feature designed for performance, so be careful not to rely on side effects in initializers. Consider the example below. \u5f53\u8f93\u5165\u4e2d\u5b58\u5728\u53ef\u9009\u5c5e\u6027\u65f6\uff0c\u8be5\u5c5e\u6027\u7684\u76f8\u5e94\u521d\u59cb\u5316\u5668\u4e0d\u4f1a\u88ab\u8c03\u7528\u3002\u8fd9\u662f\u4e00\u9879\u4e13\u4e3a\u63d0\u9ad8\u6027\u80fd\u800c\u8bbe\u8ba1\u7684\u529f\u80fd\uff0c\u56e0\u6b64\u8bf7\u6ce8\u610f\u4e0d\u8981\u4f9d\u8d56\u521d\u59cb\u503c\u8bbe\u5b9a\u9879\u4e2d\u7684\u9644\u5e26\u6548\u5e94\u3002\u8bf7\u770b\u4e0b\u9762\u7684\u4f8b\u5b50\u3002</p> <pre><code>fun computeLanguage(): String {\n    println(\"Computing\")\n    return \"Kotlin\"\n}\n\n@Serializable\ndata class Project(val name: String, val language: String = computeLanguage())\n\nfun main() {\n    val data = Json.decodeFromString&lt;Project&gt;(\"\"\"\n        {\"name\":\"kotlinx.serialization\",\"language\":\"Kotlin\"}\n    \"\"\")\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Since the\u00a0<code>language</code>\u00a0property was specified in the input, we don\u2019t see the \u201cComputing\u201d string printed in the output. \u7531\u4e8e\u8be5\u00a0<code>language</code>\u00a0\u5c5e\u6027\u662f\u5728\u8f93\u5165\u4e2d\u6307\u5b9a\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u770b\u4e0d\u5230\u8f93\u51fa\u4e2d\u6253\u5370\u7684\u201cComputing\u201d\u5b57\u7b26\u4e32\u3002</p> <pre><code>Project(name=kotlinx.serialization, language=Kotlin)\n</code></pre>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#required-properties","title":"Required properties\u00a0\u5fc5\u9700\u7684\u5c5e\u6027","text":"<p>A property with a default value can be required in a serial format with the\u00a0<code>@Required</code>\u00a0annotation. Let us change the previous example by marking the\u00a0<code>language</code>\u00a0property as\u00a0<code>@Required</code>. \u4e00\u4e2a\u5e26\u6709\u9ed8\u8ba4\u503c\u7684\u5c5e\u6027\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528<code>@Required</code>\u6ce8\u89e3\u5728\u5e8f\u5217\u5316\u683c\u5f0f\u4e2d\u88ab\u6807\u8bb0\u4e3a\u5fc5\u9700\u7684\u3002\u4f8b\u5982\uff1a\u628a\u4e4b\u524d\u4f8b\u5b50\u4e2d<code>language</code>\u5c5e\u6027\u6807\u8bb0\u4e3a<code>@Required</code></p> <pre><code>@Serializable\ndata class Project(val name: String, @Required val language: String = \"Kotlin\")\n\nfun main() {\n    val data = Json.decodeFromString&lt;Project&gt;(\"\"\"\n        {\"name\":\"kotlinx.serialization\"}\n    \"\"\")\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>We get the following exception. \u6211\u4eec\u5f97\u5230\u4ee5\u4e0b\u5f02\u5e38\u3002</p> <pre><code>Exception in thread \"main\" kotlinx.serialization.MissingFieldException: Field 'language' is required for type with serial name 'example.exampleClasses07.Project', but it was missing at path: $\n</code></pre>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#transient-properties","title":"Transient properties\u00a0\u5ffd\u7565\u67d0\u5c5e\u6027\u5e8f\u5217\u5316","text":"<p>A property can be excluded from serialization by marking it with the\u00a0<code>@Transient</code>\u00a0annotation (don\u2019t confuse it with\u00a0kotlin.jvm.Transient). Transient properties must have a default value. \u4e00\u4e2a\u5c5e\u6027\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528[<code>@Transient</code>]\u6ce8\u89e3\u6765\u4ece\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\u6392\u9664\uff08\u4e0d\u8981\u4e0e[kotlin.jvm.Transient]\u6df7\u6dc6\uff09\u3002\u88ab\u6807\u8bb0\u4e3aTransient\u7684\u5c5e\u6027\u5fc5\u987b\u6709\u4e00\u4e2a\u9ed8\u8ba4\u503c\u3002  </p> <p>Note</p> <p><code>@Transient</code>\u662f\u4e00\u4e2a\u7528\u4e8eKotlin\u6216Java\u5bf9\u8c61\u5e8f\u5217\u5316\u65f6\u7684\u6ce8\u89e3\uff0c\u5b83\u544a\u8bc9\u5e8f\u5217\u5316\u5668\u5ffd\u7565\u8be5\u5c5e\u6027\uff0c\u5373\u4f7f\u8be5\u5bf9\u8c61\u7684\u5176\u4ed6\u90e8\u5206\u6b63\u5728\u88ab\u5e8f\u5217\u5316\u3002\u8fd9\u5728\u4f60\u4e0d\u5e0c\u671b\u67d0\u4e9b\u5b57\u6bb5\uff08\u6bd4\u5982\u654f\u611f\u4fe1\u606f\u6216\u4e34\u65f6\u72b6\u6001\uff09\u88ab\u6301\u4e45\u5316\u6216\u901a\u8fc7\u7f51\u7edc\u4f20\u8f93\u65f6\u975e\u5e38\u6709\u7528\u3002 \u6b64\u5916\uff0c<code>Transient</code>\u5c5e\u6027\u5fc5\u987b\u6709\u4e00\u4e2a\u9ed8\u8ba4\u503c\uff0c\u8fd9\u662f\u56e0\u4e3a\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e0d\u5305\u62ec\u8fd9\u4e9b\u5c5e\u6027\uff0c\u6240\u4ee5\u5728\u53cd\u5e8f\u5217\u5316\u65f6\uff0c\u5982\u679c\u6ca1\u6709\u9ed8\u8ba4\u503c\uff0c\u8fd9\u4e9b\u5c5e\u6027\u53ef\u80fd\u4f1a\u662f\u672a\u5b9a\u4e49\u7684\u6216\u8005\u4e0d\u53ef\u9884\u6d4b\u7684\u3002 \u6ce8\u610f\uff0c<code>kotlin.jvm.Transient</code>\u662fKotlin\u8bed\u8a00\u7279\u6709\u7684\uff0c\u7528\u4e8e\u6807\u8bb0\u5728JVM\u5e73\u53f0\u4e0a\u5e94\u8be5\u5ffd\u7565\u7684\u5c5e\u6027\uff0c\u5982\u679c\u7528transient\u58f0\u660e\u4e00\u4e2a\u5b9e\u4f8b\u53d8\u91cf\uff0c\u5f53\u5bf9\u8c61\u5b58\u50a8\u65f6\uff0c\u5b83\u7684\u503c\u4e0d\u9700\u8981\u7ef4\u6301\u3002\u6362\u53e5\u8bdd\u6765\u8bf4\u5c31\u662f\uff0c\u7528transient\u5173\u952e\u5b57\u6807\u8bb0\u7684\u6210\u5458\u53d8\u91cf\u4e0d\u53c2\u4e0e\u5e8f\u5217\u5316\u8fc7\u7a0b\u3002 \u901a\u5e38\u7528\u5728Fragment\u8c03\u8f6c\u4f20\u503c, Bundle\u4e2d\u7684\u4f7f\u7528.</p> <pre><code>@Serializable\ndata class Project(val name: String, @Transient val language: String = \"Kotlin\")\n\nfun main() {\n    val data = Json.decodeFromString&lt;Project&gt;(\"\"\"\n        {\"name\":\"kotlinx.serialization\",\"language\":\"Kotlin\"}\n    \"\"\")\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Attempts to explicitly specify its value in the serial format, even if the specified value is equal to the default one, produces the following exception. \u5728\u5e8f\u5217\u5316\u683c\u5f0f\u4e2d\u5c1d\u8bd5\u663e\u5f0f\u6307\u5b9a<code>@Transient</code>\u5c5e\u6027\u7684\u503c\uff0c\u5373\u4f7f\u6307\u5b9a\u7684\u503c\u7b49\u4e8e\u9ed8\u8ba4\u503c\uff0c\u4e5f\u4f1a\u5f15\u53d1\u4ee5\u4e0b\u5f02\u5e38\u3002</p> <pre><code>Exception in thread \"main\" kotlinx.serialization.json.internal.JsonDecodingException: Unexpected JSON token at offset 42: Encountered an unknown key 'language' at path: $.name\nUse 'ignoreUnknownKeys = true' in 'Json {}' builder to ignore unknown keys.\n</code></pre> <p>The \u2018ignoreUnknownKeys\u2019 feature is explained in the\u00a0Ignoring Unknown Keys section\u00a0section. \u201cignoreUnknownKeys\u201d\u529f\u80fd\u5728\u201c\u5ffd\u7565\u672a\u77e5\u952e\u201d\u90e8\u5206\u90e8\u5206\u8fdb\u884c\u4e86\u8bf4\u660e\u3002</p> <p>Note</p> <p>\u5176\u5b9e\u5c31\u662f\u8bf4\uff0c<code>@Transient</code>\u6807\u8bb0\u7684\u5c5e\u6027\u4e0d\u4f1a\u88ab\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\uff0c\u4f46\u662f\u5462\uff0c\u4ed6\u5728\u7c7b\u4e2d\u8fd8\u5fc5\u987b\u8981\u6709\u9ed8\u8ba4\u503c\u3002\u5e8f\u5217\u5316\u7684\u65f6\u5019\u751f\u6210\u7684json\u4e2d\u4e0d\u4f1a\u6709\u8fd9\u4e2a\u5c5e\u6027\u3002\u53cd\u5e8f\u5217\u5316\u65f6\uff0cjson\u4e2d\u6709\u8fd9\u4e2a\u5c5e\u6027\uff0c\u53cd\u5e8f\u5217\u5316\u4f1a\u62a5\u9519\u3002 \u5982\u679c\u53cd\u5e8f\u5217\u5316\u65f6\uff0cjson\u4e2d\u6709\u8fd9\u4e2a\u5c5e\u6027\u7684\u503c\uff0c\u53c8\u4e0d\u60f3\u62a5\u9519\uff0c\u9700\u8981\u7ed9Json\u914d\u7f6eignoreUnknownKeys\u5c5e\u6027\u4e3atrue</p>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#defaults-are-not-encoded-by-default","title":"Defaults are not encoded by default","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u4e0d\u5bf9\u9ed8\u8ba4\u503c\u8fdb\u884c\u7f16\u7801</p> <p>Default values are not encoded by default in JSON. This behavior is motivated by the fact that in most real-life scenarios such configuration reduces visual clutter, and saves the amount of data being serialized. \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5e8f\u5217\u5316\u4e4b\u540e\uff0c\u9ed8\u8ba4\u503c\u4e0d\u4f1a\u51fa\u73b0\u5728json\u5b57\u7b26\u4e32\u4e2d\u3002\u8fd9\u79cd\u884c\u4e3a\u7684\u52a8\u673a\u662f\uff0c\u5728\u5927\u591a\u6570\u73b0\u5b9e\u751f\u6d3b\u4e2d\uff0c\u8fd9\u79cd\u914d\u7f6e\u53ef\u4ee5\u51cf\u5c11\u89c6\u89c9\u6df7\u4e71\uff0c\u5e76\u8282\u7701\u8981\u5e8f\u5217\u5316\u7684\u6570\u636e\u91cf\u3002</p> <pre><code>@Serializable\ndata class Project(val name: String, val language: String = \"Kotlin\")\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\")\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>It produces the following output, which does not have the\u00a0<code>language</code>\u00a0property because its value is equal to the default one. \u5b83\u751f\u6210\u4ee5\u4e0b\u8f93\u51fa\uff0c\u8be5\u8f93\u51fa\u6ca1\u6709\u8be5\u00a0<code>language</code>\u00a0\u5c5e\u6027\uff0c\u56e0\u4e3a\u5b83\u7684\u503c\u7b49\u4e8e\u9ed8\u8ba4\u503c\u3002</p> <pre><code>{\"name\":\"kotlinx.serialization\"}\n</code></pre> <p>See JSON\u2019s\u00a0Encoding defaults\u00a0section on how this behavior can be configured for JSON. Additionally, this behavior can be controlled without taking format settings into account. For that purposes,\u00a0EncodeDefault\u00a0annotation can be used: \u8bf7\u53c2\u9605 JSON \u7684\u7f16\u7801\u9ed8\u8ba4\u503c\u90e8\u5206\uff0c\u4e86\u89e3\u5982\u4f55\u4e3a JSON \u914d\u7f6e\u6b64\u884c\u4e3a\u3002\u6b64\u5916\uff0c\u53ef\u4ee5\u5728\u4e0d\u8003\u8651\u683c\u5f0f\u8bbe\u7f6e\u7684\u60c5\u51b5\u4e0b\u63a7\u5236\u6b64\u884c\u4e3a\u3002\u4e3a\u6b64\uff0c\u53ef\u4ee5\u4f7f\u7528 EncodeDefault \u6ce8\u91ca\uff1a</p> <pre><code>@Serializable\ndata class Project(\n    val name: String,\n    @EncodeDefault val language: String = \"Kotlin\"\n)\n</code></pre> <p>This annotation instructs the framework to always serialize property, regardless of its value or format settings. It\u2019s also possible to tweak it into the opposite behavior using\u00a0EncodeDefault.Mode\u00a0parameter: \u6b64\u6ce8\u89e3\u6307\u793a\u6846\u67b6\u59cb\u7ec8\u5e8f\u5217\u5316\u5c5e\u6027\uff0c\u800c\u4e0d\u8003\u8651\u5176\u503c\u6216\u683c\u5f0f\u8bbe\u7f6e\u3002\u4e5f\u53ef\u4ee5\u4f7f\u7528 EncodeDefault.Mode \u53c2\u6570\u5c06\u5176\u8c03\u6574\u4e3a\u76f8\u53cd\u7684\u884c\u4e3a\uff1a</p> <pre><code>@Serializable\ndata class User(\n    val name: String,\n    @EncodeDefault(EncodeDefault.Mode.NEVER) val projects: List&lt;Project&gt; = emptyList()\n)\n\nfun main() {\n    val userA = User(\"Alice\", listOf(Project(\"kotlinx.serialization\")))\n    val userB = User(\"Bob\")\n    println(Json.encodeToString(userA))\n    println(Json.encodeToString(userB))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>As you can see,\u00a0<code>language</code>\u00a0property is preserved and\u00a0<code>projects</code>\u00a0is omitted: \u6b63\u5982\u4f60\u6240\u770b\u5230\u7684\uff0c\u00a0<code>language</code>\u00a0\u5c5e\u6027\u88ab\u4fdd\u7559\u5e76\u88ab\u00a0<code>projects</code>\u00a0\u7701\u7565\uff1a</p> <pre><code>{\"name\":\"Alice\",\"projects\":[{\"name\":\"kotlinx.serialization\",\"language\":\"Kotlin\"}]}\n{\"name\":\"Bob\"}\n</code></pre>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#nullable-properties-null","title":"Nullable properties\u00a0\u53ef\u4e3a null \u7684\u5c5e\u6027","text":"<p>Nullable properties are natively supported by Kotlin Serialization. Kotlin \u5e8f\u5217\u5316\u5929\u7136\u652f\u6301\u53ef\u4e3a null \u7684\u5c5e\u6027\u3002</p> <pre><code>@Serializable\nclass Project(val name: String, val renamedTo: String? = null)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\")\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>This example does not encode\u00a0<code>null</code>\u00a0in JSON because\u00a0Defaults are not encoded. \u6b64\u793a\u4f8b\u4e0d\u4ee5 JSON \u7f16\u7801\u00a0<code>null</code>\u00a0\uff0c\u56e0\u4e3a\u672a\u5bf9\u9ed8\u8ba4\u503c\u8fdb\u884c\u7f16\u7801\u3002</p> <pre><code>{\"name\":\"kotlinx.serialization\"}\n</code></pre>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#type-safety-is-enforced","title":"Type safety is enforced\u00a0\u5f3a\u5236\u6267\u884c\u7c7b\u578b\u5b89\u5168","text":"<p>Kotlin Serialization strongly enforces the type safety of the Kotlin programming language. In particular, let us try to decode a\u00a0<code>null</code>\u00a0value from a JSON object into a non-nullable Kotlin property\u00a0<code>language</code>. Kotlin \u5e8f\u5217\u5316\u72e0\u72e0\u7684\u52a0\u5f3a\u4e86 Kotlin \u7f16\u7a0b\u8bed\u8a00\u7684\u7c7b\u578b\u5b89\u5168\u6027\u3002\u7279\u522b\u662f\uff0c\u8ba9\u6211\u4eec\u5c1d\u8bd5\u5c06 JSON \u5bf9\u8c61\u4e2d\u7684\u00a0<code>null</code>\u00a0\u503c\u89e3\u7801\u4e3a\u4e0d\u53ef\u4e3a null \u7684 Kotlin \u5c5e\u6027\u00a0<code>language</code>\u00a0\u3002</p> <pre><code>@Serializable\ndata class Project(val name: String, val language: String = \"Kotlin\")\n\nfun main() {\n    val data = Json.decodeFromString&lt;Project&gt;(\"\"\"\n        {\"name\":\"kotlinx.serialization\",\"language\":null}\n    \"\"\")\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Even though the\u00a0<code>language</code>\u00a0property has a default value, it is still an error to attempt to assign the\u00a0<code>null</code>\u00a0value to it. \u5373\u4f7f\u8be5\u00a0<code>language</code>\u00a0\u5c5e\u6027\u5177\u6709\u9ed8\u8ba4\u503c\uff0c\u5c1d\u8bd5\u4e3a\u5176\u8d4b\u00a0<code>null</code>\u00a0\u503c\u4ecd\u7136\u51fa\u9519\u3002</p> <pre><code>Exception in thread \"main\" kotlinx.serialization.json.internal.JsonDecodingException: Unexpected JSON token at offset 52: Expected string literal but 'null' literal was found at path: $.language\nUse 'coerceInputValues = true' in 'Json {}' builder to coerce nulls if property has a default value.\n</code></pre> <p>It might be desired, when decoding 3rd-party JSONs, to coerce\u00a0<code>null</code>\u00a0to a default value. The corresponding feature is explained in the\u00a0Coercing input values\u00a0section. \u5728\u89e3\u7801\u7b2c\u4e09\u65b9 JSON \u65f6\uff0c\u53ef\u80fd\u9700\u8981\u5f3a\u5236\u00a0<code>null</code>\u00a0\u4f7f\u7528\u9ed8\u8ba4\u503c\u3002\u5f3a\u5236\u8f93\u5165\u503c\u90e8\u5206\u4ecb\u7ecd\u4e86\u76f8\u5e94\u7684\u529f\u80fd\u3002</p>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#referenced-objects","title":"Referenced objects\u00a0\u5f15\u7528\u5bf9\u8c61","text":"<p>Serializable classes can reference other classes in their serializable properties. The referenced classes must be also marked as\u00a0<code>@Serializable</code>. \u53ef\u5e8f\u5217\u5316\u7c7b\u53ef\u4ee5\u5728\u5176\u53ef\u5e8f\u5217\u5316\u5c5e\u6027\u4e2d\u5f15\u7528\u5176\u4ed6\u7c7b\u3002\u5f15\u7528\u7684\u7c7b\u4e5f\u5fc5\u987b\u6807\u8bb0\u4e3a\u00a0<code>@Serializable</code>\u00a0\u3002</p> <pre><code>@Serializable\nclass Project(val name: String, val owner: User)\n\n@Serializable\nclass User(val name: String)\n\nfun main() {\n    val owner = User(\"kotlin\")\n    val data = Project(\"kotlinx.serialization\", owner)\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>When encoded to JSON it results in a nested JSON object. \u5f53\u7f16\u7801\u4e3a JSON \u65f6\uff0c\u5b83\u4f1a\u5bfc\u81f4\u5d4c\u5957\u7684 JSON \u5bf9\u8c61\u3002</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"owner\":{\"name\":\"kotlin\"}}\n</code></pre> <p>References to non-serializable classes can be marked as\u00a0Transient properties, or a custom serializer can be provided for them as shown in the\u00a0Serializers\u00a0chapter. \u5bf9\u4e0d\u53ef\u5e8f\u5217\u5316\u7c7b\u7684\u5f15\u7528\u53ef\u4ee5\u6807\u8bb0\u4e3a\u77ac\u6001\u5c5e\u6027\uff0c\u4e5f\u53ef\u4ee5\u4e3a\u5b83\u4eec\u63d0\u4f9b\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u5982\u5e8f\u5217\u5316\u7a0b\u5e8f\u4e00\u7ae0\u4e2d\u6240\u793a\u3002</p>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#no-compression-of-repeated-references","title":"No compression of repeated references","text":"<p>\u4e0d\u538b\u7f29\u91cd\u590d\u5f15\u7528</p> <p>Kotlin Serialization is designed for encoding and decoding of plain data. It does not support reconstruction of arbitrary object graphs with repeated object references. For example, let us try to serialize an object that references the same\u00a0<code>owner</code>\u00a0instance twice. Kotlin \u5e8f\u5217\u5316\u4e13\u4e3a\u5bf9\u7eaf\u6570\u636e\u8fdb\u884c\u7f16\u7801\u548c\u89e3\u7801\u800c\u8bbe\u8ba1\u3002\u5b83\u4e0d\u652f\u6301\u4f7f\u7528\u91cd\u590d\u5bf9\u8c61\u5f15\u7528\u91cd\u5efa\u4efb\u610f\u5bf9\u8c61\u56fe\u3002\u4f8b\u5982\uff0c\u8ba9\u6211\u4eec\u5c1d\u8bd5\u5e8f\u5217\u5316\u4e24\u6b21\u5f15\u7528\u540c\u4e00\u00a0<code>owner</code>\u00a0\u5b9e\u4f8b\u7684\u5bf9\u8c61\u3002</p> <pre><code>@Serializable\nclass Project(val name: String, val owner: User, val maintainer: User)\n\n@Serializable\nclass User(val name: String)\n\nfun main() {\n    val owner = User(\"kotlin\")\n    val data = Project(\"kotlinx.serialization\", owner, owner)\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>We simply get the\u00a0<code>owner</code>\u00a0value encoded twice. <code>owner</code>\u00a0\u7684\u503c\u88ab\u7f16\u7801\u4e86\u4e24\u6b21</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"owner\":{\"name\":\"kotlin\"},\"maintainer\":{\"name\":\"kotlin\"}}\n</code></pre> <p>Attempt to serialize a circular structure will result in stack overflow. You can use the\u00a0Transient properties\u00a0to exclude some references from serialization. \u5c1d\u8bd5\u5e8f\u5217\u5316\u95ed\u73af\u7ed3\u6784\u5c06\u5bfc\u81f4\u5806\u6808\u6ea2\u51fa\u3002\u53ef\u4ee5\u4f7f\u7528 Transient \u5c5e\u6027\u4ece\u5e8f\u5217\u5316\u4e2d\u6392\u9664\u67d0\u4e9b\u5f15\u7528\u3002</p>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#generic-classes","title":"Generic classes\u00a0\u6cdb\u578b\u7c7b","text":"<p>Generic classes in Kotlin provide type-polymorphic behavior, which is enforced by Kotlin Serialization at compile-time. For example, consider a generic serializable class\u00a0<code>Box&lt;T&gt;</code>. Kotlin \u4e2d\u7684\u6cdb\u578b\u7c7b\u63d0\u4f9b\u7c7b\u578b\u591a\u6001\u884c\u4e3a\uff0c\u8be5\u884c\u4e3a\u5728\u7f16\u8bd1\u65f6\u7531 Kotlin \u5e8f\u5217\u5316\u5f3a\u5236\u6267\u884c\u3002\u4f8b\u5982\uff0c\u8003\u8651\u4e00\u4e2a\u6cdb\u578b\u53ef\u5e8f\u5217\u5316\u7c7b\u00a0<code>Box&lt;T&gt;</code>\u00a0\u3002</p> <pre><code>@Serializable\nclass Box&lt;T&gt;(val contents: T)\n</code></pre> <p>The\u00a0<code>Box&lt;T&gt;</code>\u00a0class can be used with builtin types like\u00a0<code>Int</code>, as well as with user-defined types like\u00a0<code>Project</code>. \u8be5\u00a0<code>Box&lt;T&gt;</code>\u00a0\u7c7b\u53ef\u4ee5\u4e0e\u5185\u7f6e\u7c7b\u578b\uff08\u5982 Int\u7c7b\u578b\uff09\u4ee5\u53ca\u7528\u6237\u5b9a\u4e49\u7c7b\u578b\uff08\u5982\u00a0<code>Project</code>\u00a0\uff09\u4e00\u8d77\u4f7f\u7528\u3002</p> <pre><code>@Serializable\nclass Data(\n    val a: Box&lt;Int&gt;,\n    val b: Box&lt;Project&gt;\n)\n\nfun main() {\n    val data = Data(Box(42), Box(Project(\"kotlinx.serialization\", \"Kotlin\")))\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The actual type that we get in JSON depends on the actual compile-time type parameter that was specified for\u00a0<code>Box</code>. \u6211\u4eec\u5728 JSON \u4e2d\u83b7\u5f97\u7684\u5b9e\u9645\u7c7b\u578b\u53d6\u51b3\u4e8e\u4e3a\u00a0<code>Box</code>\u00a0\u6307\u5b9a\u7684\u5b9e\u9645\u7f16\u8bd1\u65f6\u7c7b\u578b\u53c2\u6570\u3002</p> <pre><code>{\"a\":{\"contents\":42},\"b\":{\"contents\":{\"name\":\"kotlinx.serialization\",\"language\":\"Kotlin\"}}}\n</code></pre> <p>If the actual generic type is not serializable a compile-time error will be produced. \u5982\u679c\u5b9e\u9645\u7684\u6cdb\u578b\u7c7b\u578b\u4e0d\u53ef\u5e8f\u5217\u5316\uff0c\u5219\u5c06\u4ea7\u751f\u7f16\u8bd1\u65f6\u9519\u8bef\u3002</p>"},{"location":"%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96-1/#serial-field-names","title":"Serial field names\u00a0\u5e8f\u5217\u5316\u5b57\u6bb5\u540d\u79f0","text":"<p>The names of the properties used in encoded representation, JSON in our examples, are the same as their names in the source code by default. The name that is used for serialization is called a\u00a0serial name, and can be changed using the\u00a0<code>@SerialName</code>\u00a0annotation. For example, we can have a\u00a0<code>language</code>\u00a0property in the source with an abbreviated serial name.  </p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\u4f7f\u7528\u7684\u5c5e\u6027\u540d\u79f0\uff08\u5728\u6211\u4eec\u7684\u793a\u4f8b\u4e2d\u4e3a JSON\uff09\u4e0e\u6e90\u4ee3\u7801\u4e2d\u7684\u540d\u79f0\u76f8\u540c\u3002\u7528\u4e8e\u5e8f\u5217\u5316\u7684\u540d\u79f0\u79f0\u4e3a\u201c\u5e8f\u5217\u540d\u79f0\u201d\uff0c\u53ef\u4ee5\u4f7f\u7528\u00a0<code>@SerialName</code>\u00a0\u6ce8\u89e3\u8fdb\u884c\u66f4\u6539\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u6e90\u4ee3\u7801\u4e2d\u6709\u4e00\u4e2a\u5177\u6709\u7f29\u5199\u5e8f\u5217\u540d\u79f0\u7684\u00a0<code>language</code>\u00a0\u5c5e\u6027\u3002</p> <pre><code>@Serializable\nclass Project(val name: String, @SerialName(\"lang\") val language: String)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\", \"Kotlin\")\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Now we see that an abbreviated name\u00a0<code>lang</code>\u00a0is used in the JSON output. \u73b0\u5728\u6211\u4eec\u770b\u5230 JSON \u8f93\u51fa\u4e2d\u4f7f\u7528\u4e86\u7f29\u5199\u540d\u79f0\u00a0<code>lang</code>\u00a0\u3002</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"lang\":\"Kotlin\"}\n</code></pre> <p>The next chapter covers\u00a0Builtin classes. \u4e0b\u4e00\u7ae0\u5c06\u4ecb\u7ecd\u5185\u7f6e\u7c7b\u3002</p>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/","title":"Polymorphism\u00a0\u591a\u6001\u6027","text":"<p>This is the fourth chapter of the\u00a0Kotlin Serialization Guide. In this chapter we\u2019ll see how Kotlin Serialization deals with polymorphic class hierarchies. \u8fd9\u662f\u300aKotlin \u5e8f\u5217\u5316\u6307\u5357\u300b\u7684\u7b2c\u56db\u7ae0\u3002\u5728\u672c\u7ae0\u4e2d\uff0c\u6211\u4eec\u5c06\u4e86\u89e3 Kotlin \u5e8f\u5217\u5316\u5982\u4f55\u5904\u7406\u591a\u6001\u7c7b\u5c42\u6b21\u7ed3\u6784\u3002</p> <p>Table of contents\u00a0\u76ee\u5f55</p> <ul> <li>Closed polymorphism\u00a0\u95ed\u5408\u591a\u6001\u6027<ul> <li>Static types\u00a0\u9759\u6001\u7c7b\u578b</li> <li>Designing serializable hierarchy     \u8bbe\u8ba1\u53ef\u5e8f\u5217\u5316\u7684\u5c42\u6b21\u7ed3\u6784</li> <li>Sealed classes\u00a0\u5bc6\u5c01\u7c7b</li> <li>Custom subclass serial name     \u81ea\u5b9a\u4e49\u5b50\u7c7b\u5e8f\u5217\u5316\u540d\u79f0</li> <li>Concrete properties in a base class     \u57fa\u7c7b\u4e2d\u7684\u5177\u4f53\u5c5e\u6027</li> <li>Objects\u00a0\u5bf9\u8c61</li> </ul> </li> <li>Open polymorphism\u00a0\u5f00\u653e\u591a\u6001\u6027<ul> <li>Registered subclasses\u00a0\u5df2\u6ce8\u518c\u7684\u5b50\u7c7b</li> <li>Serializing interfaces\u00a0\u5e8f\u5217\u5316\u63a5\u53e3</li> <li>Property of an interface type     \u63a5\u53e3\u7c7b\u578b\u7684\u5c5e\u6027</li> <li>Static parent type lookup for polymorphism     \u591a\u6001\u6027\u7684\u9759\u6001\u7236\u7c7b\u578b\u67e5\u627e</li> <li>Explicitly marking polymorphic class properties     \u663e\u5f0f\u6807\u8bb0\u591a\u6001\u7c7b\u5c5e\u6027</li> <li>Registering multiple superclasses     \u6ce8\u518c\u591a\u4e2a\u8d85\u7c7b</li> <li>Polymorphism and generic classes     \u591a\u6001\u6027\u548c\u6cdb\u578b\u7c7b</li> <li>Merging library serializers modules     \u5408\u5e76\u5e93\u5e8f\u5217\u5316\u7a0b\u5e8f\u6a21\u5757</li> <li>Default polymorphic type handler for deserialization     \u7528\u4e8e\u53cd\u5e8f\u5217\u5316\u7684\u9ed8\u8ba4\u591a\u6001\u7c7b\u578b\u5904\u7406\u7a0b\u5e8f</li> <li>Default polymorphic type handler for serialization     \u7528\u4e8e\u5e8f\u5217\u5316\u7684\u9ed8\u8ba4\u591a\u6001\u7c7b\u578b\u5904\u7406\u7a0b\u5e8f</li> </ul> </li> </ul>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#closed-polymorphism","title":"Closed polymorphism\u00a0\u95ed\u5408\u591a\u6001\u6027","text":"<p>Let us start with basic introduction to polymorphism. \u8ba9\u6211\u4eec\u4ece\u591a\u6001\u6027\u7684\u57fa\u672c\u4ecb\u7ecd\u5f00\u59cb\u3002</p>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#static-types","title":"Static types\u00a0\u9759\u6001\u7c7b\u578b","text":"<p>Kotlin Serialization is fully static with respect to types by default. The structure of encoded objects is determined by\u00a0compile-time\u00a0types of objects. Let\u2019s examine this aspect in more detail and learn how to serialize polymorphic data structures, where the type of data is determined at runtime.  </p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cKotlin \u5e8f\u5217\u5316\u5bf9\u4e8e\u7c7b\u578b\u662f\u5b8c\u5168\u9759\u6001\u7684\u3002\u7f16\u7801\u5bf9\u8c61\u7684\u7ed3\u6784\u7531\u5bf9\u8c61\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\u786e\u5b9a\u3002\u8ba9\u6211\u4eec\u66f4\u8be6\u7ec6\u5730\u7814\u7a76\u8fd9\u4e00\u65b9\u9762\uff0c\u5e76\u5b66\u4e60\u5982\u4f55\u5e8f\u5217\u5316\u591a\u6001\u6570\u636e\u7ed3\u6784\uff0c\u5176\u4e2d\u6570\u636e\u7c7b\u578b\u662f\u5728\u8fd0\u884c\u65f6\u786e\u5b9a\u7684\u3002</p> <p>To show the static nature of Kotlin Serialization let us make the following setup. An\u00a0<code>open class Project</code>\u00a0has just the\u00a0<code>name</code>\u00a0property, while its derived\u00a0<code>class OwnedProject</code>\u00a0adds an\u00a0<code>owner</code>\u00a0property. In the below example, we serialize\u00a0<code>data</code>\u00a0variable with a static type of\u00a0<code>Project</code>\u00a0that is initialized with an instance of\u00a0<code>OwnedProject</code>\u00a0at runtime.  </p> <p>\u4e3a\u4e86\u663e\u793a Kotlin \u5e8f\u5217\u5316\u7684\u9759\u6001\u7279\u6027\uff0c\u8ba9\u6211\u4eec\u8fdb\u884c\u4ee5\u4e0b\u8bbe\u7f6e\u3002\u4e00\u4e2a\u00a0<code>open class Project</code>\u00a0\u7c7b\uff0c\u53ea\u5177\u6709\u00a0<code>name</code>\u00a0\u5c5e\u6027\uff0c\u800c\u5b50\u7c7b <code>OwnedProject</code>\u00a0\u6dfb\u52a0\u4e86\u5c5e\u6027\u00a0<code>owner</code>\u00a0\u3002\u5728\u4e0b\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u5c06 <code>data</code> \u53d8\u91cf\u5e8f\u5217\u5316\u4e3a\u9759\u6001\u7c7b\u578b\u7684 <code>Project</code>\uff0c\u8be5\u7c7b\u578b\u5728\u8fd0\u884c\u65f6\u88ab\u521d\u59cb\u5316\u4e3a <code>OwnedProject</code>\u7684\u5b9e\u4f8b\u3002 </p> <pre><code>@Serializable\nopen class Project(val name: String)\n\nclass OwnedProject(name: String, val owner: String) : Project(name)\n\nfun main() {\n    val data: Project = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(Json.encodeToString(data))\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Despite the runtime type of\u00a0<code>OwnedProject</code>, only the\u00a0<code>Project</code>\u00a0class properties are getting serialized. \u5c3d\u7ba1\u8fd0\u884c\u65f6\u7c7b\u578b\u4e3a\u00a0<code>OwnedProject</code>\u00a0\uff0c\u4f46\u53ea\u6709\u00a0<code>Project</code>\u00a0\u7c7b\u5c5e\u6027\u88ab\u5e8f\u5217\u5316\u3002</p> <pre><code>{\"name\":\"kotlinx.coroutines\"}\n</code></pre> <p>Let\u2019s change the compile-time type of\u00a0<code>data</code>\u00a0to\u00a0<code>OwnedProject</code>. \u8ba9\u6211\u4eec\u5c06\u7f16\u8bd1\u00a0<code>data</code>\u00a0\u65f6\u7c7b\u578b\u66f4\u6539\u4e3a\u00a0<code>OwnedProject</code>\u00a0\u3002</p> <pre><code>@Serializable\nopen class Project(val name: String)\n\nclass OwnedProject(name: String, val owner: String) : Project(name)\n\nfun main() {\n    val data = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(Json.encodeToString(data))\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>We get an error, because the\u00a0<code>OwnedProject</code>\u00a0class is not serializable. \u6211\u4eec\u6536\u5230\u4e00\u4e2a\u9519\u8bef\uff0c\u56e0\u4e3a\u8be5\u00a0<code>OwnedProject</code>\u00a0\u7c7b\u4e0d\u53ef\u5e8f\u5217\u5316\u3002</p> <pre><code>Exception in thread \"main\" kotlinx.serialization.SerializationException: Serializer for class 'OwnedProject' is not found.\nPlease ensure that class is marked as '@Serializable' and that the serialization compiler plugin is applied.\n</code></pre>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#designing-serializable-hierarchy","title":"Designing serializable hierarchy  \u8bbe\u8ba1\u53ef\u5e8f\u5217\u5316\u7684\u5c42\u6b21\u7ed3\u6784","text":"<p>We cannot simply mark\u00a0<code>OwnedProject</code>\u00a0from the previous example as\u00a0<code>@Serializable</code>. It does not compile, running into the\u00a0constructor properties requirement. To make hierarchy of classes serializable, the properties in the parent class have to be marked\u00a0<code>abstract</code>, making the\u00a0<code>Project</code>\u00a0class\u00a0<code>abstract</code>, too.  </p> <p>\u6211\u4eec\u4e0d\u80fd\u7b80\u5355\u5730\u5c06\u4e0a\u4e00\u793a\u4f8b\u4e2d\u7684 <code>OwnedProject</code> \u6807\u8bb0\u4e3a <code>@Serializable</code>\u3002\u5b83\u65e0\u6cd5\u7f16\u8bd1\uff0c\u4f1a\u9047\u5230 [\u6784\u9020\u51fd\u6570\u5c5e\u6027\u8981\u6c42]\u3002\u8981\u4f7f\u7c7b\u7684\u5c42\u6b21\u7ed3\u6784\u53ef\u5e8f\u5217\u5316\uff0c\u7236\u7c7b\u4e2d\u7684\u5c5e\u6027\u5fc5\u987b\u6807\u8bb0\u4e3a<code>abstract</code>\uff0c\u4ece\u800c\u4f7f<code>Project</code>\u7c7b\u4e5f\u6210\u4e3a\u62bd\u8c61\u7c7b\u3002 </p> <pre><code>@Serializable\nabstract class Project {\n    abstract val name: String\n}\n\nclass OwnedProject(override val name: String, val owner: String) : Project()\n\nfun main() {\n    val data: Project = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(Json.encodeToString(data))\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>This is close to the best design for a serializable hierarchy of classes, but running it produces the following error: \u8fd9\u63a5\u8fd1\u4e8e\u53ef\u5e8f\u5217\u5316\u7684\u7c7b\u5c42\u6b21\u7ed3\u6784\u7684\u6700\u4f73\u8bbe\u8ba1\uff0c\u4f46\u8fd0\u884c\u5b83\u4f1a\u4ea7\u751f\u4ee5\u4e0b\u9519\u8bef\uff1a</p> <pre><code>Exception in thread \"main\" kotlinx.serialization.SerializationException: Serializer for subclass 'OwnedProject' is not found in the polymorphic scope of 'Project'.\nCheck if class with serial name 'OwnedProject' exists and serializer is registered in a corresponding SerializersModule.\nTo be registered automatically, class 'OwnedProject' has to be '@Serializable', and the base class 'Project' has to be sealed and '@Serializable'.\n</code></pre>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#sealed-classes","title":"Sealed classes\u00a0\u5bc6\u5c01\u7c7b","text":"<p>The most straightforward way to use serialization with a polymorphic hierarchy is to mark the base class\u00a0<code>sealed</code>.\u00a0All\u00a0subclasses of a sealed class must be explicitly marked as\u00a0<code>@Serializable</code>.  </p> <p>\u5c06\u5e8f\u5217\u5316\u4e0e\u591a\u6001\u5c42\u6b21\u7ed3\u6784\u4e00\u8d77\u4f7f\u7528\u7684\u6700\u76f4\u63a5\u65b9\u6cd5\u662f\u6807\u8bb0\u57fa\u7c7b\u4e3a\u5bc6\u5c01\u7c7b\u00a0<code>sealed</code>\u00a0\u3002\u5bc6\u5c01\u7c7b\u7684\u6240\u6709\u5b50\u7c7b\u90fd\u5fc5\u987b\u663e\u5f0f\u6807\u8bb0\u4e3a\u00a0<code>@Serializable</code>\u00a0\u3002</p> <pre><code>@Serializable\nsealed class Project {\n    abstract val name: String\n}\n\n@Serializable\nclass OwnedProject(override val name: String, val owner: String) : Project()\n\nfun main() {\n    val data: Project = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(Json.encodeToString(data)) // Serializing data of compile-time type Project\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Now we can see a default way to represent polymorphism in JSON. A\u00a0<code>type</code>\u00a0key is added to the resulting JSON object as a\u00a0discriminator.  </p> <p>\u73b0\u5728\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u5728JSON\u4e2d\u8868\u793a\u591a\u6001\u6027\u7684\u9ed8\u8ba4\u65b9\u6cd5\u3002\u5728\u751f\u6210\u7684 JSON \u5bf9\u8c61\u4e2d\u6dfb\u52a0\u4e86\u4e00\u4e2atype\u7528\u4e8e\u533a\u5206\u7c7b\u578b\u3002</p> <pre><code>{\"type\":\"example.examplePoly04.OwnedProject\",\"name\":\"kotlinx.coroutines\",\"owner\":\"kotlin\"}\n</code></pre> <p>Pay attention to the small, but very important detail in the above example that is related to\u00a0Static types: the\u00a0<code>val data</code>\u00a0property has a compile-time type of\u00a0<code>Project</code>, even though its run-time type is\u00a0<code>OwnedProject</code>. When serializing polymorphic class hierarchies you must ensure that the compile-time type of the serialized object is a polymorphic one, not a concrete one.  </p> <p>\u8bf7\u6ce8\u610f\u4e0a\u4f8b\u4e2d\u4e0e [Static types] \u6709\u5173\u7684\u4e00\u4e2a\u5f88\u5c0f\u4f46\u975e\u5e38\u91cd\u8981\u7684\u7ec6\u8282\uff1a<code>val data</code> \u5c5e\u6027\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\u662f<code>Project</code>\uff0c\u5c3d\u7ba1\u5176\u8fd0\u884c\u65f6\u7c7b\u578b\u662f<code>OwnedProject</code>\u3002\u5728\u5e8f\u5217\u5316\u591a\u6001\u7c7b\u5c42\u6b21\u7ed3\u6784\u65f6\uff0c\u5fc5\u987b\u786e\u4fdd\u5e8f\u5217\u5316\u5bf9\u8c61\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\u662f\u591a\u6001\u7c7b\u578b\uff0c\u800c\u4e0d\u662f\u5177\u4f53\u7c7b\u578b\u3002 </p> <p>Let us see what happens if the example is slightly changed, so that the compile-time of the object that is being serialized is\u00a0<code>OwnedProject</code>\u00a0(the same as its run-time type). \u8ba9\u6211\u4eec\u770b\u770b\u5982\u679c\u5bf9\u793a\u4f8b\u7a0d\u4f5c\u4fee\u6539\uff0c\u4f7f\u88ab\u5e8f\u5217\u5316\u5bf9\u8c61\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\u4e3a <code>OwnedProject</code>\uff08\u4e0e\u5176\u8fd0\u884c\u65f6\u7c7b\u578b\u76f8\u540c\uff09\uff0c\u4f1a\u53d1\u751f\u4ec0\u4e48\u60c5\u51b5\u3002 </p> <pre><code>@Serializable\nsealed class Project {\n    abstract val name: String\n}\n\n@Serializable\nclass OwnedProject(override val name: String, val owner: String) : Project()\n\nfun main() {\n    val data = OwnedProject(\"kotlinx.coroutines\", \"kotlin\") // data: OwnedProject here\n    println(Json.encodeToString(data)) // Serializing data of compile-time type OwnedProject\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The type of\u00a0<code>OwnedProject</code>\u00a0is concrete and is not polymorphic, thus the\u00a0<code>type</code>\u00a0discriminator property is not emitted into the resulting JSON. \u7684\u00a0<code>OwnedProject</code>\u00a0\u7c7b\u578b\u662f\u5177\u4f53\u7684\uff0c\u4e0d\u662f\u591a\u6001\u7684\uff0c\u56e0\u6b64\u00a0<code>type</code>\u5c5e\u6027\u4e0d\u4f1a\u6dfb\u52a0\u5230\u751f\u6210\u7684 JSON \u4e2d\u3002</p> <pre><code>{\"name\":\"kotlinx.coroutines\",\"owner\":\"kotlin\"}\n</code></pre> <p>In general, Kotlin Serialization is designed to work correctly only when the compile-time type used during serialization is the same one as the compile-time type used during deserialization. You can always specify the type explicitly when calling serialization functions. The previous example can be corrected to use\u00a0<code>Project</code>\u00a0type for serialization by calling\u00a0<code>Json.encodeToString&lt;Project&gt;(data)</code>. \u4e00\u822c\u6765\u8bf4\uff0c\u53ea\u6709\u5f53\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\u4f7f\u7528\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\u4e0e\u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\u4f7f\u7528\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\u76f8\u540c\u65f6\uff0cKotlin \u5e8f\u5217\u5316\u624d\u80fd\u6b63\u5e38\u5de5\u4f5c\u3002\u60a8\u53ef\u4ee5\u5728\u8c03\u7528\u5e8f\u5217\u5316\u51fd\u6570\u65f6\u660e\u786e\u6307\u5b9a\u7c7b\u578b\u3002\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 <code>Json.encodeToString&lt;Project&gt;(data)</code>\uff0c\u5c06\u4e0a\u4f8b\u66f4\u6b63\u4e3a\u4f7f\u7528 <code>Project</code> \u7c7b\u578b\u8fdb\u884c\u5e8f\u5217\u5316\u3002 </p>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#custom-subclass-serial-name","title":"Custom subclass serial name  \u81ea\u5b9a\u4e49\u5b50\u7c7b\u5e8f\u5217\u5316\u540d\u79f0","text":"<p>A value of the\u00a0<code>type</code>\u00a0key is a fully qualified class name by default. We can put\u00a0SerialName\u00a0annotation onto the corresponding class to change it.  </p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u00a0<code>type</code>\u00a0\u952e\u7684\u503c\u662f\u5b8c\u5168\u9650\u5b9a\u7684\u7c7b\u540d\u3002\u6211\u4eec\u53ef\u4ee5\u5c06 SerialName \u6ce8\u89e3\u653e\u5728\u76f8\u5e94\u7684\u7c7b\u4e0a\u4ee5\u66f4\u6539\u5b83\u3002</p> <pre><code>@Serializable\nsealed class Project {\n    abstract val name: String\n}\n\n@Serializable         \n@SerialName(\"owned\")\nclass OwnedProject(override val name: String, val owner: String) : Project()\n\nfun main() {\n    val data: Project = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(Json.encodeToString(data))\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>This way we can have a stable\u00a0serial name\u00a0that is not affected by the class\u2019s name in the source code. \u8fd9\u6837\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u62e5\u6709\u4e00\u4e2a\u7a33\u5b9a\u7684\u5e8f\u5217\u5316\u540d\u79f0\uff0c\u4e0d\u53d7\u6e90\u4ee3\u7801\u4e2d\u7c7b\u540d\u7684\u5f71\u54cd\u3002</p> <pre><code>{\"type\":\"owned\",\"name\":\"kotlinx.coroutines\",\"owner\":\"kotlin\"}\n</code></pre> <p>In addition to that, JSON can be configured to use a different key name for the class discriminator. You can find an example in the\u00a0Class discriminator for polymorphism\u00a0section. \u9664\u6b64\u4e4b\u5916\uff0c\u8fd8\u53ef\u4ee5\u5c06 JSON \u914d\u7f6e\u4e3a\u5bf9\u7c7b\u9274\u522b\u5668\u4f7f\u7528\u4e0d\u540c\u7684\u952e\u540d\u3002\u60a8\u53ef\u4ee5\u5728\u591a\u6001\u6027\u7684\u7c7b\u9274\u522b\u5668\u90e8\u5206\u627e\u5230\u4e00\u4e2a\u793a\u4f8b\u3002</p>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#concrete-properties-in-a-base-class","title":"Concrete properties in a base class  \u57fa\u7c7b\u4e2d\u7684\u5177\u4f53\u5c5e\u6027","text":"<p>A base class in a sealed hierarchy can have properties with backing fields. \u5bc6\u5c01\u5c42\u6b21\u7ed3\u6784\u4e2d\u7684\u57fa\u7c7b\u53ef\u4ee5\u6709\u5e26\u652f\u6301\u5b57\u6bb5\u7684\u5c5e\u6027\uff08\u6709getter\u548csetter\uff09\u3002 </p> <pre><code>@Serializable\nsealed class Project {\n    abstract val name: String   \n    var status = \"open\"\n}\n\n@Serializable   \n@SerialName(\"owned\")\nclass OwnedProject(override val name: String, val owner: String) : Project()\n\nfun main() {\n    val json = Json { encodeDefaults = true } // \"status\" will be skipped otherwise\n    val data: Project = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(json.encodeToString(data))\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The properties of the superclass are serialized before the properties of the subclass. \u8d85\u7c7b\u7684\u5c5e\u6027\u5728\u5b50\u7c7b\u7684\u5c5e\u6027\u4e4b\u524d\u5e8f\u5217\u5316\u3002</p> <pre><code>{\"type\":\"owned\",\"status\":\"open\",\"name\":\"kotlinx.coroutines\",\"owner\":\"kotlin\"}\n</code></pre>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#objects-object","title":"Objects\u00a0 object\u7c7b","text":"<p>Sealed hierarchies can have objects as their subclasses and they also need to be marked as\u00a0<code>@Serializable</code>. Let\u2019s take a different example with a hierarchy of\u00a0<code>Response</code>\u00a0classes. \u5bc6\u5c01\u5c42\u6b21\u7ed3\u6784\u53ef\u4ee5\u5c06object\u7c7b\u4f5c\u4e3a\u5176\u5b50\u7c7b\uff0c\u5e76\u4e14\u8fd8\u9700\u8981\u5c06\u5b83\u4eec\u6807\u8bb0\u4e3a\u00a0<code>@Serializable</code>\u00a0\u3002\u8ba9\u6211\u4eec\u7528\u4e00\u4e2a\u4e0d\u540c\u7684\u4f8b\u5b50\u6765\u8bf4\u660e <code>Response</code> \u7c7b\u7684\u5c42\u6b21\u7ed3\u6784\u3002 </p> <pre><code>@Serializable\nsealed class Response\n\n@Serializable\nobject EmptyResponse : Response()\n\n@Serializable   \nclass TextResponse(val text: String) : Response()   \n</code></pre> <p>Let us serialize a list of different responses. \u8ba9\u6211\u4eec\u5e8f\u5217\u5316\u4e00\u4e2a\u4e0d\u540cresponse\u7c7b\u7684list\u3002</p> <pre><code>fun main() {\n    val list = listOf(EmptyResponse, TextResponse(\"OK\"))\n    println(Json.encodeToString(list))\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>An object serializes as an empty class, also using its fully-qualified class name as type by default: \u5bf9\u8c61\u5e8f\u5217\u5316\u4e3a\u7a7a\u7c7b\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u4e5f\u4f7f\u7528\u5176\u5b8c\u5168\u9650\u5b9a\u7684\u7c7b\u540d\u4f5c\u4e3a\u7c7b\u578b\uff1a</p> <pre><code>[{\"type\":\"example.examplePoly08.EmptyResponse\"},{\"type\":\"example.examplePoly08.TextResponse\",\"text\":\"OK\"}]\n</code></pre> <p>Even if object has properties, they are not serialized. \u5373\u4f7f\u5bf9\u8c61\u5177\u6709\u5c5e\u6027\uff0c\u5b83\u4eec\u4e5f\u4e0d\u4f1a\u5e8f\u5217\u5316\u3002</p>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#open-polymorphism","title":"Open polymorphism\u00a0\u5f00\u653e\u591a\u6001\u6027","text":"<p>Serialization can work with arbitrary\u00a0<code>open</code>\u00a0classes or\u00a0<code>abstract</code>\u00a0classes. However, since this kind of polymorphism is open, there is a possibility that subclasses are defined anywhere in the source code, even in other modules, the list of subclasses that are serialized cannot be determined at compile-time and must be explicitly registered at runtime. \u5e8f\u5217\u5316\u53ef\u4ee5\u5904\u7406\u4efb\u610f\u7684 \u201c\u5f00\u653e \u201c\u7c7b\u6216 \u201c\u62bd\u8c61 \u201c\u7c7b\u3002\u4f46\u662f\uff0c\u7531\u4e8e\u8fd9\u79cd\u591a\u6001\u6027\u662f\u5f00\u653e\u7684\uff0c\u56e0\u6b64\u6709\u53ef\u80fd\u5728\u6e90\u4ee3\u7801\u7684\u4efb\u4f55\u5730\u65b9\uff0c\u751a\u81f3\u5728\u5176\u4ed6\u6a21\u5757\u4e2d\u5b9a\u4e49\u4e86\u5b50\u7c7b\uff0c\u56e0\u6b64\u5e8f\u5217\u5316\u7684\u5b50\u7c7b\u5217\u8868\u65e0\u6cd5\u5728\u7f16\u8bd1\u65f6\u786e\u5b9a\uff0c\u5fc5\u987b\u5728\u8fd0\u884c\u65f6\u663e\u5f0f\u6ce8\u518c\u3002 </p>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#registered-subclasses","title":"Registered subclasses\u00a0\u5df2\u6ce8\u518c\u7684\u5b50\u7c7b","text":"<p>Let us start with the code from the\u00a0Designing serializable hierarchy\u00a0section. To make it work with serialization without making it\u00a0<code>sealed</code>, we have to define a\u00a0SerializersModule\u00a0using the\u00a0SerializersModule {}\u00a0builder function. In the module the base class is specified in the\u00a0polymorphic\u00a0builder and each subclass is registered with the\u00a0subclass\u00a0function. Now, a custom JSON configuration can be instantiated with this module and used for serialization.  </p> <p>\u8ba9\u6211\u4eec\u4ece\u8bbe\u8ba1\u53ef\u5e8f\u5217\u5316\u5c42\u6b21\u7ed3\u6784\u90e8\u5206\u7684\u4ee3\u7801\u5f00\u59cb\u3002\u4e3a\u4e86\u5728\u4e0d\u5bc6\u5c01\u7684\u60c5\u51b5\u4e0b\u5b9e\u73b0\u5e8f\u5217\u5316\uff0c\u6211\u4eec\u5fc5\u987b\u4f7f\u7528\u5e8f\u5217\u5316\u6a21\u5757\uff08SerializersModule {} builder\uff09\u51fd\u6570\u5b9a\u4e49\u4e00\u4e2a\u5e8f\u5217\u5316\u6a21\u5757\uff08SerializersModule\uff09\u3002\u5728\u8be5\u6a21\u5757\u4e2d\uff0c\u57fa\u7c7b\u662f\u5728\u591a\u6001\u751f\u6210\u5668\u4e2d\u6307\u5b9a\u7684\uff0c\u6bcf\u4e2a\u5b50\u7c7b\u90fd\u662f\u901a\u8fc7\u5b50\u7c7b\u51fd\u6570\u6ce8\u518c\u7684\u3002\u73b0\u5728\uff0c\u81ea\u5b9a\u4e49 JSON \u914d\u7f6e\u53ef\u4ee5\u901a\u8fc7\u8be5\u6a21\u5757\u5b9e\u4f8b\u5316\u5e76\u7528\u4e8e\u5e8f\u5217\u5316\u3002</p> <p>Details on custom JSON configurations can be found in the\u00a0JSON configuration\u00a0section. \u6709\u5173\u81ea\u5b9a\u4e49 JSON \u914d\u7f6e\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 JSON \u914d\u7f6e\u90e8\u5206\u3002</p> <pre><code>val module = SerializersModule {\n    polymorphic(Project::class) {\n        subclass(OwnedProject::class)\n    }\n}\n\nval format = Json { serializersModule = module }\n\n@Serializable\nabstract class Project {\n    abstract val name: String\n}\n\n@Serializable\n@SerialName(\"owned\")\nclass OwnedProject(override val name: String, val owner: String) : Project()\n\nfun main() {\n    val data: Project = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(format.encodeToString(data))\n}    \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>This additional configuration makes our code work just as it worked with a sealed class in the\u00a0Sealed classes\u00a0section, but here subclasses can be spread arbitrarily throughout the code. \u8fd9\u79cd\u989d\u5916\u7684\u914d\u7f6e\u4f7f\u6211\u4eec\u7684\u4ee3\u7801\u5c31\u50cf\u5728\u201c\u5bc6\u5c01\u7c7b\u201d\u90e8\u5206\u4e2d\u4f7f\u7528\u5bc6\u5c01\u7c7b\u4e00\u6837\u5de5\u4f5c\uff0c\u4f46\u5728\u8fd9\u91cc\uff0c\u5b50\u7c7b\u53ef\u4ee5\u4efb\u610f\u5206\u5e03\u5728\u4efb\u610f\u4f4d\u7f6e\u3002</p> <pre><code>{\"type\":\"owned\",\"name\":\"kotlinx.coroutines\",\"owner\":\"kotlin\"}\n</code></pre> <p>Please note that this example works only on JVM because of\u00a0<code>serializer</code>\u00a0function restrictions. For JS and Native, explicit serializer should be used:\u00a0<code>format.encodeToString(PolymorphicSerializer(Project::class), data)</code>\u00a0You can keep track of this issue\u00a0here. \u8bf7\u6ce8\u610f\uff0c\u7531\u4e8e\u00a0<code>serializer</code>\u00a0\u529f\u80fd\u9650\u5236\uff0c\u6b64\u793a\u4f8b\u4ec5\u9002\u7528\u4e8e JVM\u3002\u5bf9\u4e8e JS \u548c Native\uff0c\u5e94\u4f7f\u7528\u663e\u5f0f\u5e8f\u5217\u5316\u7a0b\u5e8f\uff1a\u00a0<code>format.encodeToString(PolymorphicSerializer(Project::class), data)</code>\u00a0\u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u8ddf\u8e2a\u6b64\u95ee\u9898\u3002</p>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#serializing-interfaces","title":"Serializing interfaces\u00a0\u5e8f\u5217\u5316\u63a5\u53e3","text":"<p>We can update the previous example and turn\u00a0<code>Project</code>\u00a0superclass into an interface. However, we cannot mark an interface itself as\u00a0<code>@Serializable</code>. No problem. Interfaces cannot have instances by themselves. Interfaces can only be represented by instances of their derived classes. Interfaces are used in the Kotlin language to enable polymorphism, so all interfaces are considered to be implicitly serializable with the\u00a0PolymorphicSerializer\u00a0strategy. We just need to mark their implementing classes as\u00a0<code>@Serializable</code>\u00a0and register them.  </p> <p>\u6211\u4eec\u53ef\u4ee5\u66f4\u65b0\u524d\u9762\u7684\u793a\u4f8b\uff0c\u5c06 <code>Project</code> \u8d85\u7c7b\u53d8\u6210\u4e00\u4e2a\u63a5\u53e3\u3002\u4f46\u662f\uff0c\u6211\u4eec\u4e0d\u80fd\u5c06\u63a5\u53e3\u672c\u8eab\u6807\u8bb0\u4e3a <code>@Serializable</code>\u3002\u6ca1\u95ee\u9898\u3002\u63a5\u53e3\u672c\u8eab\u4e0d\u80fd\u62e5\u6709\u5b9e\u4f8b\u3002\u63a5\u53e3\u53ea\u80fd\u7531\u5176\u6d3e\u751f\u7c7b\u7684\u5b9e\u4f8b\u6765\u8868\u793a\u3002Kotlin \u8bed\u8a00\u4e2d\u4f7f\u7528\u63a5\u53e3\u6765\u5b9e\u73b0\u591a\u6001\u6027\uff0c\u56e0\u6b64\u4f7f\u7528 [PolymorphicSerializer] \u7b56\u7565\uff0c\u6240\u6709\u63a5\u53e3\u90fd\u88ab\u8ba4\u4e3a\u662f\u9690\u5f0f\u53ef\u5e8f\u5217\u5316\u7684\u3002\u6211\u4eec\u53ea\u9700\u5c06\u5b83\u4eec\u7684\u5b9e\u73b0\u7c7b\u6807\u8bb0\u4e3a <code>@Serializable</code> \u5e76\u6ce8\u518c\u5373\u53ef\u3002 </p> <pre><code>interface Project {\n    val name: String\n}\n\n@Serializable\n@SerialName(\"owned\")\nclass OwnedProject(override val name: String, val owner: String) : Project\n</code></pre> <p>Now if we declare\u00a0<code>data</code>\u00a0with the type of\u00a0<code>Project</code>\u00a0we can simply call\u00a0<code>format.encodeToString</code>\u00a0as before. \u73b0\u5728\uff0c\u5982\u679c\u6211\u4eec\u4ee5 <code>Project</code> \u7c7b\u578b\u58f0\u660e <code>data</code> \uff0c\u5c31\u53ef\u4ee5\u50cf\u4ee5\u524d\u4e00\u6837\u7b80\u5355\u5730\u8c03\u7528 <code>format.encodeToString</code>\u3002 </p> <pre><code>fun main() {\n    val data: Project = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(format.encodeToString(data))\n}    \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>{\"type\":\"owned\",\"name\":\"kotlinx.coroutines\",\"owner\":\"kotlin\"}\n</code></pre> <p>Note: On Kotlin/Native, you should use\u00a0<code>format.encodeToString(PolymorphicSerializer(Project::class), data))</code>\u00a0instead due to limited reflection capabilities. \u6ce8\u610f\uff1a\u5728 Kotlin/Native \u4e0a\uff0c\u7531\u4e8e\u53cd\u5c04\u529f\u80fd\u6709\u9650\uff0c\u60a8\u5e94\u8be5\u6539\u7528\u00a0<code>format.encodeToString(PolymorphicSerializer(Project::class), data))</code>\u00a0\u3002</p>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#property-of-an-interface-type","title":"Property of an interface type  \u63a5\u53e3\u7c7b\u578b\u7684\u5c5e\u6027","text":"<p>Continuing the previous example, let us see what happens if we use\u00a0<code>Project</code>\u00a0interface as a property in some other serializable class. Interfaces are implicitly polymorphic, so we can just declare a property of an interface type. \u7ee7\u7eed\u524d\u9762\u7684\u4f8b\u5b50\uff0c\u8ba9\u6211\u4eec\u770b\u770b\u5982\u679c\u628a <code>Project</code> \u63a5\u53e3\u4f5c\u4e3a\u5176\u4ed6\u53ef\u5e8f\u5217\u5316\u7c7b\u7684\u5c5e\u6027\u4f1a\u53d1\u751f\u4ec0\u4e48\u3002\u63a5\u53e3\u662f\u9690\u5f0f\u591a\u6001\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u58f0\u660e\u4e00\u4e2a\u63a5\u53e3\u7c7b\u578b\u7684\u5c5e\u6027\u3002 </p> <pre><code>@Serializable\nclass Data(val project: Project) // Project is an interface\n\nfun main() {\n    val data = Data(OwnedProject(\"kotlinx.coroutines\", \"kotlin\"))\n    println(format.encodeToString(data))\n}        \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>As long as we\u2019ve registered the actual subtype of the interface that is being serialized in the\u00a0SerializersModule\u00a0of our\u00a0<code>format</code>, we get it working at runtime.  </p> <p>\u53ea\u8981\u6211\u4eec\u5728\u00a0<code>format</code>\u00a0SerializersModule \u4e2d\u6ce8\u518c\u4e86\u6b63\u5728\u5e8f\u5217\u5316\u7684\u63a5\u53e3\u7684\u5b9e\u9645\u5b50\u7c7b\u578b\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u8ba9\u5b83\u5728\u8fd0\u884c\u65f6\u5de5\u4f5c\u3002</p> <pre><code>{\"project\":{\"type\":\"owned\",\"name\":\"kotlinx.coroutines\",\"owner\":\"kotlin\"}}\n</code></pre>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#static-parent-type-lookup-for-polymorphism","title":"Static parent type lookup for polymorphism  \u591a\u6001\u6027\u7684\u9759\u6001\u7236\u7c7b\u578b\u67e5\u627e","text":"<p>During serialization of a polymorphic class the root type of the polymorphic hierarchy (<code>Project</code>\u00a0in our example) is determined statically. Let us take the example with the serializable\u00a0<code>abstract class Project</code>, but change the\u00a0<code>main</code>\u00a0function to declare\u00a0<code>data</code>\u00a0as having a type of\u00a0<code>Any</code>:  </p> <p>\u5728\u591a\u6001\u7c7b\u7684\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\uff0c\u591a\u6001\u5c42\u6b21\u7ed3\u6784\u7684\u6839\u7c7b\u578b\uff08\u5728\u6211\u4eec\u7684\u793a\u4f8b\u4e2d\u4e3a <code>Project</code>\uff09\u662f\u9759\u6001\u786e\u5b9a\u7684\u3002\u8ba9\u6211\u4eec\u4ee5\u53ef\u5e8f\u5217\u5316\u7684 \u201c\u62bd\u8c61\u7c7b Project \u201c\u4e3a\u4f8b\uff0c\u6539\u53d8 \u201cmain \u201c\u51fd\u6570\uff0c\u5c06 \u201cdata \u201c\u58f0\u660e\u4e3a \u201cAny \u201c\u7c7b\u578b\uff1a  </p> <pre><code>fun main() {\n    val data: Any = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(format.encodeToString(data))\n}    \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>We get the exception. \u6211\u4eec\u5f97\u5230\u4e86\u5f02\u5e38\u3002</p> <pre><code>Exception in thread \"main\" kotlinx.serialization.SerializationException: Serializer for class 'Any' is not found.\nPlease ensure that class is marked as '@Serializable' and that the serialization compiler plugin is applied.\n</code></pre> <p>We have to register classes for polymorphic serialization with respect for the corresponding static type we use in the source code. First of all, we change our module to register a subclass of\u00a0<code>Any</code>: \u6211\u4eec\u5fc5\u987b\u9488\u5bf9\u6e90\u4ee3\u7801\u4e2d\u4f7f\u7528\u7684\u76f8\u5e94\u9759\u6001\u7c7b\u578b\u6ce8\u518c\u591a\u6001\u5e8f\u5217\u5316\u7c7b\u3002\u9996\u5148\uff0c\u6211\u4eec\u66f4\u6539\u6a21\u5757\uff0c\u6ce8\u518c\u4e00\u4e2a <code>Any</code> \u7684\u5b50\u7c7b\uff1a  </p> <pre><code>val module = SerializersModule {\n    polymorphic(Any::class) {\n        subclass(OwnedProject::class)\n    }\n}\n</code></pre> <p>Then we can try to serialize the variable of type\u00a0<code>Any</code>: \u7136\u540e\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5c1d\u8bd5\u5e8f\u5217\u5316 <code>Any</code> \u7c7b\u578b\u7684\u53d8\u91cf\u4e86\uff1a</p> <pre><code>fun main() {\n    val data: Any = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(format.encodeToString(data))\n}    \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>However,\u00a0<code>Any</code>\u00a0is a class and it is not serializable: \u7136\u800c\uff0c\u867d\u7136Any\u662f\u4e00\u4e2a\u7c7b\uff0c\u00a0\u4f46\u5b83\u4e0d\u53ef\u5e8f\u5217\u5316\uff1a</p> <pre><code>Exception in thread \"main\" kotlinx.serialization.SerializationException: Serializer for class 'Any' is not found.\nPlease ensure that class is marked as '@Serializable' and that the serialization compiler plugin is applied.\n</code></pre> <p>We must to explicitly pass an instance of\u00a0PolymorphicSerializer\u00a0for the base class\u00a0<code>Any</code>\u00a0as the first parameter to the\u00a0encodeToString\u00a0function. </p> <p>\u6211\u4eec\u5fc5\u987b\u5c06\u57fa\u7c7b\u00a0<code>Any</code>\u00a0\u7684 PolymorphicSerializer \u5b9e\u4f8b\u663e\u5f0f\u4f20\u9012\u7ed9 encodeToString \u51fd\u6570\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u3002</p> <pre><code>fun main() {\n    val data: Any = OwnedProject(\"kotlinx.coroutines\", \"kotlin\")\n    println(format.encodeToString(PolymorphicSerializer(Any::class), data))\n}    \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>With the explicit serializer it works as before. \u4f7f\u7528\u663e\u5f0f\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u5b83\u7684\u5de5\u4f5c\u65b9\u5f0f\u4e0e\u4ee5\u524d\u4e00\u6837\u3002</p> <pre><code>{\"type\":\"owned\",\"name\":\"kotlinx.coroutines\",\"owner\":\"kotlin\"}\n</code></pre>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#explicitly-marking-polymorphic-class-properties","title":"Explicitly marking polymorphic class properties  \u663e\u5f0f\u6807\u8bb0\u591a\u6001\u7c7b\u5c5e\u6027","text":"<p>The property of an interface type is implicitly considered polymorphic, since interfaces are all about runtime polymorphism. However, Kotlin Serialization does not compile a serializable class with a property of a non-serializable class type. If we have a property of\u00a0<code>Any</code>\u00a0class or other non-serializable class, then we must explicitly provide its serialization strategy via the\u00a0<code>@Serializable</code>\u00a0annotation as we saw in the\u00a0Specifying serializer on a property\u00a0section. To specify a polymorphic serialization strategy of a property, the special-purpose\u00a0<code>@Polymorphic</code>\u00a0annotation is used. \u63a5\u53e3\u7c7b\u578b\u7684\u5c5e\u6027\u88ab\u9690\u542b\u5730\u8ba4\u4e3a\u662f\u591a\u6001\u7684\uff0c\u56e0\u4e3a\u63a5\u53e3\u5c31\u662f\u5173\u4e8e\u8fd0\u884c\u65f6\u591a\u6001\u6027\u7684\u3002\u4f46\u662f\uff0cKotlin \u5e8f\u5217\u5316\u4e0d\u4f1a\u7f16\u8bd1\u5e26\u6709\u4e0d\u53ef\u5e8f\u5217\u5316\u7c7b\u7c7b\u578b\u5c5e\u6027\u7684\u53ef\u5e8f\u5217\u5316\u7c7b\u3002\u5982\u679c\u6211\u4eec\u6709\u4e00\u4e2a Any \u7c7b\u6216\u5176\u4ed6\u4e0d\u53ef\u5e8f\u5217\u5316\u7c7b\u7684\u5c5e\u6027\uff0c\u90a3\u4e48\u6211\u4eec\u5fc5\u987b\u901a\u8fc7 @Serializable \u6ce8\u89e3\u663e\u5f0f\u5730\u63d0\u4f9b\u5176\u5e8f\u5217\u5316\u7b56\u7565\uff0c\u6b63\u5982\u6211\u4eec\u5728 \u201c\u5728\u5c5e\u6027\u4e0a\u6307\u5b9a\u5e8f\u5217\u5316\u5668 \u201c\u4e00\u8282\u4e2d\u6240\u770b\u5230\u7684\u90a3\u6837\u3002\u8981\u6307\u5b9a\u4e00\u4e2a\u5c5e\u6027\u7684\u591a\u6001\u5e8f\u5217\u5316\u7b56\u7565\uff0c\u9700\u8981\u4f7f\u7528\u7279\u6b8a\u7528\u9014\u7684 @Polymorphic \u6ce8\u89e3\u3002</p> <pre><code>@Serializable\nclass Data(\n    @Polymorphic // the code does not compile without it \n    val project: Any \n)\n\nfun main() {\n    val data = Data(OwnedProject(\"kotlinx.coroutines\", \"kotlin\"))\n    println(format.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#registering-multiple-superclasses","title":"Registering multiple superclasses  \u6ce8\u518c\u591a\u4e2a\u8d85\u7c7b","text":"<p>When the same class gets serialized as a value of properties with different compile-time type from the list of its superclasses, we must register it in the\u00a0SerializersModule\u00a0for each of its superclasses separately. It is convenient to extract registration of all the subclasses into a separate function and use it for each superclass. You can use the following template to write it.  </p> <p>\u5f53\u540c\u4e00\u4e2a\u7c7b\u88ab\u5e8f\u5217\u5316\u4e3a\u5176\u8d85\u7c7b\u5217\u8868\u4e2d\u7f16\u8bd1\u65f6\u7c7b\u578b\u4e0d\u540c\u7684\u5c5e\u6027\u503c\u65f6\uff0c\u6211\u4eec\u5fc5\u987b\u5728 [SerializersModule] \u4e2d\u4e3a\u6bcf\u4e2a\u8d85\u7c7b\u5206\u522b\u6ce8\u518c\u3002\u5c06\u6240\u6709\u5b50\u7c7b\u7684\u6ce8\u518c\u63d0\u53d6\u5230\u4e00\u4e2a\u5355\u72ec\u7684\u51fd\u6570\u4e2d\u5e76\u7528\u4e8e\u6bcf\u4e2a\u8d85\u7c7b\u662f\u5f88\u65b9\u4fbf\u7684\u3002\u4f60\u53ef\u4ee5\u4f7f\u7528\u4e0b\u9762\u7684\u6a21\u677f\u6765\u7f16\u5199\u5b83\u3002 </p> <pre><code>val module = SerializersModule {\n    fun PolymorphicModuleBuilder&lt;Project&gt;.registerProjectSubclasses() {\n        subclass(OwnedProject::class)\n    }\n    polymorphic(Any::class) { registerProjectSubclasses() }\n    polymorphic(Project::class) { registerProjectSubclasses() }\n}        \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#polymorphism-and-generic-classes","title":"Polymorphism and generic classes  \u591a\u6001\u6027\u548c\u6cdb\u578b\u7c7b","text":"<p>Generic subtypes for a serializable class require a special handling. Consider the following hierarchy. \u53ef\u5e8f\u5217\u5316\u7c7b\u7684\u6cdb\u578b\u5b50\u7c7b\u578b\u9700\u8981\u7279\u6b8a\u5904\u7406\u3002\u8bf7\u8003\u8651\u4ee5\u4e0b\u5c42\u6b21\u7ed3\u6784\u3002</p> <pre><code>@Serializable\nabstract class Response&lt;out T&gt;\n\n@Serializable\n@SerialName(\"OkResponse\")\ndata class OkResponse&lt;out T&gt;(val data: T) : Response&lt;T&gt;()\n</code></pre> <p>Kotlin Serialization does not have a builtin strategy to represent the actually provided argument type for the type parameter\u00a0<code>T</code>\u00a0when serializing a property of the polymorphic type\u00a0<code>OkResponse&lt;T&gt;</code>. We have to provide this strategy explicitly when defining the serializers module for the\u00a0<code>Response</code>. In the below example we use\u00a0<code>OkResponse.serializer(...)</code>\u00a0to retrieve the\u00a0Plugin-generated generic serializer\u00a0of the\u00a0<code>OkResponse</code>\u00a0class and instantiate it with the\u00a0PolymorphicSerializer\u00a0instance with\u00a0<code>Any</code>\u00a0class as its base. This way, we can serialize an instance of\u00a0<code>OkResponse</code>\u00a0with any\u00a0<code>data</code>\u00a0property that was polymorphically registered as a subtype of\u00a0<code>Any</code>.  </p> <p>\u5728\u5e8f\u5217\u5316\u591a\u6001\u7c7b\u578b OkResponse \u7684\u5c5e\u6027\u65f6\uff0cKotlin \u5e8f\u5217\u5316\u6ca1\u6709\u5185\u7f6e\u7b56\u7565\u6765\u8868\u793a\u7c7b\u578b\u53c2\u6570 T \u5b9e\u9645\u63d0\u4f9b\u7684\u53c2\u6570\u7c7b\u578b\u3002\u6211\u4eec\u5fc5\u987b\u5728\u4e3a Response \u5b9a\u4e49\u5e8f\u5217\u5316\u6a21\u5757\u65f6\u660e\u786e\u63d0\u4f9b\u8fd9\u4e00\u7b56\u7565\u3002\u5728\u4e0b\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 OkResponse.serializer(\u2026)\u6765\u83b7\u53d6\u7531\u63d2\u4ef6\u751f\u6210\u7684 OkResponse \u7c7b\u7684\u901a\u7528\u5e8f\u5217\u5316\u5668\uff0c\u5e76\u5c06\u5176\u4e0e\u4ee5 Any \u7c7b\u4e3a\u57fa\u7c7b\u7684 PolymorphicSerializer \u5b9e\u4f8b\u8fdb\u884c\u5b9e\u4f8b\u5316\u3002\u8fd9\u6837\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5e8f\u5217\u5316 OkResponse \u5b9e\u4f8b\u7684\u4efb\u4f55\u6570\u636e\u5c5e\u6027\uff0c\u8fd9\u4e9b\u6570\u636e\u5c5e\u6027\u5df2\u88ab\u591a\u6001\u6ce8\u518c\u4e3a Any \u7684\u5b50\u7c7b\u578b\u3002 <pre><code>  val responseModule = SerializersModule {\n    polymorphic(Response::class) {\n        subclass(OkResponse.serializer(PolymorphicSerializer(Any::class)))\n    }\n}\n</code></pre>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#merging-library-serializers-modules","title":"Merging library serializers modules  \u5408\u5e76\u5e93\u5e8f\u5217\u5316\u7a0b\u5e8f\u6a21\u5757","text":"<p>When the application grows in size and splits into source code modules, it may become inconvenient to store all class hierarchies in one serializers module. Let us add a library with the\u00a0<code>Project</code>\u00a0hierarchy to the code from the previous section.  </p> <p>\u5f53\u5e94\u7528\u7a0b\u5e8f\u89c4\u6a21\u6269\u5927\u5e76\u5206\u5272\u6210\u591a\u4e2a\u6e90\u4ee3\u7801\u6a21\u5757\u65f6\uff0c\u5c06\u6240\u6709\u7c7b\u7684\u5c42\u6b21\u7ed3\u6784\u5b58\u50a8\u5728\u4e00\u4e2a\u5e8f\u5217\u5316\u6a21\u5757\u4e2d\u53ef\u80fd\u4f1a\u53d8\u5f97\u4e0d\u65b9\u4fbf\u3002\u8ba9\u6211\u4eec\u5728\u4e0a\u4e00\u8282\u7684\u4ee3\u7801\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u5177\u6709 <code>Project</code> \u5c42\u6b21\u7ed3\u6784\u7684\u5e93\u3002 </p> <pre><code>val projectModule = SerializersModule {\n    fun PolymorphicModuleBuilder&lt;Project&gt;.registerProjectSubclasses() {\n        subclass(OwnedProject::class)\n    }\n    polymorphic(Any::class) { registerProjectSubclasses() }\n    polymorphic(Project::class) { registerProjectSubclasses() }\n}\n</code></pre> <p>We can compose those two modules together using the\u00a0plus\u00a0operator to merge them, so that we can use them both in the same\u00a0Json\u00a0format instance.  </p> <p>\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 plus \u8fd0\u7b97\u7b26\u5c06\u8fd9\u4e24\u4e2a\u6a21\u5757\u7ec4\u5408\u5728\u4e00\u8d77\u4ee5\u5408\u5e76\u5b83\u4eec\uff0c\u4ee5\u4fbf\u6211\u4eec\u53ef\u4ee5\u5728\u540c\u4e00\u4e2a Json \u683c\u5f0f\u5b9e\u4f8b\u4e2d\u4f7f\u7528\u5b83\u4eec\u3002</p> <p>You can also use the\u00a0include\u00a0function in the\u00a0SerializersModule {}\u00a0DSL. \u8fd8\u53ef\u4ee5\u5728 SerializersModule {} DSL \u4e2d\u4f7f\u7528 include \u51fd\u6570\u3002</p> <pre><code>val format = Json { serializersModule = projectModule + responseModule }\n</code></pre> <p>Now classes from both hierarchies can be serialized together and deserialized together. \u73b0\u5728\uff0c\u4e24\u4e2a\u5c42\u6b21\u7ed3\u6784\u4e2d\u7684\u7c7b\u53ef\u4ee5\u4e00\u8d77\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u3002</p> <pre><code>fun main() {\n    // both Response and Project are abstract and their concrete subtypes are being serialized\n    val data: Response&lt;Project&gt; =  OkResponse(OwnedProject(\"kotlinx.serialization\", \"kotlin\"))\n    val string = format.encodeToString(data)\n    println(string)\n    println(format.decodeFromString&lt;Response&lt;Project&gt;&gt;(string))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The JSON that is being produced is deeply polymorphic. \u6b63\u5728\u751f\u6210\u7684 JSON \u662f\u6df1\u5ea6\u591a\u6001\u7684\u3002</p> <pre><code>{\"type\":\"OkResponse\",\"data\":{\"type\":\"OwnedProject\",\"name\":\"kotlinx.serialization\",\"owner\":\"kotlin\"}}\nOkResponse(data=OwnedProject(name=kotlinx.serialization, owner=kotlin))\n</code></pre> <p>If you\u2019re writing a library or shared module with an abstract class and some implementations of it, you can expose your own serializers module for your clients to use so that a client can combine your module with their modules. \u5982\u679c\u8981\u7f16\u5199\u5305\u542b\u62bd\u8c61\u7c7b\u53ca\u5176\u67d0\u4e9b\u5b9e\u73b0\u7684\u5e93\u6216\u5171\u4eab\u6a21\u5757\uff0c\u5219\u53ef\u4ee5\u516c\u5f00\u81ea\u5df1\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u6a21\u5757\u4f9b\u5ba2\u6237\u7aef\u4f7f\u7528\uff0c\u4ee5\u4fbf\u5ba2\u6237\u7aef\u53ef\u4ee5\u5c06\u6a21\u5757\u4e0e\u5176\u6a21\u5757\u7ec4\u5408\u5728\u4e00\u8d77\u3002</p>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#default-polymorphic-type-handler-for-deserialization","title":"Default polymorphic type handler for deserialization  \u7528\u4e8e\u53cd\u5e8f\u5217\u5316\u7684\u9ed8\u8ba4\u591a\u6001\u7c7b\u578b\u5904\u7406\u7a0b\u5e8f","text":"<p>What happens when we deserialize a subclass that was not registered? \u5f53\u6211\u4eec\u53cd\u5e8f\u5217\u5316\u672a\u6ce8\u518c\u7684\u5b50\u7c7b\u65f6\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f</p> <pre><code>fun main() {\n    println(format.decodeFromString&lt;Project&gt;(\"\"\"\n        {\"type\":\"unknown\",\"name\":\"example\"}\n    \"\"\"))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>We get the following exception. \u6211\u4eec\u5f97\u5230\u4ee5\u4e0b\u5f02\u5e38\u3002</p> <pre><code>Exception in thread \"main\" kotlinx.serialization.json.internal.JsonDecodingException: Unexpected JSON token at offset 0: Serializer for subclass 'unknown' is not found in the polymorphic scope of 'Project' at path: $\nCheck if class with serial name 'unknown' exists and serializer is registered in a corresponding SerializersModule.\n</code></pre> <p>When reading a flexible input we might want to provide some default behavior in this case. For example, we can have a\u00a0<code>BasicProject</code>\u00a0subtype to represent all kinds of unknown\u00a0<code>Project</code>\u00a0subtypes. \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5728\u8bfb\u53d6\u7075\u6d3b\u8f93\u5165\u65f6\uff0c\u6211\u4eec\u53ef\u80fd\u5e0c\u671b\u63d0\u4f9b\u4e00\u4e9b\u9ed8\u8ba4\u884c\u4e3a\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u6709\u4e00\u4e2a\u00a0<code>BasicProject</code>\u00a0\u5b50\u7c7b\u578b\u6765\u8868\u793a\u5404\u79cd\u672a\u77e5\u00a0<code>Project</code>\u00a0\u7684\u5b50\u7c7b\u578b\u3002</p> <pre><code>@Serializable\nabstract class Project {\n    abstract val name: String\n}\n\n@Serializable\ndata class BasicProject(override val name: String, val type: String): Project()\n\n@Serializable\n@SerialName(\"OwnedProject\")\ndata class OwnedProject(override val name: String, val owner: String) : Project()\n</code></pre> <p>We register a default deserializer handler using the\u00a0<code>defaultDeserializer</code>\u00a0function in the\u00a0<code>polymorphic { ... }</code>\u00a0DSL that defines a strategy which maps the\u00a0<code>type</code>\u00a0string from the input to the\u00a0deserialization strategy. In the below example we don\u2019t use the type, but always return the\u00a0Plugin-generated serializer\u00a0of the\u00a0<code>BasicProject</code>\u00a0class. \u6211\u4eec\u4f7f\u7528\u00a0<code>polymorphic { ... }</code>\u00a0DSL \u4e2d\u7684\u00a0<code>defaultDeserializer</code>\u00a0\u51fd\u6570\u6ce8\u518c\u4e00\u4e2a\u9ed8\u8ba4\u7684\u53cd\u5e8f\u5217\u5316\u7a0b\u5e8f\u5904\u7406\u7a0b\u5e8f\uff0c\u8be5\u51fd\u6570\u5b9a\u4e49\u4e86\u4e00\u4e2a\u7b56\u7565\uff0c\u8be5\u7b56\u7565\u5c06\u00a0<code>type</code>\u00a0\u5b57\u7b26\u4e32\u4ece\u8f93\u5165\u6620\u5c04\u5230\u53cd\u5e8f\u5217\u5316\u7b56\u7565\u3002\u5728\u4e0b\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u6ca1\u6709\u4f7f\u7528\u7c7b\u578b\uff0c\u800c\u662f\u59cb\u7ec8\u8fd4\u56de\u7531\u63d2\u4ef6\u751f\u6210\u7684 BasicProject \u7c7b\u7684\u5e8f\u5217\u5316\u5668\u3002</p> <pre><code>val module = SerializersModule {\n    polymorphic(Project::class) {\n        subclass(OwnedProject::class)\n        defaultDeserializer { BasicProject.serializer() }\n    }\n}\n</code></pre> <p>Using this module we can now deserialize both instances of the registered\u00a0<code>OwnedProject</code>\u00a0and any unregistered one. \u4f7f\u7528\u6b64\u6a21\u5757\uff0c\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u53cd\u5e8f\u5217\u5316\u5df2\u6ce8\u518c\u00a0<code>OwnedProject</code>\u00a0\u548c\u4efb\u4f55\u672a\u6ce8\u518c\u7684\u5b9e\u4f8b\u3002</p> <pre><code>val format = Json { serializersModule = module }\n\nfun main() {\n    println(format.decodeFromString&lt;List&lt;Project&gt;&gt;(\"\"\"\n        [\n            {\"type\":\"unknown\",\"name\":\"example\"},\n            {\"type\":\"OwnedProject\",\"name\":\"kotlinx.serialization\",\"owner\":\"kotlin\"} \n        ]\n    \"\"\"))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Notice, how\u00a0<code>BasicProject</code>\u00a0had also captured the specified type key in its\u00a0<code>type</code>\u00a0property. \u8bf7\u6ce8\u610f\uff0c\u5982\u4f55\u00a0<code>BasicProject</code>\u00a0\u5728\u5176\u00a0<code>type</code>\u00a0\u5c5e\u6027\u4e2d\u6355\u83b7\u6307\u5b9a\u7684\u7c7b\u578b\u952e\u3002</p> <pre><code>[BasicProject(name=example, type=unknown), OwnedProject(name=kotlinx.serialization, owner=kotlin)]\n</code></pre> <p>We used a plugin-generated serializer as a default serializer, implying that the structure of the \u201cunknown\u201d data is known in advance. In a real-world API it\u2019s rarely the case. For that purpose a custom, less-structured serializer is needed. You will see the example of such serializer in the future section on\u00a0Maintaining custom JSON attributes. \u6211\u4eec\u4f7f\u7528\u63d2\u4ef6\u751f\u6210\u7684\u5e8f\u5217\u5316\u5668\u4f5c\u4e3a\u9ed8\u8ba4\u5e8f\u5217\u5316\u5668\uff0c\u8fd9\u610f\u5473\u7740 \u201c\u672a\u77e5 \u201c\u6570\u636e\u7684\u7ed3\u6784\u662f\u4e8b\u5148\u5df2\u77e5\u7684\u3002\u5728\u73b0\u5b9e\u4e16\u754c\u7684\u5e94\u7528\u7a0b\u5e8f\u63a5\u53e3\u4e2d\uff0c\u8fd9\u79cd\u60c5\u51b5\u5f88\u5c11\u53d1\u751f\u3002\u4e3a\u6b64\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u81ea\u5b9a\u4e49\u7684\u3001\u7ed3\u6784\u4e0d\u90a3\u4e48\u590d\u6742\u7684\u5e8f\u5217\u5316\u5668\u3002\u60a8\u5c06\u5728\u4ee5\u540e\u7684\u7ef4\u62a4\u81ea\u5b9a\u4e49 JSON \u5c5e\u6027\u4e00\u8282\u4e2d\u770b\u5230\u8fd9\u79cd\u5e8f\u5217\u5316\u5668\u7684\u793a\u4f8b\u3002</p>"},{"location":"%E5%A4%9A%E6%80%81%E6%80%A7-4/#default-polymorphic-type-handler-for-serialization","title":"Default polymorphic type handler for serialization","text":"<p>\u7528\u4e8e\u5e8f\u5217\u5316\u7684\u9ed8\u8ba4\u591a\u6001\u7c7b\u578b\u5904\u7406\u7a0b\u5e8f</p> <p></p> <p>Sometimes you need to dynamically choose which serializer to use for a polymorphic type based on the instance, for example if you don\u2019t have access to the full type hierarchy, or if it changes a lot. For this situation, you can register a default serializer. \u4f8b\u5982\uff0c\u5982\u679c\u65e0\u6cd5\u8bbf\u95ee\u5b8c\u6574\u7684\u7c7b\u578b\u5c42\u6b21\u7ed3\u6784\uff0c\u6216\u8005\u7c7b\u578b\u53d8\u5316\u5f88\u5927\uff0c\u6709\u65f6\u9700\u8981\u6839\u636e\u5b9e\u4f8b\u52a8\u6001\u9009\u62e9\u591a\u6001\u7c7b\u578b\u7684\u5e8f\u5217\u5316\u5668\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u6ce8\u518c\u4e00\u4e2a\u9ed8\u8ba4\u5e8f\u5217\u5316\u5668\u3002 </p> <pre><code>interface Animal {\n}\n\ninterface Cat : Animal {\n    val catType: String\n}\n\ninterface Dog : Animal {\n    val dogType: String\n}\n\nprivate class CatImpl : Cat {\n    override val catType: String = \"Tabby\"\n}\n\nprivate class DogImpl : Dog {\n    override val dogType: String = \"Husky\"\n}\n\nobject AnimalProvider {\n    fun createCat(): Cat = CatImpl()\n    fun createDog(): Dog = DogImpl()\n}\n</code></pre> <p>We register a default serializer handler using the\u00a0<code>polymorphicDefaultSerializer</code>\u00a0function in the\u00a0<code>SerializersModule { ... }</code>\u00a0DSL that defines a strategy which takes an instance of the base class and provides a\u00a0serialization strategy. In the below example we use a\u00a0<code>when</code>\u00a0block to check the type of the instance, without ever having to refer to the private implementation classes.  </p> <p>\u6211\u4eec\u4f7f\u7528\u00a0<code>SerializersModule { ... }</code>\u00a0DSL \u4e2d\u7684\u00a0<code>polymorphicDefaultSerializer</code>\u00a0\u51fd\u6570\u6ce8\u518c\u4e00\u4e2a\u9ed8\u8ba4\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u5904\u7406\u7a0b\u5e8f\uff0c\u8be5\u51fd\u6570\u5b9a\u4e49\u4e86\u4e00\u4e2a\u7b56\u7565\uff0c\u8be5\u7b56\u7565\u91c7\u7528\u57fa\u7c7b\u7684\u5b9e\u4f8b\u5e76\u63d0\u4f9b\u5e8f\u5217\u5316\u7b56\u7565\u3002\u5728\u4e0b\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4e00\u4e2a\u00a0<code>when</code>\u00a0\u5757\u6765\u68c0\u67e5\u5b9e\u4f8b\u7684\u7c7b\u578b\uff0c\u800c\u65e0\u9700\u5f15\u7528\u79c1\u6709\u5b9e\u73b0\u7c7b\u3002</p> <pre><code>val module = SerializersModule {\n    polymorphicDefaultSerializer(Animal::class) { instance -&gt;\n        @Suppress(\"UNCHECKED_CAST\")\n        when (instance) {\n            is Cat -&gt; CatSerializer as SerializationStrategy&lt;Animal&gt;\n            is Dog -&gt; DogSerializer as SerializationStrategy&lt;Animal&gt;\n            else -&gt; null\n        }\n    }\n}\n\nobject CatSerializer : SerializationStrategy&lt;Cat&gt; {\n    override val descriptor = buildClassSerialDescriptor(\"Cat\") {\n        element&lt;String&gt;(\"catType\")\n    }\n\n    override fun serialize(encoder: Encoder, value: Cat) {\n        encoder.encodeStructure(descriptor) {\n          encodeStringElement(descriptor, 0, value.catType)\n        }\n    }\n}\n\nobject DogSerializer : SerializationStrategy&lt;Dog&gt; {\n  override val descriptor = buildClassSerialDescriptor(\"Dog\") {\n    element&lt;String&gt;(\"dogType\")\n  }\n\n  override fun serialize(encoder: Encoder, value: Dog) {\n    encoder.encodeStructure(descriptor) {\n      encodeStringElement(descriptor, 0, value.dogType)\n    }\n  }\n}\n</code></pre> <p>Using this module we can now serialize instances of\u00a0<code>Cat</code>\u00a0and\u00a0<code>Dog</code>. \u4f7f\u7528\u6b64\u6a21\u5757\uff0c\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u5e8f\u5217\u5316\u00a0<code>Cat</code>\u00a0\u548c\u00a0<code>Dog</code>\u00a0\u7684\u5b9e\u4f8b\u3002</p> <pre><code>val format = Json { serializersModule = module }\n\nfun main() {\n    println(format.encodeToString&lt;Animal&gt;(AnimalProvider.createCat()))\n}\n</code></pre> <p>You can get the full code\u00a0here \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801</p> <pre><code>{\"type\":\"Cat\",\"catType\":\"Tabby\"}\n</code></pre> <p>The next chapter covers\u00a0JSON features. \u4e0b\u4e00\u7ae0\u5c06\u4ecb\u7ecd JSON \u529f\u80fd\u3002</p>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/","title":"Serializers\u00a0\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>This is the third chapter of the\u00a0Kotlin Serialization Guide. In this chapter we\u2019ll take a look at serializers in more detail, and we\u2019ll see how custom serializers can be written. \u8fd9\u662f\u300aKotlin \u5e8f\u5217\u5316\u6307\u5357\u300b\u7684\u7b2c\u4e09\u7ae0\u3002\u5728\u672c\u7ae0\u4e2d\uff0c\u6211\u4eec\u5c06\u66f4\u8be6\u7ec6\u5730\u4ecb\u7ecd\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u5e76\u4e86\u89e3\u5982\u4f55\u7f16\u5199\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002</p> <p>Table of contents\u00a0\u76ee\u5f55</p> <ul> <li>Introduction to serializers     \u5e8f\u5217\u5316\u7a0b\u5e8f\u7b80\u4ecb<ul> <li>Plugin-generated serializer     \u63d2\u4ef6\u751f\u6210\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Plugin-generated generic serializer     \u63d2\u4ef6\u751f\u6210\u7684\u6cdb\u578b\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Builtin primitive serializers     \u5185\u7f6e\u57fa\u5143\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Constructing collection serializers     \u6784\u9020\u96c6\u5408\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Using top-level serializer function     \u4f7f\u7528\u9876\u7ea7\u5e8f\u5217\u5316\u7a0b\u5e8f\u529f\u80fd</li> </ul> </li> <li>Custom serializers\u00a0\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f<ul> <li>Primitive serializer\u00a0\u57fa\u5143\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Delegating serializers\u00a0\u59d4\u6d3e\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Composite serializer via surrogate     \u901a\u8fc7\u4ee3\u7406\u9879\u7684\u590d\u5408\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Hand-written composite serializer     \u624b\u5199\u590d\u5408\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Sequential decoding protocol (experimental)     \u987a\u5e8f\u89e3\u7801\u534f\u8bae\uff08\u5b9e\u9a8c\u6027\uff09</li> <li>Serializing 3rd party classes     \u5e8f\u5217\u5316\u7b2c\u4e09\u65b9\u7c7b</li> <li>Passing a serializer manually     \u624b\u52a8\u4f20\u9012\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Specifying serializer on a property     \u5728\u5c5e\u6027\u4e0a\u6307\u5b9a\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Specifying serializer for a particular type     \u4e3a\u7279\u5b9a\u7c7b\u578b\u6307\u5b9a\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Specifying serializers for a file     \u6307\u5b9a\u6587\u4ef6\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Specifying serializer globally using typealias     \u4f7f\u7528 typealias \u5168\u5c40\u6307\u5b9a\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Custom serializers for a generic type     \u6cdb\u578b\u7c7b\u578b\u7684\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Format-specific serializers     \u7279\u5b9a\u4e8e\u683c\u5f0f\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f</li> </ul> </li> <li>Contextual serialization     \u4e0a\u4e0b\u6587\u5e8f\u5217\u5316<ul> <li>Serializers module\u00a0\u4e32\u884c\u7a0b\u5e8f\u6a21\u5757</li> <li>Contextual serialization and generic classes     \u4e0a\u4e0b\u6587\u5e8f\u5217\u5316\u548c\u6cdb\u578b\u7c7b</li> </ul> </li> <li>Deriving external serializer for another Kotlin class (experimental)     \u4e3a\u53e6\u4e00\u4e2a Kotlin \u7c7b\u6d3e\u751f\u5916\u90e8\u5e8f\u5217\u5316\u7a0b\u5e8f\uff08\u5b9e\u9a8c\u6027\uff09<ul> <li>External serialization uses properties     \u5916\u90e8\u5e8f\u5217\u5316\u4f7f\u7528\u5c5e\u6027</li> </ul> </li> </ul>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#introduction-to-serializers","title":"Introduction to serializers  \u5e8f\u5217\u5316\u7a0b\u5e8f\u7b80\u4ecb","text":"<p>Formats, like JSON, control the\u00a0encoding\u00a0of an object into specific output bytes, but how the object is decomposed into its constituent properties is controlled by a\u00a0serializer. So far we\u2019ve been using automatically-derived serializers by using the\u00a0<code>@Serializable</code>\u00a0annotation as explained in the\u00a0Serializable classes\u00a0section, or using builtin serializers that were shown in the\u00a0Builtin classes\u00a0section.  </p> <p>\u683c\u5f0f\uff08\u5982 JSON\uff09\u63a7\u5236\u7740\u5c06\u5bf9\u8c61\u7f16\u7801\u4e3a\u7279\u5b9a\u8f93\u51fa\u5b57\u8282\u7684\u7f16\u7801\uff0c\u4f46\u5982\u4f55\u5c06\u5bf9\u8c61\u5206\u89e3\u4e3a\u5176\u7ec4\u6210\u5c5e\u6027\u5219\u7531\u5e8f\u5217\u5316\u5668\u63a7\u5236\u3002\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u4e00\u76f4\u901a\u8fc7\u4f7f\u7528 [<code>@Serializable</code>]\u6ce8\u89e3\uff08\u5982 [Serializable classes] \u90e8\u5206\u6240\u8ff0\uff09\u6765\u4f7f\u7528\u81ea\u52a8\u6d3e\u751f\u7684\u5e8f\u5217\u5316\u5668\uff0c\u6216\u8005\u4f7f\u7528 [Builtin classes] \u90e8\u5206\u6240\u793a\u7684\u5185\u7f6e\u5e8f\u5217\u5316\u5668\u3002 </p> <p>As a motivating example, let us take the following\u00a0<code>Color</code>\u00a0class with an integer value storing its\u00a0<code>rgb</code>\u00a0bytes. \u4f5c\u4e3a\u4e00\u4e2a\u6fc0\u52b1\u6027\u7684\u4f8b\u5b50\uff0c\u8ba9\u6211\u4eec\u4ee5\u4e0b\u9762\u7684\u00a0<code>Color</code>\u00a0\u7c7b\u4e3a\u4f8b\uff0c\u8be5\u7c7b\u5177\u6709\u5b58\u50a8\u5176\u00a0<code>rgb</code>\u00a0\u5b57\u8282\u7684\u6574\u6570\u503c\u3002</p> <pre><code>@Serializable\nclass Color(val rgb: Int)\n\nfun main() {\n    val green = Color(0x00ff00)\n    println(Json.encodeToString(green))\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>By default this class serializes its\u00a0<code>rgb</code>\u00a0property into JSON. \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6b64\u7c7b\u5c06\u5176\u00a0<code>rgb</code>\u00a0\u5c5e\u6027\u5e8f\u5217\u5316\u4e3a JSON\u3002</p> <pre><code>{\"rgb\":65280}\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#plugin-generated-serializer","title":"Plugin-generated serializer  \u63d2\u4ef6\u751f\u6210\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>Every class marked with the\u00a0<code>@Serializable</code>\u00a0annotation, like the\u00a0<code>Color</code>\u00a0class from the previous example, gets an instance of the\u00a0KSerializer\u00a0interface automatically generated by the Kotlin Serialization compiler plugin. We can retrieve this instance using the\u00a0<code>.serializer()</code>\u00a0function on the class\u2019s companion object. \u4e0e\u4e0a\u4e00\u4e2a\u793a\u4f8b\u4e2d\u7684\u00a0<code>Color</code>\u00a0\u7c7b\u4e00\u6837\uff0c\u6bcf\u4e2a\u6807\u6709\u00a0<code>@Serializable</code>\u00a0\u6ce8\u91ca\u7684\u7c7b\u90fd\u4f1a\u83b7\u5f97\u7531 Kotlin \u5e8f\u5217\u5316\u7f16\u8bd1\u5668\u63d2\u4ef6\u81ea\u52a8\u751f\u6210\u7684 KSerializer \u63a5\u53e3\u7684\u5b9e\u4f8b\u3002\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u7c7b\u7684\u4f34\u968f\u5bf9\u8c61\u4e0a\u7684\u00a0<code>.serializer()</code>\u00a0\u51fd\u6570\u6765\u68c0\u7d22\u6b64\u5b9e\u4f8b\u3002</p> <p>We can examine its\u00a0descriptor\u00a0property that describes the structure of the serialized class. We\u2019ll learn more details about that in the upcoming sections. \u6211\u4eec\u53ef\u4ee5\u68c0\u67e5\u5176\u63cf\u8ff0\u5e8f\u5217\u5316\u7c7b\u7ed3\u6784\u7684\u63cf\u8ff0\u7b26\u5c5e\u6027\u3002\u6211\u4eec\u5c06\u5728\u63a5\u4e0b\u6765\u7684\u7ae0\u8282\u4e2d\u4e86\u89e3\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\u3002</p> <pre><code>fun main() {\n    val colorSerializer: KSerializer&lt;Color&gt; = Color.serializer()\n    println(colorSerializer.descriptor)\n} \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>Color(rgb: kotlin.Int)\n</code></pre> <p>This serializer is automatically retrieved and used by the Kotlin Serialization framework when the\u00a0<code>Color</code>\u00a0class is itself serialized, or when it is used as a property of other classes. \u5f53\u00a0<code>Color</code>\u00a0\u7c7b\u672c\u8eab\u5e8f\u5217\u5316\u65f6\uff0c\u6216\u8005\u5f53\u5b83\u88ab\u7528\u4f5c\u5176\u4ed6\u7c7b\u7684\u5c5e\u6027\u65f6\uff0cKotlin \u5e8f\u5217\u5316\u6846\u67b6\u4f1a\u81ea\u52a8\u68c0\u7d22\u548c\u4f7f\u7528\u6b64\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002</p> <p>You cannot define your own function\u00a0<code>serializer()</code>\u00a0on a companion object of a serializable class. \u4e0d\u80fd\u5728\u53ef\u5e8f\u5217\u5316\u7c7b\u7684\u4f34\u968f\u5bf9\u8c61\u4e0a\u5b9a\u4e49\u81ea\u5df1\u7684\u51fd\u6570\u00a0<code>serializer()</code>\u00a0\u3002</p>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#plugin-generated-generic-serializer","title":"Plugin-generated generic serializer  \u63d2\u4ef6\u751f\u6210\u7684\u6cdb\u578b\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>For generic classes, like the\u00a0<code>Box</code>\u00a0class shown in the\u00a0Generic classes\u00a0section, the automatically generated\u00a0<code>.serializer()</code>\u00a0function accepts as many parameters as there are type parameters in the corresponding class. These parameters are of type\u00a0KSerializer, so the actual type argument\u2019s serializer has to be provided when constructing an instance of a serializer for a generic class. \u5bf9\u4e8e\u6cdb\u578b\u7c7b\uff08\u5982\u6cdb\u578b\u7c7b\u201c\u90e8\u5206\u4e2d\u663e\u793a\u7684\u00a0<code>Box</code>\u00a0\u7c7b\uff09\uff0c\u81ea\u52a8\u751f\u6210\u00a0<code>.serializer()</code>\u00a0\u7684\u51fd\u6570\u63a5\u53d7\u7684\u53c2\u6570\u6570\u91cf\u4e0e\u76f8\u5e94\u7c7b\u4e2d\u7684\u7c7b\u578b\u53c2\u6570\u6570\u91cf\u4e00\u6837\u591a\u3002\u8fd9\u4e9b\u53c2\u6570\u7684\u7c7b\u578b\u4e3a KSerializer\uff0c\u56e0\u6b64\u5728\u4e3a\u6cdb\u578b\u7c7b\u6784\u9020\u5e8f\u5217\u5316\u7a0b\u5e8f\u7684\u5b9e\u4f8b\u65f6\uff0c\u5fc5\u987b\u63d0\u4f9b\u5b9e\u9645\u7c7b\u578b\u53c2\u6570\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002</p> <pre><code>@Serializable           \n@SerialName(\"Box\")\nclass Box&lt;T&gt;(val contents: T)    \n\nfun main() {\n    val boxedColorSerializer = Box.serializer(Color.serializer())\n    println(boxedColorSerializer.descriptor)\n} \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>As we can see, a serializer was instantiated to serialize a concrete\u00a0<code>Box&lt;Color&gt;</code>. \u6b63\u5982\u6211\u4eec\u6240\u770b\u5230\u7684\uff0c\u5e8f\u5217\u5316\u5668\u88ab\u5b9e\u4f8b\u5316\u4e3a\u5e8f\u5217\u5316\u4e00\u4e2a\u5177\u4f53\u00a0<code>Box&lt;Color&gt;</code>\u00a0\u7684 .</p> <pre><code>Box(contents: Color)\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#builtin-primitive-serializers","title":"Builtin primitive serializers  \u5185\u7f6e\u57fa\u5143\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>The serializers for the\u00a0primitive builtin classes\u00a0can be retrieved using\u00a0<code>.serializer()</code>\u00a0extensions. \u53ef\u4ee5\u4f7f\u7528\u00a0<code>.serializer()</code>\u00a0\u6269\u5c55\u68c0\u7d22\u539f\u59cb\u5185\u7f6e\u7c7b\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002</p> <pre><code>fun main() {\n    val intSerializer: KSerializer&lt;Int&gt; = Int.serializer()\n    println(intSerializer.descriptor)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#constructing-collection-serializers","title":"Constructing collection serializers  \u6784\u9020\u96c6\u5408\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>Builtin collection serializers, when needed, must be explicitly constructed using the corresponding functions\u00a0ListSerializer(),\u00a0SetSerializer(),\u00a0MapSerializer(), etc. These classes are generic, so to instantiate their serializer we must provide the serializers for the corresponding number of their type parameters. For example, we can produce a serializer for a\u00a0<code>List&lt;String&gt;</code>\u00a0in the following way. \u5185\u7f6e\u96c6\u5408\u5e8f\u5217\u5316\u7a0b\u5e8f\u5728\u9700\u8981\u65f6\uff0c\u5fc5\u987b\u4f7f\u7528\u76f8\u5e94\u7684\u51fd\u6570 ListSerializer\uff08\uff09\u3001SetSerializer\uff08\uff09\u3001MapSerializer\uff08\uff09 \u7b49\u663e\u5f0f\u6784\u9020\u3002\u8fd9\u4e9b\u7c7b\u662f\u6cdb\u578b\u7684\uff0c\u56e0\u6b64\u8981\u5b9e\u4f8b\u5316\u5b83\u4eec\u7684\u5e8f\u5217\u5316\u5668\uff0c\u6211\u4eec\u5fc5\u987b\u4e3a\u5176\u76f8\u5e94\u6570\u91cf\u7684\u7c7b\u578b\u53c2\u6570\u63d0\u4f9b\u5e8f\u5217\u5316\u5668\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u6309\u4ee5\u4e0b\u65b9\u5f0f\u4e3a a\u00a0<code>List&lt;String&gt;</code>\u00a0\u751f\u6210\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002</p> <pre><code>fun main() {   \n    val stringListSerializer: KSerializer&lt;List&lt;String&gt;&gt; = ListSerializer(String.serializer()) \n    println(stringListSerializer.descriptor)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#using-top-level-serializer-function","title":"Using top-level serializer function  \u4f7f\u7528\u9876\u7ea7\u5e8f\u5217\u5316\u7a0b\u5e8f\u529f\u80fd","text":"<p>When in doubt, you can always use the top-level generic\u00a0<code>serializer&lt;T&gt;()</code>\u00a0function to retrieve a serializer for an arbitrary Kotlin type in your source-code. \u5982\u6709\u7591\u95ee\uff0c\u60a8\u59cb\u7ec8\u53ef\u4ee5\u4f7f\u7528\u9876\u7ea7\u6cdb\u578b\u00a0<code>serializer&lt;T&gt;()</code>\u00a0\u51fd\u6570\u5728\u6e90\u4ee3\u7801\u4e2d\u68c0\u7d22\u4efb\u610f Kotlin \u7c7b\u578b\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002</p> <pre><code>@Serializable            \n@SerialName(\"Color\")\nclass Color(val rgb: Int)\n\nfun main() {        \n    val stringToColorMapSerializer: KSerializer&lt;Map&lt;String, Color&gt;&gt; = serializer()\n    println(stringToColorMapSerializer.descriptor)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#custom-serializers","title":"Custom serializers\u00a0\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>A plugin-generated serializer is convenient, but it may not produce the JSON we want for such a class as\u00a0<code>Color</code>. Let\u2019s study alternatives. \u63d2\u4ef6\u751f\u6210\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u5f88\u65b9\u4fbf\uff0c\u4f46\u5b83\u53ef\u80fd\u4e0d\u4f1a\u4e3a\u8fd9\u6837\u7684\u00a0<code>Color</code>\u00a0\u7c7b\u751f\u6210\u6211\u4eec\u60f3\u8981\u7684 JSON\u3002\u8ba9\u6211\u4eec\u7814\u7a76\u4e00\u4e0b\u66ff\u4ee3\u65b9\u6848\u3002</p>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#primitive-serializer","title":"Primitive serializer\u00a0\u57fa\u5143\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>We want to serialize the\u00a0<code>Color</code>\u00a0class as a hex string with the green color represented as\u00a0<code>\"00ff00\"</code>. To achieve this, we write an object that implements the\u00a0KSerializer\u00a0interface for the\u00a0<code>Color</code>\u00a0class. \u6211\u4eec\u5e0c\u671b\u5c06\u00a0<code>Color</code>\u00a0\u7c7b\u5e8f\u5217\u5316\u4e3a\u5341\u516d\u8fdb\u5236\u5b57\u7b26\u4e32\uff0c\u7eff\u8272\u8868\u793a\u4e3a\u00a0<code>\"00ff00\"</code>\u00a0\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e00\u70b9\uff0c\u6211\u4eec\u7f16\u5199\u4e86\u4e00\u4e2a\u5bf9\u8c61\u6765\u5b9e\u73b0\u00a0<code>Color</code>\u00a0\u8be5\u7c7b\u7684 KSerializer \u63a5\u53e3\u3002</p> <pre><code>object ColorAsStringSerializer : KSerializer&lt;Color&gt; {\n    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor(\"Color\", PrimitiveKind.STRING)\n\n    override fun serialize(encoder: Encoder, value: Color) {\n        val string = value.rgb.toString(16).padStart(6, '0')\n        encoder.encodeString(string)\n    }\n\n    override fun deserialize(decoder: Decoder): Color {\n        val string = decoder.decodeString()\n        return Color(string.toInt(16))\n    }\n}\n</code></pre> <p>Serializer has three required pieces. \u5e8f\u5217\u5316\u7a0b\u5e8f\u6709\u4e09\u4e2a\u5fc5\u9700\u7684\u90e8\u5206\u3002</p> <ul> <li> <p>The\u00a0serialize\u00a0function implements\u00a0SerializationStrategy. It receives an instance of\u00a0Encoder\u00a0and a value to serialize. It uses the\u00a0<code>encodeXxx</code>\u00a0functions of\u00a0<code>Encoder</code>\u00a0to represent a value as a sequence of primitives. There is an\u00a0<code>encodeXxx</code>\u00a0for each primitive type supported by serialization. In our example,\u00a0encodeString\u00a0is used.     serialize \u51fd\u6570\u5b9e\u73b0 SerializationStrategy\u3002\u5b83\u63a5\u6536 Encoder \u7684\u5b9e\u4f8b\u548c\u8981\u5e8f\u5217\u5316\u7684\u503c\u3002\u5b83\u4f7f\u7528 \u7684\u00a0<code>encodeXxx</code> <code>Encoder</code>\u00a0\u51fd\u6570\u5c06\u503c\u8868\u793a\u4e3a\u57fa\u5143\u5e8f\u5217\u3002\u5e8f\u5217\u5316\u652f\u6301\u7684\u6bcf\u4e2a\u57fa\u5143\u7c7b\u578b\u90fd\u6709\u4e00\u4e2a\u00a0<code>encodeXxx</code>\u00a0\u3002\u5728\u6211\u4eec\u7684\u793a\u4f8b\u4e2d\uff0c\u4f7f\u7528\u4e86 encodeString\u3002</p> </li> <li> <p>The\u00a0deserialize\u00a0function implements\u00a0DeserializationStrategy. It receives an instance of\u00a0Decoder\u00a0and returns a deserialized value. It uses the\u00a0<code>decodeXxx</code>\u00a0functions of\u00a0<code>Decoder</code>, which mirror the corresponding functions of\u00a0<code>Encoder</code>. In our example\u00a0decodeString\u00a0is used.     \u53cd\u5e8f\u5217\u5316\u51fd\u6570\u5b9e\u73b0 DeserializationStrategy\u3002\u5b83\u63a5\u6536 Decoder \u7684\u5b9e\u4f8b\u5e76\u8fd4\u56de\u53cd\u5e8f\u5217\u5316\u503c\u3002\u5b83\u4f7f\u7528\u00a0<code>Decoder</code>\u00a0\u7684\u00a0<code>decodeXxx</code>\u00a0\u51fd\u6570 \uff0c\u8fd9\u4e9b\u51fd\u6570\u53cd\u6620\u4e86 \u7684\u00a0<code>Encoder</code>\u00a0\u76f8\u5e94\u51fd\u6570\u3002\u5728\u6211\u4eec\u7684\u793a\u4f8b\u4e2d\uff0c\u4f7f\u7528\u4e86 decodeString\u3002</p> </li> <li> <p>The\u00a0descriptor\u00a0property must faithfully explain what exactly the\u00a0<code>encodeXxx</code>\u00a0and\u00a0<code>decodeXxx</code>\u00a0functions do so that a format implementation knows in advance what encoding/decoding methods they call. Some formats might also use it to generate a schema for the serialized data. For primitive serialization, the\u00a0PrimitiveSerialDescriptor\u00a0function must be used with a unique name of the type that is being serialized.\u00a0PrimitiveKind\u00a0describes the specific\u00a0<code>encodeXxx</code>/<code>decodeXxx</code>\u00a0method that is being used in the implementation.     \u63cf\u8ff0\u7b26\u5c5e\u6027\u5fc5\u987b\u5fe0\u5b9e\u5730\u89e3\u91ca\u00a0<code>encodeXxx</code>\u00a0and\u00a0<code>decodeXxx</code>\u00a0\u51fd\u6570\u7684\u786e\u5207\u4f5c\u7528\uff0c\u4ee5\u4fbf\u683c\u5f0f\u5b9e\u73b0\u4e8b\u5148\u77e5\u9053\u5b83\u4eec\u8c03\u7528\u7684\u7f16\u7801/\u89e3\u7801\u65b9\u6cd5\u3002\u67d0\u4e9b\u683c\u5f0f\u8fd8\u53ef\u80fd\u4f7f\u7528\u5b83\u6765\u751f\u6210\u5e8f\u5217\u5316\u6570\u636e\u7684\u67b6\u6784\u3002\u5bf9\u4e8e\u57fa\u5143\u5e8f\u5217\u5316\uff0cPrimitiveSerialDescriptor \u51fd\u6570\u5fc5\u987b\u4e0e\u8981\u5e8f\u5217\u5316\u7684\u7c7b\u578b\u7684\u552f\u4e00\u540d\u79f0\u4e00\u8d77\u4f7f\u7528\u3002PrimitiveKind \u63cf\u8ff0\u5b9e\u73b0\u4e2d\u4f7f\u7528\u7684\u7279\u5b9a\u00a0<code>encodeXxx</code>\u00a0/\u00a0<code>decodeXxx</code>\u00a0\u65b9\u6cd5\u3002</p> </li> </ul> <p>When the\u00a0<code>descriptor</code>\u00a0does not correspond to the encoding/decoding methods, then the behavior of the resulting code is unspecified, and may arbitrarily change in future updates. \u5f53 \u4e0e\u00a0<code>descriptor</code>\u00a0\u7f16\u7801/\u89e3\u7801\u65b9\u6cd5\u4e0d\u5bf9\u5e94\u65f6\uff0c\u5219\u751f\u6210\u7684\u4ee3\u7801\u7684\u884c\u4e3a\u662f\u672a\u6307\u5b9a\u7684\uff0c\u5e76\u4e14\u53ef\u80fd\u4f1a\u5728\u5c06\u6765\u7684\u66f4\u65b0\u4e2d\u4efb\u610f\u66f4\u6539\u3002</p> <p>The next step is to bind a serializer to a class. This is done with the\u00a0<code>@Serializable</code>\u00a0annotation by adding the\u00a0<code>with</code>\u00a0property value. \u4e0b\u4e00\u6b65\u662f\u5c06\u5e8f\u5217\u5316\u7a0b\u5e8f\u7ed1\u5b9a\u5230\u7c7b\u3002\u8fd9\u662f\u901a\u8fc7\u6dfb\u52a0\u00a0<code>with</code>\u00a0\u5c5e\u6027\u503c\u6765\u00a0<code>@Serializable</code>\u00a0\u5b8c\u6210\u6ce8\u91ca\u7684\u3002</p> <pre><code>@Serializable(with = ColorAsStringSerializer::class)\nclass Color(val rgb: Int)\n</code></pre> <p>Now we can serialize the\u00a0<code>Color</code>\u00a0class as we did before. \u73b0\u5728\uff0c\u6211\u4eec\u53ef\u4ee5\u50cf\u4ee5\u524d\u4e00\u6837\u5e8f\u5217\u5316\u00a0<code>Color</code>\u00a0\u8be5\u7c7b\u3002</p> <pre><code>fun main() {\n    val green = Color(0x00ff00)\n    println(Json.encodeToString(green))\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>We get the serial representation as the hex string we wanted. \u6211\u4eec\u5f97\u5230\u4e32\u884c\u8868\u793a\u4e3a\u6211\u4eec\u60f3\u8981\u7684\u5341\u516d\u8fdb\u5236\u5b57\u7b26\u4e32\u3002</p> <pre><code>\"00ff00\"\n</code></pre> <p>Deserialization is also straightforward because we implemented the\u00a0<code>deserialize</code>\u00a0method. \u53cd\u5e8f\u5217\u5316\u4e5f\u5f88\u7b80\u5355\uff0c\u56e0\u4e3a\u6211\u4eec\u5b9e\u73b0\u4e86\u8be5\u00a0<code>deserialize</code>\u00a0\u65b9\u6cd5\u3002</p> <pre><code>@Serializable(with = ColorAsStringSerializer::class)\nclass Color(val rgb: Int)\n\nfun main() {\n    val color = Json.decodeFromString&lt;Color&gt;(\"\\\"00ff00\\\"\")\n    println(color.rgb) // prints 65280 \n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>It also works if we serialize or deserialize a different class with\u00a0<code>Color</code>\u00a0properties. \u5982\u679c\u6211\u4eec\u5e8f\u5217\u5316\u6216\u53cd\u5e8f\u5217\u5316\u5177\u6709\u00a0<code>Color</code>\u00a0\u5c5e\u6027\u7684\u4e0d\u540c\u7c7b\uff0c\u5b83\u4e5f\u53ef\u4ee5\u5de5\u4f5c\u3002</p> <pre><code>@Serializable(with = ColorAsStringSerializer::class)\ndata class Color(val rgb: Int)\n\n@Serializable \ndata class Settings(val background: Color, val foreground: Color)\n\nfun main() {\n    val data = Settings(Color(0xffffff), Color(0))\n    val string = Json.encodeToString(data)\n    println(string)\n    require(Json.decodeFromString&lt;Settings&gt;(string) == data)\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Both\u00a0<code>Color</code>\u00a0properties are serialized as strings. \u8fd9\u4e24\u4e2a\u00a0<code>Color</code>\u00a0\u5c5e\u6027\u90fd\u5e8f\u5217\u5316\u4e3a\u5b57\u7b26\u4e32\u3002</p> <pre><code>{\"background\":\"ffffff\",\"foreground\":\"000000\"}\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#delegating-serializers","title":"Delegating serializers\u00a0\u59d4\u6d3e\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>In the previous example, we represented the\u00a0<code>Color</code>\u00a0class as a string. String is considered to be a primitive type, therefore we used\u00a0<code>PrimitiveClassDescriptor</code>\u00a0and specialized\u00a0<code>encodeString</code>\u00a0method. Now let\u2019s see what our actions would be if we have to serialize\u00a0<code>Color</code>\u00a0as another non-primitive type, let\u2019s say\u00a0<code>IntArray</code>. \u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u5c06\u00a0<code>Color</code>\u00a0\u7c7b\u8868\u793a\u4e3a\u5b57\u7b26\u4e32\u3002\u5b57\u7b26\u4e32\u88ab\u8ba4\u4e3a\u662f\u4e00\u79cd\u539f\u59cb\u7c7b\u578b\uff0c\u56e0\u6b64\u6211\u4eec\u4f7f\u7528\u4e86\u00a0<code>PrimitiveClassDescriptor</code>\u00a0\u4e13\u95e8\u00a0<code>encodeString</code>\u00a0\u7684\u65b9\u6cd5\u3002\u73b0\u5728\u8ba9\u6211\u4eec\u770b\u770b\u5982\u679c\u6211\u4eec\u5fc5\u987b\u5e8f\u5217\u5316\u00a0<code>Color</code>\u00a0\u4e3a\u53e6\u4e00\u79cd\u975e\u539f\u59cb\u7c7b\u578b\uff0c\u6211\u4eec\u7684\u64cd\u4f5c\u4f1a\u662f\u4ec0\u4e48\uff0c\u6bd4\u5982\u00a0<code>IntArray</code>\u00a0\u8bf4 .</p> <p>An implementation of\u00a0KSerializer\u00a0for our original\u00a0<code>Color</code>\u00a0class is going to perform a conversion between\u00a0<code>Color</code>\u00a0and\u00a0<code>IntArray</code>, but delegate the actual serialization logic to the\u00a0<code>IntArraySerializer</code>\u00a0using\u00a0encodeSerializableValue\u00a0and\u00a0decodeSerializableValue. \u6211\u4eec\u539f\u59cb\u00a0<code>Color</code>\u00a0\u7c7b\u7684 KSerializer \u5b9e\u73b0\u5c06\u5728 \u548c\u00a0<code>IntArray</code>\u00a0\u4e4b\u95f4\u00a0<code>Color</code>\u00a0\u6267\u884c\u8f6c\u6362\uff0c\u4f46\u00a0<code>IntArraySerializer</code>\u00a0\u5c06\u5b9e\u9645\u7684\u5e8f\u5217\u5316\u903b\u8f91\u59d4\u6258\u7ed9\u4f7f\u7528 encodeSerializableValue \u548c decodeSerializableValue\u3002</p> <pre><code>import kotlinx.serialization.builtins.IntArraySerializer\n\nclass ColorIntArraySerializer : KSerializer&lt;Color&gt; {\n    private val delegateSerializer = IntArraySerializer()\n    override val descriptor = SerialDescriptor(\"Color\", delegateSerializer.descriptor)\n\n    override fun serialize(encoder: Encoder, value: Color) {\n        val data = intArrayOf(\n            (value.rgb shr 16) and 0xFF,\n            (value.rgb shr 8) and 0xFF,\n            value.rgb and 0xFF\n        )\n        encoder.encodeSerializableValue(delegateSerializer, data)\n    }\n\n    override fun deserialize(decoder: Decoder): Color {\n        val array = decoder.decodeSerializableValue(delegateSerializer)\n        return Color((array[0] shl 16) or (array[1] shl 8) or array[2])\n    }\n}\n</code></pre> <p>Note that we can\u2019t use default\u00a0<code>Color.serializer().descriptor</code>\u00a0here because formats that rely on the schema may think that we would call\u00a0<code>encodeInt</code>\u00a0instead of\u00a0<code>encodeSerializableValue</code>. Neither we can use\u00a0<code>IntArraySerializer().descriptor</code>\u00a0directly \u2014 otherwise, formats that handle int arrays specially can\u2019t tell if\u00a0<code>value</code>\u00a0is really a\u00a0<code>IntArray</code>\u00a0or a\u00a0<code>Color</code>. Don\u2019t worry, this optimization would still kick in when serializing actual underlying int array. \u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u4e0d\u80fd\u5728\u8fd9\u91cc\u4f7f\u7528 default\u00a0<code>Color.serializer().descriptor</code>\u00a0\uff0c\u56e0\u4e3a\u4f9d\u8d56\u4e8e\u67b6\u6784\u7684\u683c\u5f0f\u53ef\u80fd\u4f1a\u8ba4\u4e3a\u6211\u4eec\u4f1a\u8c03\u7528\u00a0<code>encodeInt</code>\u00a0\u800c\u4e0d\u662f\u00a0<code>encodeSerializableValue</code>\u00a0.\u6211\u4eec\u4e5f\u4e0d\u80fd\u76f4\u63a5\u4f7f\u7528\u00a0<code>IntArraySerializer().descriptor</code>\u00a0\u2014\u2014\u5426\u5219\uff0c\u4e13\u95e8\u5904\u7406 int \u6570\u7ec4\u7684\u683c\u5f0f\u65e0\u6cd5\u5224\u65ad\u662f\u5426\u771f\u7684\u00a0<code>value</code>\u00a0\u662f\u00a0<code>Color</code>\u00a0a\u00a0<code>IntArray</code>\u00a0\u6216 .\u522b\u62c5\u5fc3\uff0c\u5728\u5e8f\u5217\u5316\u5b9e\u9645\u5e95\u5c42 int \u6570\u7ec4\u65f6\uff0c\u6b64\u4f18\u5316\u4ecd\u4f1a\u542f\u52a8\u3002</p> <p>Example of how format can treat arrays specially is shown in the\u00a0formats guide. \u683c\u5f0f\u6307\u5357\u4e2d\u663e\u793a\u4e86\u683c\u5f0f\u5982\u4f55\u4e13\u95e8\u5904\u7406\u6570\u7ec4\u7684\u793a\u4f8b\u3002</p> <p>Now we can use the serializer: \u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u5e8f\u5217\u5316\u5668\uff1a</p> <pre><code>@Serializable(with = ColorIntArraySerializer::class)\nclass Color(val rgb: Int)\n\nfun main() {\n    val green = Color(0x00ff00)\n    println(Json.encodeToString(green))\n}  \n</code></pre> <p>As you can see, such array representation is not very useful in JSON, but may save some space when used with a\u00a0<code>ByteArray</code>\u00a0and a binary format. \u5982\u60a8\u6240\u89c1\uff0c\u8fd9\u79cd\u6570\u7ec4\u8868\u793a\u5728 JSON \u4e2d\u4e0d\u662f\u5f88\u6709\u7528\uff0c\u4f46\u5728\u4e0e a\u00a0<code>ByteArray</code>\u00a0\u548c binary \u683c\u5f0f\u4e00\u8d77\u4f7f\u7528\u65f6\u53ef\u80fd\u4f1a\u8282\u7701\u4e00\u4e9b\u7a7a\u95f4\u3002</p> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>[0,255,0]\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#composite-serializer-via-surrogate","title":"Composite serializer via surrogate  \u901a\u8fc7\u4ee3\u7406\u9879\u7684\u590d\u5408\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>Now our challenge is to get\u00a0<code>Color</code>\u00a0serialized so that it is represented in JSON as if it is a class with three properties\u2014<code>r</code>,\u00a0<code>g</code>, and\u00a0<code>b</code>\u2014so that JSON encodes it as an object. The easiest way to achieve this is to define a\u00a0surrogate\u00a0class mimicking the serialized form of\u00a0<code>Color</code>\u00a0that we are going to use for its serialization. We also set the\u00a0SerialName\u00a0of this surrogate class to\u00a0<code>Color</code>. Then if any format uses this name the surrogate looks like it is a\u00a0<code>Color</code>\u00a0class. The surrogate class can be\u00a0<code>private</code>, and can enforce all the constraints on the serial representation of the class in its\u00a0<code>init</code>\u00a0block. \u73b0\u5728\u6211\u4eec\u7684\u6311\u6218\u662f\u00a0<code>Color</code>\u00a0\u5e8f\u5217\u5316\uff0c\u4ee5\u4fbf\u7528 JSON \u8868\u793a\u5b83\uff0c\u5c31\u597d\u50cf\u5b83\u662f\u4e00\u4e2a\u5177\u6709\u4e09\u4e2a\u5c5e\u6027\u7684\u7c7b\u2014\u2014\u00a0<code>r</code>\u00a0\u3001\u00a0<code>g</code>\u00a0\u548c\u00a0<code>b</code>\u00a0\u2014\u2014\uff0c\u4ee5\u4fbf JSON \u5c06\u5176\u7f16\u7801\u4e3a\u5bf9\u8c61\u3002\u5b9e\u73b0\u6b64\u76ee\u7684\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u662f\u5b9a\u4e49\u4e00\u4e2a\u4ee3\u7406\u9879\u7c7b\uff0c\u8be5\u7c7b\u6a21\u4eff\u6211\u4eec\u5c06\u7528\u4e8e\u5176\u5e8f\u5217\u5316\u7684\u5e8f\u5217\u5316\u5f62\u5f0f\u7684\u00a0<code>Color</code>\u00a0\u4ee3\u7406\u9879\u3002\u6211\u4eec\u8fd8\u5c06\u6b64\u4ee3\u7406\u9879\u7c7b\u7684 SerialName \u8bbe\u7f6e\u4e3a\u00a0<code>Color</code>\u00a0\u3002\u7136\u540e\uff0c\u5982\u679c\u4efb\u4f55\u683c\u5f0f\u4f7f\u7528\u6b64\u540d\u79f0\uff0c\u5219\u4ee3\u7406\u9879\u770b\u8d77\u6765\u50cf\u662f\u4e00\u4e2a\u00a0<code>Color</code>\u00a0\u7c7b\u3002\u4ee3\u7406\u9879\u7c7b\u53ef\u4ee5\u662f\u00a0<code>private</code>\u00a0\uff0c\u5e76\u4e14\u53ef\u4ee5\u5bf9\u5176\u00a0<code>init</code>\u00a0\u5757\u4e2d\u7c7b\u7684\u4e32\u884c\u8868\u793a\u5f62\u5f0f\u5f3a\u5236\u6267\u884c\u6240\u6709\u7ea6\u675f\u3002</p> <pre><code>@Serializable\n@SerialName(\"Color\")\nprivate class ColorSurrogate(val r: Int, val g: Int, val b: Int) {\n    init {     \n        require(r in 0..255 &amp;&amp; g in 0..255 &amp;&amp; b in 0..255)\n    }\n}\n</code></pre> <p>An example of where the class name is used is shown in the\u00a0Custom subclass serial name\u00a0section in the chapter on polymorphism. \u591a\u6001\u6027\u4e00\u7ae0\u7684\u201c\u81ea\u5b9a\u4e49\u5b50\u7c7b\u5e8f\u5217\u5316\u540d\u79f0\u201d\u90e8\u5206\u663e\u793a\u4e86\u4f7f\u7528\u7c7b\u540d\u7684\u793a\u4f8b\u3002</p> <p>Now we can use the\u00a0<code>ColorSurrogate.serializer()</code>\u00a0function to retrieve a plugin-generated serializer for the surrogate class. \u73b0\u5728\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u8be5\u00a0<code>ColorSurrogate.serializer()</code>\u00a0\u51fd\u6570\u4e3a\u4ee3\u7406\u9879\u7c7b\u68c0\u7d22\u63d2\u4ef6\u751f\u6210\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002</p> <p>We can use the same approach as in\u00a0delegating serializer, but this time, we are fully reusing an automatically generated\u00a0SerialDescriptor\u00a0for the surrogate because it should be indistinguishable from the original. \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e0e\u59d4\u6d3e\u5e8f\u5217\u5316\u7a0b\u5e8f\u76f8\u540c\u7684\u65b9\u6cd5\uff0c\u4f46\u8fd9\u4e00\u6b21\uff0c\u6211\u4eec\u5c06\u5b8c\u5168\u91cd\u7528\u81ea\u52a8\u751f\u6210\u7684 SerialDescriptor \u4f5c\u4e3a\u4ee3\u7406\u9879\uff0c\u56e0\u4e3a\u5b83\u5e94\u8be5\u4e0e\u539f\u59cb\u63cf\u8ff0\u7b26\u65e0\u6cd5\u533a\u5206\u3002</p> <pre><code>object ColorSerializer : KSerializer&lt;Color&gt; {\n    override val descriptor: SerialDescriptor = ColorSurrogate.serializer().descriptor\n\n    override fun serialize(encoder: Encoder, value: Color) {\n        val surrogate = ColorSurrogate((value.rgb shr 16) and 0xff, (value.rgb shr 8) and 0xff, value.rgb and 0xff)\n        encoder.encodeSerializableValue(ColorSurrogate.serializer(), surrogate)\n    }\n\n    override fun deserialize(decoder: Decoder): Color {\n        val surrogate = decoder.decodeSerializableValue(ColorSurrogate.serializer())\n        return Color((surrogate.r shl 16) or (surrogate.g shl 8) or surrogate.b)\n    }\n}\n</code></pre> <p>We bind the\u00a0<code>ColorSerializer</code>\u00a0serializer to the\u00a0<code>Color</code>\u00a0class. \u6211\u4eec\u5c06\u00a0<code>ColorSerializer</code>\u00a0\u5e8f\u5217\u5316\u7a0b\u5e8f\u7ed1\u5b9a\u5230\u7c7b\u3002\u00a0<code>Color</code></p> <pre><code>@Serializable(with = ColorSerializer::class)\nclass Color(val rgb: Int)\n</code></pre> <p>Now we can enjoy the result of serialization for the\u00a0<code>Color</code>\u00a0class. \u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u4eab\u53d7\u00a0<code>Color</code>\u00a0\u7c7b\u7684\u5e8f\u5217\u5316\u7ed3\u679c\u4e86\u3002</p> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>{\"r\":0,\"g\":255,\"b\":0}\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#hand-written-composite-serializer","title":"Hand-written composite serializer  \u624b\u5199\u590d\u5408\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>There are some cases where a surrogate solution does not fit. Perhaps we want to avoid the performance implications of additional allocation, or we want a configurable/dynamic set of properties for the resulting serial representation. In these cases we need to manually write a class serializer which mimics the behaviour of a generated serializer. \u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u66ff\u4ee3\u89e3\u51b3\u65b9\u6848\u4e0d\u9002\u5408\u3002\u4e5f\u8bb8\u6211\u4eec\u60f3\u907f\u514d\u989d\u5916\u5206\u914d\u5bf9\u6027\u80fd\u7684\u5f71\u54cd\uff0c\u6216\u8005\u6211\u4eec\u60f3\u8981\u4e3a\u751f\u6210\u7684\u4e32\u884c\u8868\u793a\u63d0\u4f9b\u4e00\u7ec4\u53ef\u914d\u7f6e/\u52a8\u6001\u7684\u5c5e\u6027\u3002\u5728\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u9700\u8981\u624b\u52a8\u7f16\u5199\u4e00\u4e2a\u7c7b\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u5b83\u6a21\u4eff\u751f\u6210\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u7684\u884c\u4e3a\u3002</p> <pre><code>object ColorAsObjectSerializer : KSerializer&lt;Color&gt; {\n</code></pre> <p>Let\u2019s introduce it piece by piece. First, a descriptor is defined using the\u00a0buildClassSerialDescriptor\u00a0builder. The\u00a0element\u00a0function in the builder DSL automatically fetches serializers for the corresponding fields by their type. The order of elements is important. They are indexed starting from zero. \u8ba9\u6211\u4eec\u4e00\u70b9\u4e00\u70b9\u5730\u4ecb\u7ecd\u4e00\u4e0b\u3002\u9996\u5148\uff0c\u4f7f\u7528 buildClassSerialDescriptor \u751f\u6210\u5668\u5b9a\u4e49\u63cf\u8ff0\u7b26\u3002\u751f\u6210\u5668 DSL \u4e2d\u7684 element \u51fd\u6570\u4f1a\u6309\u7c7b\u578b\u81ea\u52a8\u83b7\u53d6\u76f8\u5e94\u5b57\u6bb5\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002\u5143\u7d20\u7684\u987a\u5e8f\u5f88\u91cd\u8981\u3002\u5b83\u4eec\u4ece\u96f6\u5f00\u59cb\u7f16\u5236\u7d22\u5f15\u3002</p> <pre><code>    override val descriptor: SerialDescriptor =\n        buildClassSerialDescriptor(\"Color\") {\n            element&lt;Int&gt;(\"r\")\n            element&lt;Int&gt;(\"g\")\n            element&lt;Int&gt;(\"b\")\n        }\n</code></pre> <p>The \u201celement\u201d is a generic term here. What is an element of a descriptor depends on its\u00a0SerialKind. Elements of a class descriptor are its properties, elements of a enum descriptor are its cases, etc. \u201c\u5143\u7d20\u201d\u5728\u8fd9\u91cc\u662f\u4e00\u4e2a\u901a\u7528\u672f\u8bed\u3002\u4ec0\u4e48\u662f\u63cf\u8ff0\u7b26\u7684\u5143\u7d20\u53d6\u51b3\u4e8e\u5176 SerialKind\u3002\u7c7b\u63cf\u8ff0\u7b26\u7684\u5143\u7d20\u662f\u5b83\u7684\u5c5e\u6027\uff0c\u679a\u4e3e\u63cf\u8ff0\u7b26\u7684\u5143\u7d20\u662f\u5b83\u7684\u5927\u5c0f\u5199\uff0c\u7b49\u7b49\u3002</p> <p>Then we write the\u00a0<code>serialize</code>\u00a0function using the\u00a0encodeStructure\u00a0DSL that provides access to the\u00a0CompositeEncoder\u00a0in its block. The difference between\u00a0Encoder\u00a0and\u00a0CompositeEncoder\u00a0is the latter has\u00a0<code>encodeXxxElement</code>\u00a0functions that correspond to the\u00a0<code>encodeXxx</code>\u00a0functions of the former. They must be called in the same order as in the descriptor. \u7136\u540e\uff0c\u6211\u4eec\u4f7f\u7528 encodeStructure DSL \u7f16\u5199\u51fd\u6570\uff0c\u00a0<code>serialize</code>\u00a0\u8be5 DSL \u63d0\u4f9b\u5bf9\u5176\u5757\u4e2d CompositeEncoder \u7684\u8bbf\u95ee\u3002Encoder \u548c CompositeEncoder \u4e4b\u95f4\u7684\u533a\u522b\u5728\u4e8e\u540e\u8005\u5177\u6709\u00a0<code>encodeXxxElement</code>\u00a0\u4e0e\u524d\u8005\u00a0<code>encodeXxx</code>\u00a0\u7684\u529f\u80fd\u76f8\u5bf9\u5e94\u7684\u529f\u80fd\u3002\u5fc5\u987b\u6309\u7167\u63cf\u8ff0\u7b26\u4e2d\u7684\u76f8\u540c\u987a\u5e8f\u8c03\u7528\u5b83\u4eec\u3002</p> <pre><code>    override fun serialize(encoder: Encoder, value: Color) =\n        encoder.encodeStructure(descriptor) {\n            encodeIntElement(descriptor, 0, (value.rgb shr 16) and 0xff)\n            encodeIntElement(descriptor, 1, (value.rgb shr 8) and 0xff)\n            encodeIntElement(descriptor, 2, value.rgb and 0xff)\n        }\n</code></pre> <p>The most complex piece of code is the\u00a0<code>deserialize</code>\u00a0function. It must support formats, like JSON, that can decode properties in an arbitrary order. It starts with the call to\u00a0decodeStructure\u00a0to get access to a\u00a0CompositeDecoder. Inside it we write a loop that repeatedly calls\u00a0decodeElementIndex\u00a0to decode the index of the next element, then we decode the corresponding element using\u00a0decodeIntElement\u00a0in our example, and finally we terminate the loop when\u00a0<code>CompositeDecoder.DECODE_DONE</code>\u00a0is encountered. \u6700\u590d\u6742\u7684\u4ee3\u7801\u662f\u00a0<code>deserialize</code>\u00a0\u51fd\u6570\u3002\u5b83\u5fc5\u987b\u652f\u6301\u53ef\u4ee5\u6309\u4efb\u610f\u987a\u5e8f\u89e3\u7801\u5c5e\u6027\u7684\u683c\u5f0f\uff0c\u4f8b\u5982 JSON\u3002\u5b83\u4ece\u8c03\u7528 decodeStructure \u5f00\u59cb\uff0c\u4ee5\u83b7\u53d6\u5bf9 CompositeDecoder \u7684\u8bbf\u95ee\u6743\u9650\u3002\u5728\u91cc\u9762\uff0c\u6211\u4eec\u7f16\u5199\u4e86\u4e00\u4e2a\u5faa\u73af\uff0c\u53cd\u590d\u8c03\u7528 decodeElementIndex \u6765\u89e3\u7801\u4e0b\u4e00\u4e2a\u5143\u7d20\u7684\u7d22\u5f15\uff0c\u7136\u540e\u6211\u4eec\u5728\u6211\u4eec\u7684\u793a\u4f8b\u4e2d\u4f7f\u7528 decodeIntElement \u89e3\u7801\u76f8\u5e94\u7684\u5143\u7d20\uff0c\u6700\u540e\u5728\u9047\u5230\u5faa\u73af\u65f6\u00a0<code>CompositeDecoder.DECODE_DONE</code>\u00a0\u7ec8\u6b62\u5faa\u73af\u3002</p> <pre><code>    override fun deserialize(decoder: Decoder): Color =\n        decoder.decodeStructure(descriptor) {\n            var r = -1\n            var g = -1\n            var b = -1\n            while (true) {\n                when (val index = decodeElementIndex(descriptor)) {\n                    0 -&gt; r = decodeIntElement(descriptor, 0)\n                    1 -&gt; g = decodeIntElement(descriptor, 1)\n                    2 -&gt; b = decodeIntElement(descriptor, 2)\n                    CompositeDecoder.DECODE_DONE -&gt; break\n                    else -&gt; error(\"Unexpected index: $index\")\n                }\n            }\n            require(r in 0..255 &amp;&amp; g in 0..255 &amp;&amp; b in 0..255)\n            Color((r shl 16) or (g shl 8) or b)\n        }\n</code></pre> <p>Now we bind the resulting serializer to the\u00a0<code>Color</code>\u00a0class and test its serialization/deserialization. \u73b0\u5728\uff0c\u6211\u4eec\u5c06\u751f\u6210\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u7ed1\u5b9a\u5230\u7c7b\u5e76\u00a0<code>Color</code>\u00a0\u6d4b\u8bd5\u5176\u5e8f\u5217\u5316/\u53cd\u5e8f\u5217\u5316\u3002</p> <pre><code>@Serializable(with = ColorAsObjectSerializer::class)\ndata class Color(val rgb: Int)\n\nfun main() {\n    val color = Color(0x00ff00)\n    val string = Json.encodeToString(color) \n    println(string)\n    require(Json.decodeFromString&lt;Color&gt;(string) == color)\n}  \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>As before, we got the\u00a0<code>Color</code>\u00a0class represented as a JSON object with three keys: \u548c\u4ee5\u524d\u4e00\u6837\uff0c\u6211\u4eec\u5c06\u00a0<code>Color</code>\u00a0\u7c7b\u8868\u793a\u4e3a\u5177\u6709\u4e09\u4e2a\u952e\u7684 JSON \u5bf9\u8c61\uff1a</p> <pre><code>{\"r\":0,\"g\":255,\"b\":0}\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#sequential-decoding-protocol-experimental","title":"Sequential decoding protocol (experimental)  \u987a\u5e8f\u89e3\u7801\u534f\u8bae\uff08\u5b9e\u9a8c\u6027\uff09","text":"<p>The implementation of the\u00a0<code>deserialize</code>\u00a0function from the previous section works with any format. However, some formats either always store all the complex data in order, or only do so sometimes (JSON always stores collections in order). With these formats the complex protocol of calling\u00a0<code>decodeElementIndex</code>\u00a0in the loop is not needed, and a faster implementation can be used if the\u00a0CompositeDecoder.decodeSequentially\u00a0function returns\u00a0<code>true</code>. The plugin-generated serializers are actually conceptually similar to the below code. \u4e0a\u4e00\u8282\u00a0<code>deserialize</code>\u00a0\u4e2d\u51fd\u6570\u7684\u5b9e\u73b0\u9002\u7528\u4e8e\u4efb\u4f55\u683c\u5f0f\u3002\u4f46\u662f\uff0c\u67d0\u4e9b\u683c\u5f0f\u8981\u4e48\u59cb\u7ec8\u6309\u987a\u5e8f\u5b58\u50a8\u6240\u6709\u590d\u6742\u6570\u636e\uff0c\u8981\u4e48\u4ec5\u5076\u5c14\u8fd9\u6837\u505a\uff08JSON \u59cb\u7ec8\u6309\u987a\u5e8f\u5b58\u50a8\u96c6\u5408\uff09\u3002\u4f7f\u7528\u8fd9\u4e9b\u683c\u5f0f\uff0c\u4e0d\u9700\u8981\u5728\u5faa\u73af\u4e2d\u8c03\u7528\u00a0<code>decodeElementIndex</code>\u00a0\u7684\u590d\u6742\u534f\u8bae\uff0c\u5982\u679c CompositeDecoder.decodeSequentially \u51fd\u6570\u8fd4\u56de\u00a0<code>true</code>\u00a0\uff0c\u5219\u53ef\u4ee5\u4f7f\u7528\u66f4\u5feb\u7684\u5b9e\u73b0\u3002\u63d2\u4ef6\u751f\u6210\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u5b9e\u9645\u4e0a\u5728\u6982\u5ff5\u4e0a\u7c7b\u4f3c\u4e8e\u4e0b\u9762\u7684\u4ee3\u7801\u3002</p> <pre><code>    override fun deserialize(decoder: Decoder): Color =\n        decoder.decodeStructure(descriptor) {\n            var r = -1\n            var g = -1\n            var b = -1     \n            if (decodeSequentially()) { // sequential decoding protocol\n                r = decodeIntElement(descriptor, 0)           \n                g = decodeIntElement(descriptor, 1)  \n                b = decodeIntElement(descriptor, 2)\n            } else while (true) {\n                when (val index = decodeElementIndex(descriptor)) {\n                    0 -&gt; r = decodeIntElement(descriptor, 0)\n                    1 -&gt; g = decodeIntElement(descriptor, 1)\n                    2 -&gt; b = decodeIntElement(descriptor, 2)\n                    CompositeDecoder.DECODE_DONE -&gt; break\n                    else -&gt; error(\"Unexpected index: $index\")\n                }\n            }\n            require(r in 0..255 &amp;&amp; g in 0..255 &amp;&amp; b in 0..255)\n            Color((r shl 16) or (g shl 8) or b)\n        }\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#serializing-3rd-party-classes","title":"Serializing 3rd party classes  \u5e8f\u5217\u5316\u7b2c\u4e09\u65b9\u7c7b","text":"<p>Sometimes an application has to work with an external type that is not serializable. Let us use\u00a0java.util.Date\u00a0as an example. As before, we start by writing an implementation of\u00a0KSerializer\u00a0for the class. Our goal is to get a\u00a0<code>Date</code>\u00a0serialized as a long number of milliseconds following the approach from the\u00a0Primitive serializer\u00a0section. \u6709\u65f6\uff0c\u5e94\u7528\u7a0b\u5e8f\u5fc5\u987b\u4f7f\u7528\u4e0d\u53ef\u5e8f\u5217\u5316\u7684\u5916\u90e8\u7c7b\u578b\u3002\u8ba9\u6211\u4eec\u4ee5 java.util.Date \u4e3a\u4f8b\u3002\u548c\u4ee5\u524d\u4e00\u6837\uff0c\u6211\u4eec\u9996\u5148\u4e3a\u8be5\u7c7b\u7f16\u5199 KSerializer \u7684\u5b9e\u73b0\u3002\u6211\u4eec\u7684\u76ee\u6807\u662f\u6309\u7167 Primitive \u5e8f\u5217\u5316\u7a0b\u5e8f\u90e8\u5206\u7684\u65b9\u6cd5\u5c06\u5e8f\u5217\u00a0<code>Date</code>\u00a0\u5316\u4e3a\u957f\u6beb\u79d2\u3002</p> <p>In the following sections any kind of\u00a0<code>Date</code>\u00a0serializer would work. For example, if we want\u00a0<code>Date</code>\u00a0to be serialized as an object, we would use an approach from the\u00a0Composite serializer via surrogate\u00a0section. \u5728\u4ee5\u4e0b\u5404\u8282\u4e2d\uff0c\u4efb\u4f55\u7c7b\u578b\u7684\u00a0<code>Date</code>\u00a0\u5e8f\u5217\u5316\u7a0b\u5e8f\u90fd\u53ef\u4ee5\u4f7f\u7528\u3002\u4f8b\u5982\uff0c\u5982\u679c\u6211\u4eec\u60f3\u00a0<code>Date</code>\u00a0\u5e8f\u5217\u5316\u4e3a\u5bf9\u8c61\uff0c\u6211\u4eec\u5c06\u4f7f\u7528 Composite serializer via surrogate \u90e8\u5206\u7684\u65b9\u6cd5\u3002 See also\u00a0Deriving external serializer for another Kotlin class (experimental)\u00a0when you need to serialize a 3rd-party Kotlin class that could have been serializable, but is not. \u53e6\u8bf7\u53c2\u9605 \u5f53\u60a8\u9700\u8981\u5e8f\u5217\u5316\u672c\u6765\u53ef\u4ee5\u5e8f\u5217\u5316\u4f46\u4e0d\u53ef\u5e8f\u5217\u5316\u7684\u7b2c\u4e09\u65b9 Kotlin \u7c7b\u65f6\uff0c\u8bf7\u4e3a\u53e6\u4e00\u4e2a Kotlin \u7c7b\u6d3e\u751f\u5916\u90e8\u5e8f\u5217\u5316\u5668\uff08\u5b9e\u9a8c\u6027\uff09\u3002</p> <pre><code>object DateAsLongSerializer : KSerializer&lt;Date&gt; {\n    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor(\"Date\", PrimitiveKind.LONG)\n    override fun serialize(encoder: Encoder, value: Date) = encoder.encodeLong(value.time)\n    override fun deserialize(decoder: Decoder): Date = Date(decoder.decodeLong())\n}\n</code></pre> <p>We cannot bind the\u00a0<code>DateAsLongSerializer</code>\u00a0serializer to the\u00a0<code>Date</code>\u00a0class with the\u00a0<code>@Serializable</code>\u00a0annotation because we don\u2019t control the\u00a0<code>Date</code>\u00a0source code. There are several ways to work around that. \u6211\u4eec\u65e0\u6cd5\u5c06\u00a0<code>DateAsLongSerializer</code>\u00a0\u5e8f\u5217\u5316\u7a0b\u5e8f\u7ed1\u5b9a\u5230\u5e26\u6709\u00a0<code>@Serializable</code>\u00a0\u6ce8\u91ca\u7684\u7c7b\uff0c\u00a0<code>Date</code>\u00a0\u56e0\u4e3a\u6211\u4eec\u65e0\u6cd5\u63a7\u5236\u00a0<code>Date</code>\u00a0\u6e90\u4ee3\u7801\u3002\u6709\u51e0\u79cd\u65b9\u6cd5\u53ef\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002</p>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#passing-a-serializer-manually","title":"Passing a serializer manually  \u624b\u52a8\u4f20\u9012\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>All\u00a0<code>encodeToXxx</code>\u00a0and\u00a0<code>decodeFromXxx</code>\u00a0functions have an overload with the first serializer parameter. When a non-serializable class, like\u00a0<code>Date</code>, is the top-level class being serialized, we can use those. All\u00a0<code>encodeToXxx</code>\u00a0\u548c\u00a0<code>decodeFromXxx</code>\u00a0functions \u5177\u6709\u7b2c\u4e00\u4e2a\u5e8f\u5217\u5316\u7a0b\u5e8f\u53c2\u6570\u7684\u91cd\u8f7d\u3002\u5f53\u4e0d\u53ef\u5e8f\u5217\u5316\u7684\u7c7b\uff08\u5982\u00a0<code>Date</code>\u00a0\uff09\u662f\u8981\u5e8f\u5217\u5316\u7684\u9876\u7ea7\u7c7b\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u5b83\u4eec\u3002</p> <pre><code>fun main() {                                              \n    val kotlin10ReleaseDate = SimpleDateFormat(\"yyyy-MM-ddX\").parse(\"2016-02-15+00\") \n    println(Json.encodeToString(DateAsLongSerializer, kotlin10ReleaseDate))    \n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>1455494400000\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#specifying-serializer-on-a-property","title":"Specifying serializer on a property  \u5728\u5c5e\u6027\u4e0a\u6307\u5b9a\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>When a property of a non-serializable class, like\u00a0<code>Date</code>, is serialized as part of a serializable class we must supply its serializer or the code will not compile. This is accomplished using the\u00a0<code>@Serializable</code>\u00a0annotation on the property. \u5f53\u4e0d\u53ef\u5e8f\u5217\u5316\u7c7b\u7684\u5c5e\u6027\uff08\u5982\u00a0<code>Date</code>\u00a0\uff09\u4f5c\u4e3a\u53ef\u5e8f\u5217\u5316\u7c7b\u7684\u4e00\u90e8\u5206\u5e8f\u5217\u5316\u65f6\uff0c\u6211\u4eec\u5fc5\u987b\u63d0\u4f9b\u5176\u5e8f\u5217\u5316\u5668\uff0c\u5426\u5219\u4ee3\u7801\u5c06\u65e0\u6cd5\u7f16\u8bd1\u3002\u8fd9\u662f\u4f7f\u7528\u5c5e\u6027\u4e0a\u7684\u00a0<code>@Serializable</code>\u00a0\u6ce8\u91ca\u5b8c\u6210\u7684\u3002</p> <pre><code>@Serializable          \nclass ProgrammingLanguage(\n    val name: String,\n    @Serializable(with = DateAsLongSerializer::class)\n    val stableReleaseDate: Date\n)\n\nfun main() {\n    val data = ProgrammingLanguage(\"Kotlin\", SimpleDateFormat(\"yyyy-MM-ddX\").parse(\"2016-02-15+00\"))\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The\u00a0<code>stableReleaseDate</code>\u00a0property is serialized with the serialization strategy that we specified for it: \u8be5\u00a0<code>stableReleaseDate</code>\u00a0\u5c5e\u6027\u4f7f\u7528\u6211\u4eec\u4e3a\u5176\u6307\u5b9a\u7684\u5e8f\u5217\u5316\u7b56\u7565\u8fdb\u884c\u5e8f\u5217\u5316\uff1a</p> <pre><code>{\"name\":\"Kotlin\",\"stableReleaseDate\":1455494400000}\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#specifying-serializer-for-a-particular-type","title":"Specifying serializer for a particular type  \u4e3a\u7279\u5b9a\u7c7b\u578b\u6307\u5b9a\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p><code>@Serializable</code>\u00a0annotation can also be applied directly to the types. This is handy when a class that requires a custom serializer, such as\u00a0<code>Date</code>, happens to be a generic type argument. The most common use case for that is when you have a list of dates: <code>@Serializable</code>\u00a0\u6ce8\u91ca\u4e5f\u53ef\u4ee5\u76f4\u63a5\u5e94\u7528\u4e8e\u7c7b\u578b\u3002\u5f53\u9700\u8981\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u7684\u7c7b\uff08\u5982\u00a0<code>Date</code>\u00a0\uff09\u6070\u597d\u662f\u6cdb\u578b\u7c7b\u578b\u53c2\u6570\u65f6\uff0c\u8fd9\u5f88\u65b9\u4fbf\u3002\u6700\u5e38\u89c1\u7684\u7528\u4f8b\u662f\u5f53\u60a8\u6709\u4e00\u4e2a\u65e5\u671f\u5217\u8868\u65f6\uff1a</p> <pre><code>@Serializable          \nclass ProgrammingLanguage(\n    val name: String,\n    val releaseDates: List&lt;@Serializable(DateAsLongSerializer::class) Date&gt;\n)\n\nfun main() {\n    val df = SimpleDateFormat(\"yyyy-MM-ddX\")\n    val data = ProgrammingLanguage(\"Kotlin\", listOf(df.parse(\"2023-07-06+00\"), df.parse(\"2023-04-25+00\"), df.parse(\"2022-12-28+00\")))\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>{\"name\":\"Kotlin\",\"releaseDates\":[1688601600000,1682380800000,1672185600000]}\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#specifying-serializers-for-a-file","title":"Specifying serializers for a file  \u6307\u5b9a\u6587\u4ef6\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>A serializer for a specific type, like\u00a0<code>Date</code>, can be specified for a whole source code file with the file-level\u00a0UseSerializers\u00a0annotation at the beginning of the file. \u53ef\u4ee5\u4e3a\u6574\u4e2a\u6e90\u4ee3\u7801\u6587\u4ef6\u6307\u5b9a\u7279\u5b9a\u7c7b\u578b\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u4f8b\u5982\u00a0<code>Date</code>\u00a0\uff0c\u6587\u4ef6\u5f00\u5934\u5e26\u6709\u6587\u4ef6\u7ea7 UseSerializers \u6ce8\u91ca\u3002</p> <pre><code>@file:UseSerializers(DateAsLongSerializer::class)\n</code></pre> <p>Now a\u00a0<code>Date</code>\u00a0property can be used in a serializable class without additional annotations. \u73b0\u5728\uff0c\u53ef\u4ee5\u5728\u53ef\u5e8f\u5217\u5316\u7c7b\u4e2d\u4f7f\u7528\u5c5e\u6027\u00a0<code>Date</code>\u00a0\uff0c\u800c\u65e0\u9700\u6dfb\u52a0\u6ce8\u91ca\u3002</p> <pre><code>@Serializable          \nclass ProgrammingLanguage(val name: String, val stableReleaseDate: Date)\n\nfun main() {\n    val data = ProgrammingLanguage(\"Kotlin\", SimpleDateFormat(\"yyyy-MM-ddX\").parse(\"2016-02-15+00\"))\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>{\"name\":\"Kotlin\",\"stableReleaseDate\":1455494400000}\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#specifying-serializer-globally-using-typealias-typealias","title":"Specifying serializer globally using typealias  \u4f7f\u7528 typealias \u5168\u5c40\u6307\u5b9a\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>kotlinx.serialization tends to be the always-explicit framework when it comes to serialization strategies: normally, they should be explicitly mentioned in\u00a0<code>@Serializable</code>\u00a0annotation. Therefore, we do not provide any kind of global serializer configuration (except for\u00a0context serializer\u00a0mentioned later). \u5f53\u6d89\u53ca\u5230\u5e8f\u5217\u5316\u7b56\u7565\u65f6\uff0ckotlinx.serialization \u5f80\u5f80\u662f\u59cb\u7ec8\u660e\u786e\u7684\u6846\u67b6\uff1a\u901a\u5e38\uff0c\u5b83\u4eec\u5e94\u8be5\u5728\u6ce8\u91ca\u4e2d\u00a0<code>@Serializable</code>\u00a0\u663e\u5f0f\u63d0\u53ca\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u4e0d\u63d0\u4f9b\u4efb\u4f55\u7c7b\u578b\u7684\u5168\u5c40\u5e8f\u5217\u5316\u7a0b\u5e8f\u914d\u7f6e\uff08\u540e\u9762\u63d0\u5230\u7684\u4e0a\u4e0b\u6587\u5e8f\u5217\u5316\u7a0b\u5e8f\u9664\u5916\uff09\u3002</p> <p>However, in projects with a large number of files and classes, it may be too cumbersome to specify\u00a0<code>@file:UseSerializers</code>\u00a0every time, especially for classes like\u00a0<code>Date</code>\u00a0or\u00a0<code>Instant</code>\u00a0that have a fixed strategy of serialization across the project. For such cases, it is possible to specify serializers using\u00a0<code>typealias</code>es, as they preserve annotations, including serialization-related ones: \u4f46\u662f\uff0c\u5728\u5177\u6709\u5927\u91cf\u6587\u4ef6\u548c\u7c7b\u7684\u9879\u76ee\u4e2d\uff0c\u6bcf\u6b21\u90fd\u6307\u5b9a\u00a0<code>@file:UseSerializers</code>\u00a0\u53ef\u80fd\u592a\u9ebb\u70e6\uff0c\u5c24\u5176\u662f\u5bf9\u4e8e\u50cf OR\u00a0<code>Date</code> <code>Instant</code>\u00a0\u8fd9\u6837\u7684\u7c7b\uff0c\u8fd9\u4e9b\u7c7b\u5728\u6574\u4e2a\u9879\u76ee\u4e2d\u5177\u6709\u56fa\u5b9a\u7684\u5e8f\u5217\u5316\u7b56\u7565\u3002\u5bf9\u4e8e\u8fd9\u79cd\u60c5\u51b5\uff0c\u53ef\u4ee5\u4f7f\u7528\u00a0<code>typealias</code>\u00a0es \u6307\u5b9a\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u56e0\u4e3a\u5b83\u4eec\u4f1a\u4fdd\u7559\u6ce8\u91ca\uff0c\u5305\u62ec\u4e0e\u5e8f\u5217\u5316\u76f8\u5173\u7684\u6ce8\u91ca\uff1a</p> <pre><code>typealias DateAsLong = @Serializable(DateAsLongSerializer::class) Date\n\ntypealias DateAsText = @Serializable(DateAsSimpleTextSerializer::class) Date\n</code></pre> <p>Using these new different types, it is possible to serialize a Date differently without additional annotations: \u4f7f\u7528\u8fd9\u4e9b\u65b0\u7684\u4e0d\u540c\u7c7b\u578b\uff0c\u53ef\u4ee5\u5728\u6ca1\u6709\u989d\u5916\u6ce8\u91ca\u7684\u60c5\u51b5\u4e0b\u4ee5\u4e0d\u540c\u7684\u65b9\u5f0f\u5e8f\u5217\u5316 Date\uff1a</p> <pre><code>@Serializable          \nclass ProgrammingLanguage(val stableReleaseDate: DateAsText, val lastReleaseTimestamp: DateAsLong)\n\nfun main() {\n    val format = SimpleDateFormat(\"yyyy-MM-ddX\")\n    val data = ProgrammingLanguage(format.parse(\"2016-02-15+00\"), format.parse(\"2022-07-07+00\"))\n    println(Json.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>{\"stableReleaseDate\":\"2016-02-15\",\"lastReleaseTimestamp\":1657152000000}\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#custom-serializers-for-a-generic-type","title":"Custom serializers for a generic type  \u6cdb\u578b\u7c7b\u578b\u7684\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>Let us take a look at the following example of the generic\u00a0<code>Box&lt;T&gt;</code>\u00a0class. It is marked with\u00a0<code>@Serializable(with = BoxSerializer::class)</code>\u00a0as we plan to have a custom serialization strategy for it. \u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u4e0b\u9762\u7684\u6cdb\u578b\u00a0<code>Box&lt;T&gt;</code>\u00a0\u7c7b\u793a\u4f8b\u3002\u5b83\u88ab\u6807\u8bb0\u4e3a\u00a0<code>@Serializable(with = BoxSerializer::class)</code>\u00a0\u6211\u4eec\u8ba1\u5212\u4e3a\u5176\u5236\u5b9a\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7b56\u7565\u3002</p> <pre><code>@Serializable(with = BoxSerializer::class)\ndata class Box&lt;T&gt;(val contents: T) \n</code></pre> <p>An implementation of\u00a0KSerializer\u00a0for a regular type is written as an\u00a0<code>object</code>, as we saw in this chapter\u2019s examples for the\u00a0<code>Color</code>\u00a0type. A generic class serializer is instantiated with serializers for its generic parameters. We saw this in the\u00a0Plugin-generated generic serializer\u00a0section. A custom serializer for a generic class must be a\u00a0<code>class</code>\u00a0with a constructor that accepts as many\u00a0KSerializer\u00a0parameters as the type has generic parameters. Let us write a\u00a0<code>Box&lt;T&gt;</code>\u00a0serializer that erases itself during serialization, delegating everything to the underlying serializer of its\u00a0<code>data</code>\u00a0property. \u5e38\u89c4\u7c7b\u578b\u7684 KSerializer \u5b9e\u73b0\u88ab\u5199\u6210 \uff0c\u6b63\u5982\u6211\u4eec\u5728\u672c\u7ae0\u7684\u00a0<code>Color</code>\u00a0\u8be5\u7c7b\u578b\u7684\u793a\u4f8b\u4e2d\u770b\u5230\u7684\u90a3\u6837\u00a0<code>object</code>\u00a0\u3002\u6cdb\u578b\u7c7b\u5e8f\u5217\u5316\u7a0b\u5e8f\u4f7f\u7528\u5e8f\u5217\u5316\u7a0b\u5e8f\u5b9e\u4f8b\u5316\u5176\u6cdb\u578b\u53c2\u6570\u3002\u6211\u4eec\u5728\u63d2\u4ef6\u751f\u6210\u7684\u6cdb\u578b\u5e8f\u5217\u5316\u7a0b\u5e8f\u90e8\u5206\u4e2d\u770b\u5230\u4e86\u8fd9\u4e00\u70b9\u3002\u6cdb\u578b\u7c7b\u7684\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u5fc5\u987b\u662f\u00a0<code>class</code>\u00a0\u5177\u6709\u6784\u9020\u51fd\u6570\u7684\u6784\u9020\u51fd\u6570\uff0c\u8be5\u6784\u9020\u51fd\u6570\u63a5\u53d7\u4e0e\u7c7b\u578b\u5177\u6709\u6cdb\u578b\u53c2\u6570\u7684 KSerializer \u53c2\u6570\u4e00\u6837\u591a\u7684 KSerializer \u53c2\u6570\u3002\u8ba9\u6211\u4eec\u7f16\u5199\u4e00\u4e2a\u00a0<code>Box&lt;T&gt;</code>\u00a0\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u8be5\u5e8f\u5217\u5316\u5668\u5728\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\u64e6\u9664\u81ea\u8eab\uff0c\u5c06\u6240\u6709\u5185\u5bb9\u59d4\u6258\u7ed9\u5176\u00a0<code>data</code>\u00a0\u5c5e\u6027\u7684\u57fa\u7840\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002</p> <pre><code>class BoxSerializer&lt;T&gt;(private val dataSerializer: KSerializer&lt;T&gt;) : KSerializer&lt;Box&lt;T&gt;&gt; {\n    override val descriptor: SerialDescriptor = dataSerializer.descriptor\n    override fun serialize(encoder: Encoder, value: Box&lt;T&gt;) = dataSerializer.serialize(encoder, value.contents)\n    override fun deserialize(decoder: Decoder) = Box(dataSerializer.deserialize(decoder))\n}\n</code></pre> <p>Now we can serialize and deserialize\u00a0<code>Box&lt;Project&gt;</code>. \u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u00a0<code>Box&lt;Project&gt;</code>\u00a0\u3002</p> <pre><code>@Serializable\ndata class Project(val name: String)\n\nfun main() {\n    val box = Box(Project(\"kotlinx.serialization\"))\n    val string = Json.encodeToString(box)\n    println(string)\n    println(Json.decodeFromString&lt;Box&lt;Project&gt;&gt;(string))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The resulting JSON looks like the\u00a0<code>Project</code>\u00a0class was serialized directly. \u751f\u6210\u7684 JSON \u770b\u8d77\u6765\u50cf\u662f\u00a0<code>Project</code>\u00a0\u76f4\u63a5\u5e8f\u5217\u5316\u7684\u7c7b\u3002</p> <pre><code>{\"name\":\"kotlinx.serialization\"}\nBox(contents=Project(name=kotlinx.serialization))\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#format-specific-serializers","title":"Format-specific serializers  \u7279\u5b9a\u4e8e\u683c\u5f0f\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<p>The above custom serializers worked in the same way for every format. However, there might be format-specific features that a serializer implementation would like to take advantage of. \u4e0a\u8ff0\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u5bf9\u6bcf\u79cd\u683c\u5f0f\u90fd\u4ee5\u76f8\u540c\u7684\u65b9\u5f0f\u5de5\u4f5c\u3002\u4f46\u662f\uff0c\u5e8f\u5217\u5316\u7a0b\u5e8f\u5b9e\u73b0\u53ef\u80fd\u5e0c\u671b\u5229\u7528\u7279\u5b9a\u4e8e\u683c\u5f0f\u7684\u529f\u80fd\u3002</p> <ul> <li> <p>The\u00a0Json transformations\u00a0section of the\u00a0Json\u00a0chapter provides examples of serializers that utilize JSON-specific features.     Json \u4e00\u7ae0\u7684 Json \u8f6c\u6362\u90e8\u5206\u63d0\u4f9b\u4e86\u5229\u7528 JSON \u7279\u5b9a\u529f\u80fd\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u7684\u793a\u4f8b\u3002</p> </li> <li> <p>A format implementation can have a format-specific representation for a type as explained in the\u00a0Format-specific types\u00a0section of the\u00a0Alternative and custom formats (experimental)\u00a0chapter.     \u683c\u5f0f\u5b9e\u73b0\u53ef\u4ee5\u5177\u6709\u7279\u5b9a\u4e8e\u7c7b\u578b\u7684\u683c\u5f0f\u8868\u793a\u5f62\u5f0f\uff0c\u5982\u66ff\u4ee3\u683c\u5f0f\u548c\u81ea\u5b9a\u4e49\u683c\u5f0f\uff08\u5b9e\u9a8c\uff09\u4e00\u7ae0\u7684\u7279\u5b9a\u4e8e\u683c\u5f0f\u7684\u7c7b\u578b\u90e8\u5206\u6240\u8ff0\u3002</p> </li> </ul> <p>This chapter proceeds with a generic approach to tweaking the serialization strategy based on the context. \u672c\u7ae0\u7ee7\u7eed\u91c7\u7528\u4e00\u79cd\u901a\u7528\u65b9\u6cd5\uff0c\u6839\u636e\u4e0a\u4e0b\u6587\u8c03\u6574\u5e8f\u5217\u5316\u7b56\u7565\u3002</p>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#contextual-serialization","title":"Contextual serialization\u00a0\u4e0a\u4e0b\u6587\u5e8f\u5217\u5316","text":"<p>All the previous approaches to specifying custom serialization strategies were\u00a0static, that is fully defined at compile-time. The exception was the\u00a0Passing a serializer manually\u00a0approach, but it worked only on a top-level object. You might need to change the serialization strategy for objects deep in the serialized object tree at run-time, with the strategy being selected in a context-dependent way. For example, you might want to represent\u00a0<code>java.util.Date</code>\u00a0in JSON format as an ISO 8601 string or as a long integer depending on a version of a protocol you are serializing data for. This is called\u00a0contextual\u00a0serialization, and it is supported by a built-in\u00a0ContextualSerializer\u00a0class. Usually we don\u2019t have to use this serializer class explicitly\u2014there is the\u00a0Contextual\u00a0annotation providing a shortcut to the\u00a0<code>@Serializable(with = ContextualSerializer::class)</code>\u00a0annotation, or the\u00a0UseContextualSerialization\u00a0annotation can be used at the file-level just like the\u00a0UseSerializers\u00a0annotation. Let\u2019s see an example utilizing the former.  </p> <p>\u4ee5\u524d\u6240\u6709\u6307\u5b9a\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7b56\u7565\u7684\u65b9\u6cd5\u90fd\u662f\u9759\u6001\u7684\uff0c\u5728\u7f16\u8bd1\u65f6\u5b8c\u5168\u5b9a\u4e49\u3002\u4f8b\u5916\u60c5\u51b5\u662f\u624b\u52a8\u4f20\u9012\u5e8f\u5217\u5316\u7a0b\u5e8f\u65b9\u6cd5\uff0c\u4f46\u5b83\u4ec5\u9002\u7528\u4e8e\u9876\u7ea7\u5bf9\u8c61\u3002\u60a8\u53ef\u80fd\u9700\u8981\u5728\u8fd0\u884c\u65f6\u66f4\u6539\u5e8f\u5217\u5316\u5bf9\u8c61\u6811\u6df1\u5904\u5bf9\u8c61\u7684\u5e8f\u5217\u5316\u7b56\u7565\uff0c\u5e76\u4ee5\u4e0a\u4e0b\u6587\u76f8\u5173\u7684\u65b9\u5f0f\u9009\u62e9\u8be5\u7b56\u7565\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u5e0c\u671b\u4ee5 JSON \u683c\u5f0f\u8868\u793a\u00a0<code>java.util.Date</code>\u00a0\u4e3a ISO 8601 \u5b57\u7b26\u4e32\u6216\u957f\u6574\u6570\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u8981\u5e8f\u5217\u5316\u6570\u636e\u7684\u534f\u8bae\u7248\u672c\u3002\u8fd9\u79f0\u4e3a\u4e0a\u4e0b\u6587\u5e8f\u5217\u5316\uff0c\u5b83\u7531\u5185\u7f6e\u7684 ContextualSerializer \u7c7b\u652f\u6301\u3002\u901a\u5e38\uff0c\u6211\u4eec\u4e0d\u5fc5\u663e\u5f0f\u4f7f\u7528\u6b64\u5e8f\u5217\u5316\u7a0b\u5e8f\u7c7b - \u6709 Contextual \u6ce8\u91ca\u63d0\u4f9b\u6ce8\u91ca\u7684\u5feb\u6377\u65b9\u5f0f\u00a0<code>@Serializable(with = ContextualSerializer::class)</code>\u00a0\uff0c\u6216\u8005 UseContextualSerialization \u6ce8\u91ca\u53ef\u4ee5\u5728\u6587\u4ef6\u7ea7\u522b\u4f7f\u7528\uff0c\u5c31\u50cf UseSerializers \u6ce8\u91ca\u4e00\u6837\u3002\u8ba9\u6211\u4eec\u770b\u4e00\u4e2a\u4f7f\u7528\u524d\u8005\u7684\u4f8b\u5b50\u3002</p> <pre><code>@Serializable          \nclass ProgrammingLanguage(\n    val name: String,\n    @Contextual \n    val stableReleaseDate: Date\n)\n</code></pre> <p>To actually serialize this class we must provide the corresponding context when calling the\u00a0<code>encodeToXxx</code>/<code>decodeFromXxx</code>\u00a0functions. Without it we\u2019ll get a \u201cSerializer for class \u2018Date\u2019 is not found\u201d exception. \u4e3a\u4e86\u5b9e\u9645\u5e8f\u5217\u5316\u6b64\u7c7b\uff0c\u00a0<code>encodeToXxx</code>\u00a0\u6211\u4eec\u5fc5\u987b\u5728\u8c03\u7528 /\u00a0<code>decodeFromXxx</code>\u00a0\u51fd\u6570\u65f6\u63d0\u4f9b\u76f8\u5e94\u7684\u4e0a\u4e0b\u6587\u3002\u5982\u679c\u6ca1\u6709\u5b83\uff0c\u6211\u4eec\u5c06\u5f97\u5230\u201c\u627e\u4e0d\u5230\u7c7b\u2019Date\u2019\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u201d\u5f02\u5e38\u3002</p> <p>See\u00a0here\u00a0for an example that produces that exception. \u6709\u5173\u751f\u6210\u8be5\u5f02\u5e38\u7684\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605\u6b64\u5904\u3002</p>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#serializers-module","title":"Serializers module\u00a0\u5e8f\u5217\u5316\u6a21\u5757","text":"<p>To provide a context, we define a\u00a0SerializersModule\u00a0instance that describes which serializers shall be used at run-time to serialize which contextually-serializable classes. This is done using the\u00a0SerializersModule {}\u00a0builder function, which provides the\u00a0SerializersModuleBuilder\u00a0DSL to register serializers. In the below example we use the\u00a0contextual\u00a0function with the serializer. The corresponding class this serializer is defined for is fetched automatically via the\u00a0<code>reified</code>\u00a0type parameter. \u4e3a\u4e86\u63d0\u4f9b\u4e0a\u4e0b\u6587\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86\u4e00\u4e2a SerializersModule \u5b9e\u4f8b\uff0c\u8be5\u5b9e\u4f8b\u63cf\u8ff0\u5728\u8fd0\u884c\u65f6\u5e94\u4f7f\u7528\u54ea\u4e9b\u5e8f\u5217\u5316\u7a0b\u5e8f\u6765\u5e8f\u5217\u5316\u54ea\u4e9b\u4e0a\u4e0b\u6587\u53ef\u5e8f\u5217\u5316\u7684\u7c7b\u3002\u8fd9\u662f\u4f7f\u7528 SerializersModule {} \u751f\u6210\u5668\u51fd\u6570\u5b8c\u6210\u7684\uff0c\u8be5\u51fd\u6570\u63d0\u4f9b SerializersModuleBuilder DSL \u6765\u6ce8\u518c\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002\u5728\u4e0b\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u5c06\u4e0a\u4e0b\u6587\u51fd\u6570\u4e0e\u5e8f\u5217\u5316\u7a0b\u5e8f\u4e00\u8d77\u4f7f\u7528\u3002\u4e3a\u6b64\u5e8f\u5217\u5316\u7a0b\u5e8f\u5b9a\u4e49\u7684\u76f8\u5e94\u7c7b\u662f\u901a\u8fc7\u00a0<code>reified</code>\u00a0type \u53c2\u6570\u81ea\u52a8\u63d0\u53d6\u7684\u3002</p> <pre><code>private val module = SerializersModule { \n    contextual(DateAsLongSerializer)\n}\n</code></pre> <p>Next we create an instance of the\u00a0Json\u00a0format with this module using the\u00a0Json {}\u00a0builder function and the\u00a0serializersModule\u00a0property. \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4f7f\u7528 Json {} builder \u51fd\u6570\u548c serializersModule \u5c5e\u6027\u4f7f\u7528\u6b64\u6a21\u5757\u521b\u5efa Json \u683c\u5f0f\u7684\u5b9e\u4f8b\u3002</p> <p>Details on custom JSON configurations can be found in the\u00a0JSON configuration\u00a0section. \u6709\u5173\u81ea\u5b9a\u4e49 JSON \u914d\u7f6e\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 JSON \u914d\u7f6e\u90e8\u5206\u3002</p> <pre><code>val format = Json { serializersModule = module }\n</code></pre> <p>Now we can serialize our data with this\u00a0<code>format</code>. \u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u7528\u8fd9\u4e2a\u00a0<code>format</code>\u00a0\u5e8f\u5217\u5316\u6211\u4eec\u7684\u6570\u636e\u3002</p> <pre><code>fun main() {\n    val data = ProgrammingLanguage(\"Kotlin\", SimpleDateFormat(\"yyyy-MM-ddX\").parse(\"2016-02-15+00\"))\n    println(format.encodeToString(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>{\"name\":\"Kotlin\",\"stableReleaseDate\":1455494400000}\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#contextual-serialization-and-generic-classes","title":"Contextual serialization and generic classes  \u4e0a\u4e0b\u6587\u5e8f\u5217\u5316\u548c\u6cdb\u578b\u7c7b","text":"<p>In the previous section we saw that we can register serializer instance in the module for a class we want to serialize contextually. We also know that\u00a0serializers for generic classes have constructor parameters\u00a0\u2014 type arguments serializers. It means that we can\u2019t use one serializer instance for a class if this class is generic: \u5728\u4e0a\u4e00\u8282\u4e2d\uff0c\u6211\u4eec\u770b\u5230\u6211\u4eec\u53ef\u4ee5\u5728\u6a21\u5757\u4e2d\u4e3a\u8981\u5728\u4e0a\u4e0b\u6587\u4e2d\u5e8f\u5217\u5316\u7684\u7c7b\u6ce8\u518c\u5e8f\u5217\u5316\u7a0b\u5e8f\u5b9e\u4f8b\u3002\u6211\u4eec\u8fd8\u77e5\u9053\u6cdb\u578b\u7c7b\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u5177\u6709\u6784\u9020\u51fd\u6570\u53c2\u6570 \u2014 \u7c7b\u578b\u53c2\u6570\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002\u8fd9\u610f\u5473\u7740\u5982\u679c\u4e00\u4e2a\u7c7b\u662f\u6cdb\u578b\u7684\uff0c\u6211\u4eec\u4e0d\u80fd\u4e3a\u4e00\u4e2a\u7c7b\u4f7f\u7528\u4e00\u4e2a\u5e8f\u5217\u5316\u7a0b\u5e8f\u5b9e\u4f8b\uff1a</p> <pre><code>val incorrectModule = SerializersModule {\n    // Can serialize only Box&lt;Int&gt;, but not Box&lt;String&gt; or others\n    contextual(BoxSerializer(Int.serializer()))\n}\n</code></pre> <p>For cases when one want to serialize contextually a generic class, it is possible to register provider in the module: \u5bf9\u4e8e\u60f3\u8981\u5728\u4e0a\u4e0b\u6587\u4e2d\u5e8f\u5217\u5316\u6cdb\u578b\u7c7b\u7684\u60c5\u51b5\uff0c\u53ef\u4ee5\u5728\u6a21\u5757\u4e2d\u6ce8\u518c\u63d0\u4f9b\u7a0b\u5e8f\uff1a</p> <pre><code>val correctModule = SerializersModule {\n    // args[0] contains Int.serializer() or String.serializer(), depending on the usage\n    contextual(Box::class) { args -&gt; BoxSerializer(args[0]) } \n}\n</code></pre> <p>Additional details on serialization modules are given in the\u00a0Merging library serializers modules\u00a0section of the\u00a0Polymorphism\u00a0chapter. \u6709\u5173\u5e8f\u5217\u5316\u6a21\u5757\u7684\u5176\u4ed6\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 Polymorphism \u4e00\u7ae0\u7684\u5408\u5e76\u5e93\u5e8f\u5217\u5316\u7a0b\u5e8f\u6a21\u5757\u90e8\u5206\u3002</p>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#deriving-external-serializer-for-another-kotlin-class-experimental-kotlin","title":"Deriving external serializer for another Kotlin class (experimental)  \u4e3a\u53e6\u4e00\u4e2a Kotlin \u7c7b\u6d3e\u751f\u5916\u90e8\u5e8f\u5217\u5316\u7a0b\u5e8f\uff08\u5b9e\u9a8c\u6027\uff09","text":"<p>If a 3rd-party class to be serialized is a Kotlin class with a properties-only primary constructor, a kind of class which could have been made\u00a0<code>@Serializable</code>, then you can generate an\u00a0external\u00a0serializer for it using the\u00a0Serializer\u00a0annotation on an object with the\u00a0<code>forClass</code>\u00a0property. \u5982\u679c\u8981\u5e8f\u5217\u5316\u7684\u7b2c\u4e09\u65b9\u7c7b\u662f\u5177\u6709\u4ec5\u5c5e\u6027\u4e3b\u6784\u9020\u51fd\u6570\u7684 Kotlin \u7c7b\uff0c\u8fd9\u662f\u4e00\u79cd\u53ef\u4ee5\u521b\u5efa\u00a0<code>@Serializable</code>\u00a0\u7684\u7c7b\uff0c\u90a3\u4e48\u60a8\u53ef\u4ee5\u4f7f\u7528\u5177\u6709\u8be5\u00a0<code>forClass</code>\u00a0\u5c5e\u6027\u7684\u5bf9\u8c61\u4e0a\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u6ce8\u91ca\u4e3a\u5176\u751f\u6210\u5916\u90e8\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002</p> <pre><code>// NOT @Serializable\nclass Project(val name: String, val language: String)\n\n@Serializer(forClass = Project::class)\nobject ProjectSerializer\n</code></pre> <p>You must bind this serializer to a class using one of the approaches explained in this chapter. We\u2019ll follow the\u00a0Passing a serializer manually\u00a0approach for this example. \u5fc5\u987b\u4f7f\u7528\u672c\u7ae0\u4e2d\u4ecb\u7ecd\u7684\u65b9\u6cd5\u4e4b\u4e00\u5c06\u6b64\u5e8f\u5217\u5316\u7a0b\u5e8f\u7ed1\u5b9a\u5230\u7c7b\u3002\u5bf9\u4e8e\u6b64\u793a\u4f8b\uff0c\u6211\u4eec\u5c06\u9075\u5faa\u624b\u52a8\u4f20\u9012\u5e8f\u5217\u5316\u7a0b\u5e8f\u65b9\u6cd5\u3002</p> <pre><code>fun main() {\n    val data = Project(\"kotlinx.serialization\", \"Kotlin\")\n    println(Json.encodeToString(ProjectSerializer, data))    \n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>This gets all the\u00a0<code>Project</code>\u00a0properties serialized: \u8fd9\u5c06\u4f7f\u6240\u6709\u00a0<code>Project</code>\u00a0\u5c5e\u6027\u5e8f\u5217\u5316\uff1a</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"language\":\"Kotlin\"}\n</code></pre>"},{"location":"%E5%BA%8F%E5%88%97%E5%8C%96%E7%A8%8B%E5%BA%8F-3/#external-serialization-uses-properties","title":"External serialization uses properties  \u5916\u90e8\u5e8f\u5217\u5316\u4f7f\u7528\u5c5e\u6027","text":"<p>As we saw earlier, the regular\u00a0<code>@Serializable</code>\u00a0annotation creates a serializer so that\u00a0Backing fields are serialized.\u00a0External\u00a0serialization using\u00a0<code>Serializer(forClass = ...)</code>\u00a0has no access to backing fields and works differently. It serializes only\u00a0accessible\u00a0properties that have setters or are part of the primary constructor. The following example shows this. \u6b63\u5982\u6211\u4eec\u4e4b\u524d\u6240\u770b\u5230\u7684\uff0c\u5e38\u89c4\u00a0<code>@Serializable</code>\u00a0\u6ce8\u91ca\u4f1a\u521b\u5efa\u4e00\u4e2a\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u4ee5\u4fbf\u5e8f\u5217\u5316 Backing \u5b57\u6bb5\u3002\u5916\u90e8\u5e8f\u5217\u5316\u4f7f\u7528\u00a0<code>Serializer(forClass = ...)</code>\u00a0\u65e0\u6cd5\u8bbf\u95ee\u540e\u5907\u5b57\u6bb5\uff0c\u5e76\u4e14\u5de5\u4f5c\u65b9\u5f0f\u4e0d\u540c\u3002\u5b83\u4ec5\u5e8f\u5217\u5316\u5177\u6709 setter \u6216\u5c5e\u4e8e\u4e3b\u6784\u9020\u51fd\u6570\u7684\u53ef\u8bbf\u95ee\u5c5e\u6027\u3002\u4ee5\u4e0b\u793a\u4f8b\u6f14\u793a\u4e86\u8fd9\u4e00\u70b9\u3002</p> <pre><code>// NOT @Serializable, will use external serializer\nclass Project(\n    // val in a primary constructor -- serialized\n    val name: String\n) {\n    var stars: Int = 0 // property with getter &amp; setter -- serialized\n\n    val path: String // getter only -- not serialized\n        get() = \"kotlin/$name\"                                         \n\n    private var locked: Boolean = false // private, not accessible -- not serialized \n}              \n\n@Serializer(forClass = Project::class)\nobject ProjectSerializer\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\").apply { stars = 9000 }\n    println(Json.encodeToString(ProjectSerializer, data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The output is shown below. \u8f93\u51fa\u5982\u4e0b\u6240\u793a\u3002</p> <pre><code>{\"name\":\"kotlinx.serialization\",\"stars\":9000}\n</code></pre> <p>The next chapter covers\u00a0Polymorphism. \u4e0b\u4e00\u7ae0\u5c06\u4ecb\u7ecd\u591a\u6001\u6027\u3002</p>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/","title":"Alternative and custom formats (experimental)","text":"<p>\u66ff\u4ee3\u683c\u5f0f\u548c\u81ea\u5b9a\u4e49\u683c\u5f0f\uff08\u5b9e\u9a8c\u6027\uff09</p> <p></p> <p>This is the sixth chapter of the\u00a0Kotlin Serialization Guide. It goes beyond JSON, covering alternative and custom formats. Unlike JSON, which is stable, these are currently experimental features of Kotlin Serialization. \u8fd9\u662f\u300aKotlin \u5e8f\u5217\u5316\u6307\u5357\u300b\u7684\u7b2c\u516d\u7ae0\u3002\u5b83\u8d85\u8d8a\u4e86 JSON\uff0c\u6db5\u76d6\u4e86\u66ff\u4ee3\u548c\u81ea\u5b9a\u4e49\u683c\u5f0f\u3002\u4e0e\u7a33\u5b9a\u7684 JSON \u4e0d\u540c\uff0c\u8fd9\u4e9b\u76ee\u524d\u662f Kotlin \u5e8f\u5217\u5316\u7684\u5b9e\u9a8c\u6027\u529f\u80fd\u3002</p> <p>Table of contents\u00a0\u76ee\u5f55</p> <ul> <li>CBOR (experimental)\u00a0CBOR\uff08\u5b9e\u9a8c\u6027\uff09<ul> <li>Ignoring unknown keys\u00a0\u5ffd\u7565\u672a\u77e5\u952e</li> <li>Byte arrays and CBOR data types     \u5b57\u8282\u6570\u7ec4\u548c CBOR \u6570\u636e\u7c7b\u578b</li> </ul> </li> <li>ProtoBuf (experimental)     ProtoBuf\uff08\u5b9e\u9a8c\u6027\uff09<ul> <li>Field numbers\u00a0\u5b57\u6bb5\u7f16\u53f7</li> <li>Integer types\u00a0\u6574\u6570\u7c7b\u578b</li> <li>Lists as repeated fields     \u4f5c\u4e3a\u91cd\u590d\u5b57\u6bb5\u5217\u51fa</li> <li>Packed fields\u00a0\u586b\u5145\u5b57\u6bb5</li> <li>ProtoBuf schema generator (experimental)     ProtoBuf \u6a21\u5f0f\u751f\u6210\u5668\uff08\u5b9e\u9a8c\u6027\uff09</li> </ul> </li> <li>Properties (experimental)     \u5c5e\u6027\uff08\u5b9e\u9a8c\u6027\uff09</li> <li>Custom formats (experimental)     \u81ea\u5b9a\u4e49\u683c\u5f0f\uff08\u5b9e\u9a8c\u6027\uff09<ul> <li>Basic encoder\u00a0\u57fa\u672c\u7f16\u7801\u5668</li> <li>Basic decoder\u00a0\u57fa\u672c\u89e3\u7801\u5668</li> <li>Sequential decoding\u00a0\u987a\u5e8f\u89e3\u7801</li> <li>Adding collection support     \u6dfb\u52a0\u96c6\u5408\u652f\u6301</li> <li>Adding null support\u00a0\u6dfb\u52a0 null \u652f\u6301</li> <li>Efficient binary format\u00a0\u9ad8\u6548\u7684\u4e8c\u8fdb\u5236\u683c\u5f0f</li> <li>Format-specific types\u00a0\u7279\u5b9a\u4e8e\u683c\u5f0f\u7684\u7c7b\u578b</li> </ul> </li> </ul>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#cbor-experimental-cbor","title":"CBOR (experimental)\u00a0CBOR\uff08\u5b9e\u9a8c\u6027\uff09","text":"<p>CBOR\u00a0is one of the standard compact binary encodings for JSON, so it supports a subset of\u00a0JSON features\u00a0and is generally very similar to JSON in use, but produces binary data. CBOR \u662f JSON \u7684\u6807\u51c6\u7d27\u51d1\u4e8c\u8fdb\u5236\u7f16\u7801\u4e4b\u4e00\uff0c\u56e0\u6b64\u5b83\u652f\u6301 JSON \u529f\u80fd\u7684\u5b50\u96c6\uff0c\u5e76\u4e14\u901a\u5e38\u4e0e\u4f7f\u7528\u7684 JSON \u975e\u5e38\u76f8\u4f3c\uff0c\u4f46\u4f1a\u4ea7\u751f\u4e8c\u8fdb\u5236\u6570\u636e\u3002</p> <p>CBOR support is (experimentally) available in a separate\u00a0<code>org.jetbrains.kotlinx:kotlinx-serialization-cbor:&lt;version&gt;</code>\u00a0module. CBOR\u652f\u6301\uff08\u5b9e\u9a8c\u6027\u5730\uff09\u5728\u4e00\u4e2a\u5355\u72ec\u7684\u00a0<code>org.jetbrains.kotlinx:kotlinx-serialization-cbor:&lt;version&gt;</code>\u00a0\u6a21\u5757\u4e2d\u53ef\u7528\u3002</p> <p>Cbor\u00a0class has\u00a0Cbor.encodeToByteArray\u00a0and\u00a0Cbor.decodeFromByteArray\u00a0functions. Let us take the basic example from the\u00a0JSON encoding, but encode it using CBOR. Cbor \u7c7b\u5177\u6709 Cbor.encodeToByteArray \u548c Cbor.decodeFromByteArray \u51fd\u6570\u3002\u8ba9\u6211\u4eec\u4eceJSON\u7f16\u7801\u4e2d\u83b7\u53d6\u57fa\u672c\u793a\u4f8b\uff0c\u4f46\u4f7f\u7528CBOR\u5bf9\u5176\u8fdb\u884c\u7f16\u7801\u3002</p> <pre><code>@Serializable\ndata class Project(val name: String, val language: String)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\", \"Kotlin\") \n    val bytes = Cbor.encodeToByteArray(data)   \n    println(bytes.toAsciiHexString())\n    val obj = Cbor.decodeFromByteArray&lt;Project&gt;(bytes)\n    println(obj)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>We print a filtered ASCII representation of the output, writing non-ASCII data in hex, so we see how all the original strings are directly represented in CBOR, but the format delimiters themselves are binary. \u6211\u4eec\u6253\u5370\u8f93\u51fa\u7684\u8fc7\u6ee4 ASCII \u8868\u793a\uff0c\u4ee5\u5341\u516d\u8fdb\u5236\u5199\u5165\u975e ASCII \u6570\u636e\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u6240\u6709\u539f\u59cb\u5b57\u7b26\u4e32\u5982\u4f55\u76f4\u63a5\u5728 CBOR \u4e2d\u8868\u793a\uff0c\u4f46\u683c\u5f0f\u5206\u9694\u7b26\u672c\u8eab\u662f\u4e8c\u8fdb\u5236\u7684\u3002</p> <pre><code>{BF}dnameukotlinx.serializationhlanguagefKotlin{FF}\nProject(name=kotlinx.serialization, language=Kotlin)\n</code></pre> <p>In\u00a0CBOR hex notation, the output is equivalent to the following: \u5728 CBOR \u5341\u516d\u8fdb\u5236\u8868\u793a\u6cd5\u4e2d\uff0c\u8f93\u51fa\u7b49\u6548\u4e8e\u4ee5\u4e0b\u5185\u5bb9\uff1a</p> <pre><code>BF                                      # map(*)\n   64                                   # text(4)\n      6E616D65                          # \"name\"\n   75                                   # text(21)\n      6B6F746C696E782E73657269616C697A6174696F6E # \"kotlinx.serialization\"\n   68                                   # text(8)\n      6C616E6775616765                  # \"language\"\n   66                                   # text(6)\n      4B6F746C696E                      # \"Kotlin\"\n   FF                                   # primitive(*)\n</code></pre> <p>Note, CBOR as a format, unlike JSON, supports maps with non-trivial keys (see the\u00a0Allowing structured map keys\u00a0section for JSON workarounds), and Kotlin maps are serialized as CBOR maps, but some parsers (like\u00a0<code>jackson-dataformat-cbor</code>) don\u2019t support this. \u8bf7\u6ce8\u610f\uff0c\u4e0e JSON \u4e0d\u540c\uff0cCBOR \u4f5c\u4e3a\u4e00\u79cd\u683c\u5f0f\u652f\u6301\u5177\u6709\u975e\u5e73\u51e1\u952e\u7684\u6620\u5c04\uff08\u6709\u5173 JSON \u89e3\u51b3\u65b9\u6cd5\uff0c\u8bf7\u53c2\u9605\u5141\u8bb8\u7ed3\u6784\u5316\u6620\u5c04\u952e\u90e8\u5206\uff09\uff0c\u5e76\u4e14 Kotlin \u6620\u5c04\u5e8f\u5217\u5316\u4e3a CBOR \u6620\u5c04\uff0c\u4f46\u67d0\u4e9b\u89e3\u6790\u5668\uff08\u5982\u00a0<code>jackson-dataformat-cbor</code>\u00a0\uff09\u4e0d\u652f\u6301\u6b64\u529f\u80fd\u3002</p>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#ignoring-unknown-keys","title":"Ignoring unknown keys\u00a0\u5ffd\u7565\u672a\u77e5\u952e","text":"<p>CBOR format is often used to communicate with\u00a0IoT\u00a0devices where new properties could be added as a part of a device\u2019s API evolution. By default, unknown keys encountered during deserialization produce an error. This behavior can be configured with the\u00a0ignoreUnknownKeys\u00a0property. CBOR \u683c\u5f0f\u901a\u5e38\u7528\u4e8e\u4e0e IoT \u8bbe\u5907\u901a\u4fe1\uff0c\u5176\u4e2d\u53ef\u4ee5\u6dfb\u52a0\u65b0\u5c5e\u6027\u4f5c\u4e3a\u8bbe\u5907 API \u6f14\u8fdb\u7684\u4e00\u90e8\u5206\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5728\u53cd\u5e8f\u5217\u5316\u8fc7\u7a0b\u4e2d\u9047\u5230\u7684\u672a\u77e5\u952e\u4f1a\u751f\u6210\u9519\u8bef\u3002\u53ef\u4ee5\u4f7f\u7528 ignoreUnknownKeys \u5c5e\u6027\u914d\u7f6e\u6b64\u884c\u4e3a\u3002</p> <pre><code>val format = Cbor { ignoreUnknownKeys = true }\n\n@Serializable\ndata class Project(val name: String)\n\nfun main() {\n    val data = format.decodeFromHexString&lt;Project&gt;(\n        \"bf646e616d65756b6f746c696e782e73657269616c697a6174696f6e686c616e6775616765664b6f746c696eff\"\n    )\n    println(data)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>It decodes the object, despite the fact that\u00a0<code>Project</code>\u00a0is missing the\u00a0<code>language</code>\u00a0property. \u5b83\u89e3\u7801\u5bf9\u8c61\uff0c\u5c3d\u7ba1\u7f3a\u5c11\u00a0<code>Project</code> <code>language</code>\u00a0\u8be5\u5c5e\u6027\u3002</p> <pre><code>Project(name=kotlinx.serialization)\n</code></pre> <p>In\u00a0CBOR hex notation, the input is equivalent to the following: \u5728 CBOR \u5341\u516d\u8fdb\u5236\u8868\u793a\u6cd5\u4e2d\uff0c\u8f93\u5165\u7b49\u6548\u4e8e\u4ee5\u4e0b\u5185\u5bb9\uff1a</p> <pre><code>BF                                      # map(*)\n   64                                   # text(4)\n      6E616D65                          # \"name\"\n   75                                   # text(21)\n      6B6F746C696E782E73657269616C697A6174696F6E # \"kotlinx.serialization\"\n   68                                   # text(8)\n      6C616E6775616765                  # \"language\"\n   66                                   # text(6)\n      4B6F746C696E                      # \"Kotlin\"\n   FF                                   # primitive(*)\n</code></pre>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#byte-arrays-and-cbor-data-types","title":"Byte arrays and CBOR data types","text":"<p>\u5b57\u8282\u6570\u7ec4\u548c CBOR \u6570\u636e\u7c7b\u578b</p> <p></p> <p>Per the\u00a0RFC 7049 Major Types\u00a0section, CBOR supports the following data types: \u6839\u636e RFC 7049 \u4e3b\u8981\u7c7b\u578b\u90e8\u5206\uff0cCBOR \u652f\u6301\u4ee5\u4e0b\u6570\u636e\u7c7b\u578b\uff1a</p> <ul> <li>Major type 0: an unsigned integer     \u4e3b\u8981\u7c7b\u578b 0\uff1a\u65e0\u7b26\u53f7\u6574\u6570</li> <li>Major type 1: a negative integer     \u4e3b\u8981\u7c7b\u578b 1\uff1a\u8d1f\u6574\u6570</li> <li>Major type 2: a byte string     \u4e3b\u8981\u7c7b\u578b 2\uff1a\u5b57\u8282\u5b57\u7b26\u4e32</li> <li>Major type 3: a text string     \u4e3b\u8981\u7c7b\u578b 3\uff1a\u6587\u672c\u5b57\u7b26\u4e32</li> <li>Major type 4: an array of data items     \u4e3b\u8981\u7c7b\u578b 4\uff1a\u6570\u636e\u9879\u6570\u7ec4</li> <li>Major type 5: a map of pairs of data items     \u4e3b\u8981\u7c7b\u578b 5\uff1a\u6570\u636e\u9879\u5bf9\u7684\u6620\u5c04</li> <li>Major type 6: optional semantic tagging of other major types     \u4e3b\u8981\u7c7b\u578b6\uff1a\u5176\u4ed6\u4e3b\u8981\u7c7b\u578b\u7684\u53ef\u9009\u8bed\u4e49\u6807\u8bb0</li> <li>Major type 7: floating-point numbers and simple data types that need no content, as well as the \u201cbreak\u201d stop code     \u4e3b\u8981\u7c7b\u578b 7\uff1a\u6d6e\u70b9\u6570\u548c\u4e0d\u9700\u8981\u5185\u5bb9\u7684\u7b80\u5355\u6570\u636e\u7c7b\u578b\uff0c\u4ee5\u53ca\u201c\u4e2d\u65ad\u201d\u505c\u6b62\u4ee3\u7801</li> </ul> <p>By default, Kotlin\u00a0<code>ByteArray</code>\u00a0instances are encoded as\u00a0major type 4. When\u00a0major type 2\u00a0is desired, then the\u00a0<code>@ByteString</code>\u00a0annotation can be used. \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cKotlin\u00a0<code>ByteArray</code>\u00a0\u5b9e\u4f8b\u7f16\u7801\u4e3a\u4e3b\u8981\u7c7b\u578b 4\u3002\u5f53\u9700\u8981\u4e3b\u8981\u7c7b\u578b 2 \u65f6\uff0c\u00a0<code>@ByteString</code>\u00a0\u53ef\u4ee5\u4f7f\u7528\u6ce8\u91ca\u3002</p> <pre><code>@Serializable\ndata class Data(\n    @ByteString\n    val type2: ByteArray, // CBOR Major type 2\n    val type4: ByteArray  // CBOR Major type 4\n)        \n\nfun main() {\n    val data = Data(byteArrayOf(1, 2, 3, 4), byteArrayOf(5, 6, 7, 8)) \n    val bytes = Cbor.encodeToByteArray(data)   \n    println(bytes.toAsciiHexString())\n    val obj = Cbor.decodeFromByteArray&lt;Data&gt;(bytes)\n    println(obj)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>As we see, the CBOR byte that precedes the data is different for different types of encoding. \u6b63\u5982\u6211\u4eec\u6240\u770b\u5230\u7684\uff0c\u5bf9\u4e8e\u4e0d\u540c\u7c7b\u578b\u7684\u7f16\u7801\uff0c\u6570\u636e\u524d\u9762\u7684 CBOR \u5b57\u8282\u662f\u4e0d\u540c\u7684\u3002</p> <pre><code>{BF}etype2D{01}{02}{03}{04}etype4{9F}{05}{06}{07}{08}{FF}{FF}\nData(type2=[1, 2, 3, 4], type4=[5, 6, 7, 8])\n</code></pre> <p>In\u00a0CBOR hex notation, the output is equivalent to the following: \u5728 CBOR \u5341\u516d\u8fdb\u5236\u8868\u793a\u6cd5\u4e2d\uff0c\u8f93\u51fa\u7b49\u6548\u4e8e\u4ee5\u4e0b\u5185\u5bb9\uff1a</p> <pre><code>BF               # map(*)\n   65            # text(5)\n      7479706532 # \"type2\"\n   44            # bytes(4)\n      01020304   # \"\\x01\\x02\\x03\\x04\"\n   65            # text(5)\n      7479706534 # \"type4\"\n   9F            # array(*)\n      05         # unsigned(5)\n      06         # unsigned(6)\n      07         # unsigned(7)\n      08         # unsigned(8)\n      FF         # primitive(*)\n   FF            # primitive(*)\n</code></pre>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#protobuf-experimental-protobuf","title":"ProtoBuf (experimental)\u00a0ProtoBuf\uff08\u5b9e\u9a8c\u6027\uff09","text":"<p>Protocol Buffers\u00a0is a language-neutral binary format that normally relies on a separate \u201c.proto\u201d file that defines the protocol schema. It is more compact than CBOR, because it assigns integer numbers to fields instead of names. \u534f\u8bae\u7f13\u51b2\u533a\u662f\u4e00\u79cd\u4e0e\u8bed\u8a00\u65e0\u5173\u7684\u4e8c\u8fdb\u5236\u683c\u5f0f\uff0c\u901a\u5e38\u4f9d\u8d56\u4e8e\u5b9a\u4e49\u534f\u8bae\u67b6\u6784\u7684\u5355\u72ec\u201c.proto\u201d\u6587\u4ef6\u3002\u5b83\u6bd4 CBOR \u66f4\u7d27\u51d1\uff0c\u56e0\u4e3a\u5b83\u4e3a\u5b57\u6bb5\u800c\u4e0d\u662f\u540d\u79f0\u5206\u914d\u6574\u6570\u3002</p> <p>Protocol buffers support is (experimentally) available in a separate\u00a0<code>org.jetbrains.kotlinx:kotlinx-serialization-protobuf:&lt;version&gt;</code>\u00a0module. \u534f\u8bae\u7f13\u51b2\u533a\u652f\u6301\uff08\u5b9e\u9a8c\u6027\u5730\uff09\u5728\u5355\u72ec\u7684\u00a0<code>org.jetbrains.kotlinx:kotlinx-serialization-protobuf:&lt;version&gt;</code>\u00a0\u6a21\u5757\u4e2d\u53ef\u7528\u3002</p> <p>Kotlin Serialization is using proto2 semantics, where all fields are explicitly required or optional. For a basic example we change our example to use the\u00a0ProtoBuf\u00a0class with\u00a0ProtoBuf.encodeToByteArray\u00a0and\u00a0ProtoBuf.decodeFromByteArray\u00a0functions. Kotlin \u5e8f\u5217\u5316\u4f7f\u7528 proto2 \u8bed\u4e49\uff0c\u5176\u4e2d\u6240\u6709\u5b57\u6bb5\u90fd\u662f\u663e\u5f0f\u5fc5\u586b\u5b57\u6bb5\u6216\u53ef\u9009\u5b57\u6bb5\u3002\u5bf9\u4e8e\u4e00\u4e2a\u57fa\u672c\u793a\u4f8b\uff0c\u6211\u4eec\u5c06\u793a\u4f8b\u66f4\u6539\u4e3a\u5c06 ProtoBuf \u7c7b\u4e0e ProtoBuf.encodeToByteArray \u548c ProtoBuf.decodeFromByteArray \u51fd\u6570\u4e00\u8d77\u4f7f\u7528\u3002</p> <pre><code>@Serializable\ndata class Project(val name: String, val language: String)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\", \"Kotlin\") \n    val bytes = ProtoBuf.encodeToByteArray(data)   \n    println(bytes.toAsciiHexString())\n    val obj = ProtoBuf.decodeFromByteArray&lt;Project&gt;(bytes)\n    println(obj)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>{0A}{15}kotlinx.serialization{12}{06}Kotlin\nProject(name=kotlinx.serialization, language=Kotlin)\n</code></pre> <p>In\u00a0ProtoBuf hex notation, the output is equivalent to the following: \u5728 ProtoBuf \u5341\u516d\u8fdb\u5236\u8868\u793a\u6cd5\u4e2d\uff0c\u8f93\u51fa\u7b49\u6548\u4e8e\u4ee5\u4e0b\u5185\u5bb9\uff1a</p> <pre><code>Field #1: 0A String Length = 21, Hex = 15, UTF8 = \"kotlinx.serialization\"\nField #2: 12 String Length = 6, Hex = 06, UTF8 = \"Kotlin\"\n</code></pre>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#field-numbers","title":"Field numbers\u00a0\u5b57\u6bb5\u7f16\u53f7","text":"<p>By default, field numbers in the Kotlin Serialization\u00a0ProtoBuf\u00a0implementation are automatically assigned, which does not provide the ability to define a stable data schema that evolves over time. That is normally achieved by writing a separate \u201c.proto\u201d file. However, with Kotlin Serialization we can get this ability without a separate schema file, instead using the\u00a0ProtoNumber\u00a0annotation. \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cKotlin Serialization ProtoBuf \u5b9e\u73b0\u4e2d\u7684\u5b57\u6bb5\u53f7\u662f\u81ea\u52a8\u5206\u914d\u7684\uff0c\u8fd9\u65e0\u6cd5\u5b9a\u4e49\u968f\u65f6\u95f4\u63a8\u79fb\u7684\u7a33\u5b9a\u6570\u636e\u67b6\u6784\u3002\u8fd9\u901a\u5e38\u662f\u901a\u8fc7\u7f16\u5199\u4e00\u4e2a\u5355\u72ec\u7684\u201c.proto\u201d\u6587\u4ef6\u6765\u5b9e\u73b0\u7684\u3002\u4f46\u662f\uff0c\u901a\u8fc7 Kotlin \u5e8f\u5217\u5316\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u6ca1\u6709\u5355\u72ec\u7684\u67b6\u6784\u6587\u4ef6\u7684\u60c5\u51b5\u4e0b\u83b7\u5f97\u6b64\u529f\u80fd\uff0c\u800c\u662f\u4f7f\u7528 ProtoNumber \u6ce8\u91ca\u3002</p> <pre><code>@Serializable\ndata class Project(\n    @ProtoNumber(1)\n    val name: String, \n    @ProtoNumber(3)\n    val language: String\n)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\", \"Kotlin\") \n    val bytes = ProtoBuf.encodeToByteArray(data)   \n    println(bytes.toAsciiHexString())\n    val obj = ProtoBuf.decodeFromByteArray&lt;Project&gt;(bytes)\n    println(obj)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>We see in the output that the number for the first property\u00a0<code>name</code>\u00a0did not change (as it is numbered from one by default), but it did change for the\u00a0<code>language</code>\u00a0property. \u6211\u4eec\u5728\u8f93\u51fa\u4e2d\u770b\u5230\u7b2c\u4e00\u4e2a\u5c5e\u6027\u00a0<code>name</code>\u00a0\u7684\u6570\u5b57\u6ca1\u6709\u66f4\u6539\uff08\u56e0\u4e3a\u5b83\u9ed8\u8ba4\u4ece 1 \u5f00\u59cb\u7f16\u53f7\uff09\uff0c\u4f46\u00a0<code>language</code>\u00a0\u8be5\u5c5e\u6027\u7684\u6570\u5b57\u786e\u5b9e\u53d1\u751f\u4e86\u53d8\u5316\u3002</p> <pre><code>{0A}{15}kotlinx.serialization{1A}{06}Kotlin\nProject(name=kotlinx.serialization, language=Kotlin)\n</code></pre> <p>In\u00a0ProtoBuf hex notation, the output is equivalent to the following: \u5728 ProtoBuf \u5341\u516d\u8fdb\u5236\u8868\u793a\u6cd5\u4e2d\uff0c\u8f93\u51fa\u7b49\u6548\u4e8e\u4ee5\u4e0b\u5185\u5bb9\uff1a</p> <pre><code>Field #1: 0A String Length = 21, Hex = 15, UTF8 = \"kotlinx.serialization\" (total 21 chars)\nField #3: 1A String Length = 6, Hex = 06, UTF8 = \"Kotlin\"\n</code></pre>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#integer-types","title":"Integer types\u00a0\u6574\u6570\u7c7b\u578b","text":"<p>Protocol buffers support various integer encodings optimized for different ranges of integers. They are specified using the\u00a0ProtoType\u00a0annotation and the\u00a0ProtoIntegerType\u00a0enum. The following example shows all three supported options. \u534f\u8bae\u7f13\u51b2\u533a\u652f\u6301\u9488\u5bf9\u4e0d\u540c\u8303\u56f4\u7684\u6574\u6570\u4f18\u5316\u7684\u5404\u79cd\u6574\u6570\u7f16\u7801\u3002\u5b83\u4eec\u662f\u4f7f\u7528 ProtoType \u6ce8\u89e3\u548c ProtoIntegerType \u679a\u4e3e\u6307\u5b9a\u7684\u3002\u4ee5\u4e0b\u793a\u4f8b\u663e\u793a\u4e86\u6240\u6709\u4e09\u4e2a\u53d7\u652f\u6301\u7684\u9009\u9879\u3002</p> <pre><code>@Serializable\nclass Data(\n    @ProtoType(ProtoIntegerType.DEFAULT)\n    val a: Int,\n    @ProtoType(ProtoIntegerType.SIGNED)\n    val b: Int,\n    @ProtoType(ProtoIntegerType.FIXED)\n    val c: Int\n)\n\nfun main() {\n    val data = Data(1, -2, 3) \n    println(ProtoBuf.encodeToByteArray(data).toAsciiHexString())\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <ul> <li>The\u00a0default\u00a0is a varint encoding (<code>intXX</code>) that is optimized for small non-negative numbers. The value of\u00a0<code>1</code>\u00a0is encoded in one byte\u00a0<code>01</code>.     \u9ed8\u8ba4\u503c\u662f\u9488\u5bf9\u5c0f\u975e\u8d1f\u6570\u4f18\u5316\u7684\u53d8\u91cf\u7f16\u7801 \uff08\u00a0<code>intXX</code>\u00a0\uff09\u3002\u7684\u00a0<code>1</code>\u00a0\u503c\u4ee5\u4e00\u4e2a\u5b57\u8282\u7f16\u7801\u00a0<code>01</code>\u00a0\u3002</li> <li>The\u00a0signed\u00a0is a signed ZigZag encoding (<code>sintXX</code>) that is optimized for small signed integers. The value of\u00a0<code>-2</code>\u00a0is encoded in one byte\u00a0<code>03</code>.     \u6709\u7b26\u53f7\u662f\u9488\u5bf9\u5c0f\u6709\u7b26\u53f7\u6574\u6570\u4f18\u5316\u7684\u6709\u7b26\u53f7\u4e4b\u5b57\u6298\u7ebf\u7f16\u7801 \uff08\u00a0<code>sintXX</code>\u00a0\uff09\u3002\u7684\u00a0<code>-2</code>\u00a0\u503c\u4ee5\u4e00\u4e2a\u5b57\u8282\u7f16\u7801\u00a0<code>03</code>\u00a0\u3002</li> <li>The\u00a0fixed\u00a0encoding (<code>fixedXX</code>) always uses a fixed number of bytes. The value of\u00a0<code>3</code>\u00a0is encoded as four bytes\u00a0<code>03 00 00 00</code>.     \u56fa\u5b9a\u7f16\u7801 \uff08\u00a0<code>fixedXX</code>\u00a0\uff09 \u59cb\u7ec8\u4f7f\u7528\u56fa\u5b9a\u7684\u5b57\u8282\u6570\u3002\u7684\u00a0<code>3</code>\u00a0\u503c\u7f16\u7801\u4e3a 4 \u4e2a\u5b57\u8282\u00a0<code>03 00 00 00</code>\u00a0\u3002</li> </ul> <p><code>uintXX</code>\u00a0and\u00a0<code>sfixedXX</code>\u00a0protocol buffer types are not supported. <code>uintXX</code>\u00a0\u5e76\u4e14\u00a0<code>sfixedXX</code>\u00a0\u4e0d\u652f\u6301\u534f\u8bae\u7f13\u51b2\u533a\u7c7b\u578b\u3002</p> <pre><code>{08}{01}{10}{03}{1D}{03}{00}{00}{00}\n</code></pre> <p>In\u00a0ProtoBuf hex notation\u00a0the output is equivalent to the following: \u5728 ProtoBuf \u5341\u516d\u8fdb\u5236\u8868\u793a\u6cd5\u4e2d\uff0c\u8f93\u51fa\u7b49\u6548\u4e8e\u4ee5\u4e0b\u5185\u5bb9\uff1a</p> <pre><code>Field #1: 08 Varint Value = 1, Hex = 01\nField #2: 10 Varint Value = 3, Hex = 03\nField #3: 1D Fixed32 Value = 3, Hex = 03-00-00-00\n</code></pre>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#lists-as-repeated-fields","title":"Lists as repeated fields\u00a0\u4f5c\u4e3a\u91cd\u590d\u5b57\u6bb5\u5217\u51fa","text":"<p>By default, kotlin lists and other collections are representend as repeated fields. In the protocol buffers when the list is empty there are no elements in the stream with the corresponding number. For Kotlin Serialization you must explicitly specify a default of\u00a0<code>emptyList()</code>\u00a0for any property of a collection or map type. Otherwise you will not be able deserialize an empty list, which is indistinguishable in protocol buffers from a missing field. \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0ckotlin \u5217\u8868\u548c\u5176\u4ed6\u96c6\u5408\u8868\u793a\u4e3a\u91cd\u590d\u5b57\u6bb5\u3002\u5728\u534f\u8bae\u7f13\u51b2\u533a\u4e2d\uff0c\u5f53\u5217\u8868\u4e3a\u7a7a\u65f6\uff0c\u6d41\u4e2d\u6ca1\u6709\u5177\u6709\u76f8\u5e94\u7f16\u53f7\u7684\u5143\u7d20\u3002\u5bf9\u4e8e Kotlin \u5e8f\u5217\u5316\uff0c\u60a8\u5fc5\u987b\u4e3a\u96c6\u5408\u6216\u6620\u5c04\u7c7b\u578b\u7684\u4efb\u4f55\u5c5e\u6027\u663e\u5f0f\u6307\u5b9a\u9ed8\u8ba4\u503c\u00a0<code>emptyList()</code>\u00a0\u3002\u5426\u5219\uff0c\u60a8\u5c06\u65e0\u6cd5\u53cd\u5e8f\u5217\u5316\u7a7a\u5217\u8868\uff0c\u8be5\u7a7a\u5217\u8868\u5728\u534f\u8bae\u7f13\u51b2\u533a\u4e2d\u65e0\u6cd5\u4e0e\u7f3a\u5931\u5b57\u6bb5\u533a\u5206\u5f00\u6765\u3002</p> <pre><code>@Serializable\ndata class Data(\n    val a: List&lt;Int&gt; = emptyList(),\n    val b: List&lt;Int&gt; = emptyList()\n)\n\nfun main() {\n    val data = Data(listOf(1, 2, 3), listOf())\n    val bytes = ProtoBuf.encodeToByteArray(data)\n    println(bytes.toAsciiHexString())\n    println(ProtoBuf.decodeFromByteArray&lt;Data&gt;(bytes))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <pre><code>{08}{01}{08}{02}{08}{03}\nData(a=[1, 2, 3], b=[])\n</code></pre> <p>In\u00a0ProtoBuf diagnostic mode\u00a0the output is equivalent to the following: \u5728 ProtoBuf \u8bca\u65ad\u6a21\u5f0f\u4e0b\uff0c\u8f93\u51fa\u7b49\u6548\u4e8e\u4ee5\u4e0b\u5185\u5bb9\uff1a</p> <pre><code>Field #1: 08 Varint Value = 1, Hex = 01\nField #1: 08 Varint Value = 2, Hex = 02\nField #1: 08 Varint Value = 3, Hex = 03\n</code></pre>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#packed-fields","title":"Packed fields\u00a0\u586b\u5145\u5b57\u6bb5","text":"<p>Collection types (not maps) can be\u00a0written\u00a0as packed fields when annotated with the\u00a0<code>@ProtoPacked</code>\u00a0annotation. Per the standard packed fields can only be used on primitive numeric types. The annotation is ignored on other types. \u96c6\u5408\u7c7b\u578b\uff08\u4e0d\u662f\u5730\u56fe\uff09\u5728\u4f7f\u7528\u00a0<code>@ProtoPacked</code>\u00a0\u6ce8\u91ca\u8fdb\u884c\u6ce8\u91ca\u65f6\u53ef\u4ee5\u5199\u5165\u538b\u7f29\u5b57\u6bb5\u3002\u6839\u636e\u6807\u51c6\uff0c\u6253\u5305\u5b57\u6bb5\u53ea\u80fd\u7528\u4e8e\u57fa\u5143\u6570\u503c\u7c7b\u578b\u3002\u5728\u5176\u4ed6\u7c7b\u578b\u4e0a\uff0c\u6ce8\u91ca\u5c06\u88ab\u5ffd\u7565\u3002</p> <p>Per the\u00a0format description\u00a0the parser ignores the annotation, but rather reads list in either packed or repeated format. \u6839\u636e\u683c\u5f0f\u8bf4\u660e\uff0c\u89e3\u6790\u5668\u4f1a\u5ffd\u7565\u6ce8\u91ca\uff0c\u800c\u662f\u8bfb\u53d6\u6253\u5305\u6216\u91cd\u590d\u683c\u5f0f\u7684\u5217\u8868\u3002</p>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#protobuf-schema-generator-experimental","title":"ProtoBuf schema generator (experimental)","text":"<p>ProtoBuf \u6a21\u5f0f\u751f\u6210\u5668\uff08\u5b9e\u9a8c\u6027\uff09</p> <p></p> <p>As mentioned above, when working with protocol buffers you usually use a \u201c.proto\u201d file and a code generator for your language. This includes the code to serialize your message to an output stream and deserialize it from an input stream. When using Kotlin Serialization this step is not necessary because your\u00a0<code>@Serializable</code>\u00a0Kotlin data types are used as the source for the schema. \u5982\u4e0a\u6240\u8ff0\uff0c\u5728\u4f7f\u7528\u534f\u8bae\u7f13\u51b2\u533a\u65f6\uff0c\u60a8\u901a\u5e38\u4f7f\u7528\u201c.proto\u201d\u6587\u4ef6\u548c\u8bed\u8a00\u7684\u4ee3\u7801\u751f\u6210\u5668\u3002\u8fd9\u5305\u62ec\u5c06\u6d88\u606f\u5e8f\u5217\u5316\u4e3a\u8f93\u51fa\u6d41\u5e76\u4ece\u8f93\u5165\u6d41\u53cd\u5e8f\u5217\u5316\u7684\u4ee3\u7801\u3002\u4f7f\u7528 Kotlin \u5e8f\u5217\u5316\u65f6\uff0c\u4e0d\u9700\u8981\u6b64\u6b65\u9aa4\uff0c\u56e0\u4e3a\u00a0<code>@Serializable</code>\u00a0Kotlin \u6570\u636e\u7c7b\u578b\u7528\u4f5c\u67b6\u6784\u7684\u6e90\u3002</p> <p>This is very convenient for Kotlin-to-Kotlin communication, but makes interoperability between languages complicated. Fortunately, you can use the ProtoBuf schema generator to output the \u201c.proto\u201d representation of your messages. You can keep your Kotlin classes as a source of truth and use traditional protoc compilers for other languages at the same time. \u8fd9\u5bf9\u4e8e Kotlin \u5230 Kotlin \u7684\u901a\u4fe1\u975e\u5e38\u65b9\u4fbf\uff0c\u4f46\u4f7f\u8bed\u8a00\u4e4b\u95f4\u7684\u4e92\u64cd\u4f5c\u6027\u53d8\u5f97\u590d\u6742\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 ProtoBuf \u6a21\u5f0f\u751f\u6210\u5668\u6765\u8f93\u51fa\u6d88\u606f\u7684\u201c.proto\u201d\u8868\u793a\u5f62\u5f0f\u3002\u60a8\u53ef\u4ee5\u5c06 Kotlin \u7c7b\u4fdd\u7559\u4e3a\u4e8b\u5b9e\u6765\u6e90\uff0c\u540c\u65f6\u5c06\u4f20\u7edf\u7684 protoc \u7f16\u8bd1\u5668\u7528\u4e8e\u5176\u4ed6\u8bed\u8a00\u3002</p> <p>As an example, we can display the following data class\u2019s \u201c.proto\u201d schema as follows. \u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u663e\u793a\u4ee5\u4e0b\u6570\u636e\u7c7b\u7684\u201c.proto\u201d\u6a21\u5f0f\uff0c\u5982\u4e0b\u6240\u793a\u3002</p> <pre><code>@Serializable\ndata class SampleData(\n    val amount: Long,\n    val description: String?,\n    val department: String = \"QA\"\n)\nfun main() {\n  val descriptors = listOf(SampleData.serializer().descriptor)\n  val schemas = ProtoBufSchemaGenerator.generateSchemaText(descriptors)\n  println(schemas)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Which would output as follows. \u8fd9\u5c06\u8f93\u51fa\u5982\u4e0b\u3002</p> <pre><code>syntax = \"proto2\";\n\n\n// serial name 'example.exampleFormats08.SampleData'\nmessage SampleData {\n  required int64 amount = 1;\n  optional string description = 2;\n  // WARNING: a default value decoded when value is missing\n  optional string department = 3;\n}\n</code></pre> <p>Note that since default values are not represented in \u201c.proto\u201d files, a warning is generated when one appears in the schema. \u8bf7\u6ce8\u610f\uff0c\u7531\u4e8e\u9ed8\u8ba4\u503c\u672a\u5728\u201c.proto\u201d\u6587\u4ef6\u4e2d\u8868\u793a\uff0c\u56e0\u6b64\u5f53\u67b6\u6784\u4e2d\u51fa\u73b0\u9ed8\u8ba4\u503c\u65f6\uff0c\u4f1a\u751f\u6210\u8b66\u544a\u3002</p> <p>See the documentation for\u00a0ProtoBufSchemaGenerator\u00a0for more information. \u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u89c1 ProtoBufSchemaGenerator \u7684\u6587\u6863\u3002</p>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#properties-experimental","title":"Properties (experimental)","text":"<p>\u5c5e\u6027\uff08\u5b9e\u9a8c\u6027\uff09</p> <p></p> <p>Kotlin Serialization can serialize a class into a flat map with\u00a0<code>String</code>\u00a0keys via the\u00a0Properties\u00a0format implementation. Kotlin Serialization \u53ef\u4ee5\u901a\u8fc7 Properties \u683c\u5f0f\u5b9e\u73b0\u5c06\u7c7b\u5e8f\u5217\u5316\u4e3a\u5e26\u6709\u00a0<code>String</code>\u00a0\u952e\u7684\u5e73\u9762\u6620\u5c04\u3002</p> <p>Properties support is (experimentally) available in a separate\u00a0<code>org.jetbrains.kotlinx:kotlinx-serialization-properties:&lt;version&gt;</code>\u00a0module. \u5c5e\u6027\u652f\u6301\uff08\u5b9e\u9a8c\u6027\u5730\uff09\u5728\u5355\u72ec\u7684\u00a0<code>org.jetbrains.kotlinx:kotlinx-serialization-properties:&lt;version&gt;</code>\u00a0\u6a21\u5757\u4e2d\u53ef\u7528\u3002</p> <pre><code>@Serializable\nclass Project(val name: String, val owner: User)\n\n@Serializable\nclass User(val name: String)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\",  User(\"kotlin\"))\n    val map = Properties.encodeToMap(data)\n    map.forEach { (k, v) -&gt; println(\"$k = $v\") }\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>The resulting map has dot-separated keys representing keys of the nested objects. \u751f\u6210\u7684\u6620\u5c04\u5177\u6709\u8868\u793a\u5d4c\u5957\u5bf9\u8c61\u952e\u7684\u70b9\u5206\u9694\u952e\u3002</p> <pre><code>name = kotlinx.serialization\nowner.name = kotlin\n</code></pre>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#custom-formats-experimental","title":"Custom formats (experimental)","text":"<p>\u81ea\u5b9a\u4e49\u683c\u5f0f\uff08\u5b9e\u9a8c\u6027\uff09</p> <p></p> <p>A custom format for Kotlin Serialization must provide an implementation for the\u00a0Encoder\u00a0and\u00a0Decoder\u00a0interfaces that we saw used in the\u00a0Serializers\u00a0chapter. Kotlin \u5e8f\u5217\u5316\u7684\u81ea\u5b9a\u4e49\u683c\u5f0f\u5fc5\u987b\u4e3a\u6211\u4eec\u5728\u5e8f\u5217\u5316\u7a0b\u5e8f\u4e00\u7ae0\u4e2d\u770b\u5230\u7684\u7f16\u7801\u5668\u548c\u89e3\u7801\u5668\u63a5\u53e3\u63d0\u4f9b\u5b9e\u73b0\u3002 These are pretty large interfaces. For convenience the\u00a0AbstractEncoder\u00a0and\u00a0AbstractDecoder\u00a0skeleton implementations are provided to simplify the task. In\u00a0AbstractEncoder\u00a0most of the\u00a0<code>encodeXxx</code>\u00a0methods have a default implementation that delegates to\u00a0<code>encodeValue(value: Any)</code>\u00a0\u2014 the only method that must be implemented to get a basic working format. \u8fd9\u4e9b\u90fd\u662f\u76f8\u5f53\u5927\u7684\u63a5\u53e3\u3002\u4e3a\u65b9\u4fbf\u8d77\u89c1\uff0c\u63d0\u4f9b\u4e86 AbstractEncoder \u548c AbstractDecoder \u6846\u67b6\u5b9e\u73b0\u6765\u7b80\u5316\u4efb\u52a1\u3002\u5728 AbstractEncoder \u4e2d\uff0c\u00a0<code>encodeXxx</code>\u00a0\u5927\u591a\u6570\u65b9\u6cd5\u90fd\u6709\u4e00\u4e2a\u59d4\u6258\u7ed9\u00a0<code>encodeValue(value: Any)</code>\u00a0\u7684\u9ed8\u8ba4\u5b9e\u73b0\uff0c\u8fd9\u662f\u83b7\u53d6\u57fa\u672c\u5de5\u4f5c\u683c\u5f0f\u6240\u5fc5\u987b\u5b9e\u73b0\u7684\u552f\u4e00\u65b9\u6cd5\u3002</p>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#basic-encoder","title":"Basic encoder\u00a0\u57fa\u672c\u7f16\u7801\u5668","text":"<p>Let us start with a trivial format implementation that encodes the data into a single list of primitive constituent objects in the order they were written in the source code. To start, we implement a simple\u00a0Encoder\u00a0by overriding\u00a0<code>encodeValue</code>\u00a0in\u00a0AbstractEncoder. \u8ba9\u6211\u4eec\u4ece\u4e00\u4e2a\u7b80\u5355\u7684\u683c\u5f0f\u5b9e\u73b0\u5f00\u59cb\uff0c\u8be5\u5b9e\u73b0\u6309\u7167\u5b83\u4eec\u5728\u6e90\u4ee3\u7801\u4e2d\u7684\u7f16\u5199\u987a\u5e8f\u5c06\u6570\u636e\u7f16\u7801\u5230\u57fa\u5143\u7ec4\u6210\u5bf9\u8c61\u7684\u5355\u4e2a\u5217\u8868\u4e2d\u3002\u9996\u5148\uff0c\u6211\u4eec\u901a\u8fc7\u00a0<code>encodeValue</code>\u00a0\u8986\u76d6 AbstractEncoder \u6765\u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684 Encoder\u3002</p> <pre><code>class ListEncoder : AbstractEncoder() {\n    val list = mutableListOf&lt;Any&gt;()\n\n    override val serializersModule: SerializersModule = EmptySerializersModule()\n\n    override fun encodeValue(value: Any) {\n        list.add(value)\n    }\n}\n</code></pre> <p>Now we write a convenience top-level function that creates an encoder that encodes an object and returns a list. \u73b0\u5728\uff0c\u6211\u4eec\u7f16\u5199\u4e00\u4e2a\u65b9\u4fbf\u7684\u9876\u7ea7\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u521b\u5efa\u4e00\u4e2a\u7f16\u7801\u5668\uff0c\u8be5\u7f16\u7801\u5668\u5bf9\u5bf9\u8c61\u8fdb\u884c\u7f16\u7801\u5e76\u8fd4\u56de\u5217\u8868\u3002</p> <pre><code>fun &lt;T&gt; encodeToList(serializer: SerializationStrategy&lt;T&gt;, value: T): List&lt;Any&gt; {\n    val encoder = ListEncoder()\n    encoder.encodeSerializableValue(serializer, value)\n    return encoder.list\n}\n</code></pre> <p>For even more convenience, to avoid the need to explicitly pass a serializer, we write an\u00a0<code>inline</code>\u00a0overload of the\u00a0<code>encodeToList</code>\u00a0function with a\u00a0<code>reified</code>\u00a0type parameter using the\u00a0serializer\u00a0function to retrieve the appropriate\u00a0KSerializer\u00a0instance for the actual type. \u4e3a\u4e86\u66f4\u52a0\u65b9\u4fbf\uff0c\u4e3a\u4e86\u907f\u514d\u663e\u5f0f\u4f20\u9012\u5e8f\u5217\u5316\u7a0b\u5e8f\u7684\u9700\u8981\uff0c\u6211\u4eec\u00a0<code>inline</code>\u00a0\u4f7f\u7528 serializer \u51fd\u6570\u7f16\u5199\u5e26\u6709\u00a0<code>reified</code>\u00a0\u7c7b\u578b\u53c2\u6570\u7684\u00a0<code>encodeToList</code>\u00a0\u51fd\u6570\u91cd\u8f7d\uff0c\u4ee5\u68c0\u7d22\u5b9e\u9645\u7c7b\u578b\u7684\u76f8\u5e94 KSerializer \u5b9e\u4f8b\u3002</p> <pre><code>inline fun &lt;reified T&gt; encodeToList(value: T) = encodeToList(serializer(), value)\n</code></pre> <p>Now we can test it. \u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u6d4b\u8bd5\u5b83\u4e86\u3002</p> <pre><code>@Serializable\ndata class Project(val name: String, val owner: User, val votes: Int)\n\n@Serializable\ndata class User(val name: String)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\",  User(\"kotlin\"), 9000)\n    println(encodeToList(data))\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>As a result, we got all the primitive values in our object graph visited and put into a list in\u00a0serial\u00a0order. \u7ed3\u679c\uff0c\u6211\u4eec\u8bbf\u95ee\u4e86\u5bf9\u8c61\u56fe\u4e2d\u7684\u6240\u6709\u57fa\u5143\u503c\uff0c\u5e76\u6309\u987a\u5e8f\u653e\u5165\u5217\u8868\u4e2d\u3002</p> <pre><code>[kotlinx.serialization, kotlin, 9000]\n</code></pre> <p>By itself, that\u2019s a useful feature if we need compute some kind of hashcode or digest for all the data that is contained in a serializable object tree. \u5c31\u5176\u672c\u8eab\u800c\u8a00\uff0c\u5982\u679c\u6211\u4eec\u9700\u8981\u4e3a\u53ef\u5e8f\u5217\u5316\u5bf9\u8c61\u6811\u4e2d\u5305\u542b\u7684\u6240\u6709\u6570\u636e\u8ba1\u7b97\u67d0\u79cd\u54c8\u5e0c\u7801\u6216\u6458\u8981\uff0c\u8fd9\u662f\u4e00\u4e2a\u6709\u7528\u7684\u529f\u80fd\u3002</p>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#basic-decoder","title":"Basic decoder\u00a0\u57fa\u672c\u89e3\u7801\u5668","text":"<p>A decoder needs to implement more substance. \u89e3\u7801\u5668\u9700\u8981\u5b9e\u73b0\u66f4\u591a\u7684\u5b9e\u8d28\u5185\u5bb9\u3002</p> <ul> <li>decodeValue\u00a0\u2014 returns the next value from the list.     decodeValue \u2014 \u8fd4\u56de\u5217\u8868\u4e2d\u7684\u4e0b\u4e00\u4e2a\u503c\u3002</li> <li>decodeElementIndex\u00a0\u2014 returns the next index of a deserialized value. In this primitive format deserialization always happens in order, so we keep track of the index in the\u00a0<code>elementIndex</code>\u00a0variable. See the\u00a0Hand-written composite serializer\u00a0section on how it ends up being used.     decodeElementIndex \u2014 \u8fd4\u56de\u53cd\u5e8f\u5217\u5316\u503c\u7684\u4e0b\u4e00\u4e2a\u7d22\u5f15\u3002\u5728\u8fd9\u79cd\u539f\u59cb\u683c\u5f0f\u4e2d\uff0c\u53cd\u5e8f\u5217\u5316\u603b\u662f\u6309\u987a\u5e8f\u8fdb\u884c\uff0c\u56e0\u6b64\u6211\u4eec\u8ddf\u8e2a\u00a0<code>elementIndex</code>\u00a0\u53d8\u91cf\u4e2d\u7684\u7d22\u5f15\u3002\u8bf7\u53c2\u9605\u624b\u5199\u590d\u5408\u5e8f\u5217\u5316\u7a0b\u5e8f\u90e8\u5206\uff0c\u4e86\u89e3\u5b83\u6700\u7ec8\u7684\u4f7f\u7528\u65b9\u5f0f\u3002</li> <li>beginStructure\u00a0\u2014 returns a new instance of the\u00a0<code>ListDecoder</code>, so that each structure that is being recursively decoded keeps track of its own\u00a0<code>elementIndex</code>\u00a0state separately.     beginStructure \u2014 \u8fd4\u56de\u00a0<code>ListDecoder</code>\u00a0\u7684\u65b0\u5b9e\u4f8b\uff0c\u4ee5\u4fbf\u4ee5\u9012\u5f52\u65b9\u5f0f\u89e3\u7801\u7684\u6bcf\u4e2a\u7ed3\u6784\u90fd\u5355\u72ec\u8ddf\u8e2a\u81ea\u5df1\u7684\u00a0<code>elementIndex</code>\u00a0\u72b6\u6001\u3002</li> </ul> <pre><code>class ListDecoder(val list: ArrayDeque&lt;Any&gt;) : AbstractDecoder() {\n    private var elementIndex = 0\n\n    override val serializersModule: SerializersModule = EmptySerializersModule()\n\n    override fun decodeValue(): Any = list.removeFirst()\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int {\n        if (elementIndex == descriptor.elementsCount) return CompositeDecoder.DECODE_DONE\n        return elementIndex++\n    }\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder =\n        ListDecoder(list)\n}\n</code></pre> <p>A couple of convenience functions for decoding. \u4e00\u4e9b\u65b9\u4fbf\u7684\u89e3\u7801\u529f\u80fd\u3002</p> <pre><code>fun &lt;T&gt; decodeFromList(list: List&lt;Any&gt;, deserializer: DeserializationStrategy&lt;T&gt;): T {\n    val decoder = ListDecoder(ArrayDeque(list))\n    return decoder.decodeSerializableValue(deserializer)\n}\n\ninline fun &lt;reified T&gt; decodeFromList(list: List&lt;Any&gt;): T = decodeFromList(list, serializer())\n</code></pre> <p>That is enough to start encoding and decoding basic serializable classes. \u8fd9\u8db3\u4ee5\u5f00\u59cb\u7f16\u7801\u548c\u89e3\u7801\u57fa\u672c\u7684\u53ef\u5e8f\u5217\u5316\u7c7b\u3002</p> <pre><code>fun main() {\n    val data = Project(\"kotlinx.serialization\",  User(\"kotlin\"), 9000)\n    val list = encodeToList(data)\n    println(list)\n    val obj = decodeFromList&lt;Project&gt;(list)\n    println(obj)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>Now we can convert a list of primitives back to an object tree. \u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u5c06\u57fa\u5143\u5217\u8868\u8f6c\u6362\u56de\u5bf9\u8c61\u6811\u3002</p> <pre><code>[kotlinx.serialization, kotlin, 9000]\nProject(name=kotlinx.serialization, owner=User(name=kotlin), votes=9000)\n</code></pre>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#sequential-decoding","title":"Sequential decoding\u00a0\u987a\u5e8f\u89e3\u7801","text":"<p>The decoder we have implemented keeps track of the\u00a0<code>elementIndex</code>\u00a0in its state and implements\u00a0<code>decodeElementIndex</code>. This means that it is going to work with an arbitrary serializer, even the simple one we wrote in the\u00a0Hand-written composite serializer\u00a0section. However, this format always stores elements in order, so this bookkeeping is not needed and undermines decoding performance. All auto-generated serializers on the JVM support the\u00a0Sequential decoding protocol (experimental), and the decoder can indicate its support by returning\u00a0<code>true</code>\u00a0from the\u00a0CompositeDecoder.decodeSequentially\u00a0function. \u6211\u4eec\u5b9e\u73b0\u7684\u89e3\u7801\u5668\u4f1a\u8ddf\u8e2a\u00a0<code>elementIndex</code>\u00a0\u5176\u72b6\u6001\u5e76\u5b9e\u73b0\u00a0<code>decodeElementIndex</code>\u00a0\u3002\u8fd9\u610f\u5473\u7740\u5b83\u5c06\u4e0e\u4efb\u610f\u5e8f\u5217\u5316\u7a0b\u5e8f\u4e00\u8d77\u4f7f\u7528\uff0c\u751a\u81f3\u662f\u6211\u4eec\u5728\u624b\u5199\u590d\u5408\u5e8f\u5217\u5316\u7a0b\u5e8f\u90e8\u5206\u4e2d\u7f16\u5199\u7684\u7b80\u5355\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002\u4f46\u662f\uff0c\u8fd9\u79cd\u683c\u5f0f\u59cb\u7ec8\u6309\u987a\u5e8f\u5b58\u50a8\u5143\u7d20\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u8fd9\u79cd\u7c3f\u8bb0\uff0c\u5e76\u4e14\u4f1a\u7834\u574f\u89e3\u7801\u6027\u80fd\u3002JVM \u4e0a\u6240\u6709\u81ea\u52a8\u751f\u6210\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\u90fd\u652f\u6301\u987a\u5e8f\u89e3\u7801\u534f\u8bae\uff08\u5b9e\u9a8c\u6027\uff09\uff0c\u89e3\u7801\u5668\u53ef\u4ee5\u901a\u8fc7\u4ece CompositeDecoder.decodeSequentially \u51fd\u6570\u8fd4\u56de\u00a0<code>true</code>\u00a0\u6765\u6307\u793a\u5176\u652f\u6301\u3002</p> <pre><code>class ListDecoder(val list: ArrayDeque&lt;Any&gt;) : AbstractDecoder() {\n    private var elementIndex = 0\n\n    override val serializersModule: SerializersModule = EmptySerializersModule()\n\n    override fun decodeValue(): Any = list.removeFirst()\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int {\n        if (elementIndex == descriptor.elementsCount) return CompositeDecoder.DECODE_DONE\n        return elementIndex++\n    }\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder =\n        ListDecoder(list) \n\n    override fun decodeSequentially(): Boolean = true\n}        \n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#adding-collection-support","title":"Adding collection support","text":"<p>\u6dfb\u52a0\u96c6\u5408\u652f\u6301</p> <p></p> <p>This basic format, so far, cannot properly represent collections. In encodes them, but it does not keep track of how many elements there are in the collection or where it ends, so it cannot properly decode them. First, let us add proper support for collections to the encoder by implementing the\u00a0Encoder.beginCollection\u00a0function. The\u00a0<code>beginCollection</code>\u00a0function takes a collection size as a parameter, so we encode it to add it to the result. Our encoder implementation does not keep any state, so it just returns\u00a0<code>this</code>\u00a0from the\u00a0<code>beginCollection</code>\u00a0function. \u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u8fd9\u79cd\u57fa\u672c\u683c\u5f0f\u65e0\u6cd5\u6b63\u786e\u8868\u793a\u96c6\u5408\u3002In \u5bf9\u5b83\u4eec\u8fdb\u884c\u7f16\u7801\uff0c\u4f46\u5b83\u4e0d\u8ddf\u8e2a\u96c6\u5408\u4e2d\u6709\u591a\u5c11\u5143\u7d20\u6216\u5b83\u7ed3\u675f\u7684\u4f4d\u7f6e\uff0c\u56e0\u6b64\u5b83\u65e0\u6cd5\u6b63\u786e\u89e3\u7801\u5b83\u4eec\u3002\u9996\u5148\uff0c\u8ba9\u6211\u4eec\u901a\u8fc7\u5b9e\u73b0 Encoder.beginCollection \u51fd\u6570\uff0c\u4e3a\u7f16\u7801\u5668\u6dfb\u52a0\u5bf9\u96c6\u5408\u7684\u9002\u5f53\u652f\u6301\u3002\u8be5\u00a0<code>beginCollection</code>\u00a0\u51fd\u6570\u5c06\u96c6\u5408\u5927\u5c0f\u4f5c\u4e3a\u53c2\u6570\uff0c\u56e0\u6b64\u6211\u4eec\u5bf9\u5b83\u8fdb\u884c\u7f16\u7801\u4ee5\u5c06\u5176\u6dfb\u52a0\u5230\u7ed3\u679c\u4e2d\u3002\u6211\u4eec\u7684\u7f16\u7801\u5668\u5b9e\u73b0\u4e0d\u4fdd\u7559\u4efb\u4f55\u72b6\u6001\uff0c\u56e0\u6b64\u5b83\u53ea\u662f\u4ece\u00a0<code>beginCollection</code>\u00a0\u51fd\u6570\u8fd4\u56de\u00a0<code>this</code>\u00a0\u3002</p> <pre><code>class ListEncoder : AbstractEncoder() {\n    val list = mutableListOf&lt;Any&gt;()\n\n    override val serializersModule: SerializersModule = EmptySerializersModule()\n\n    override fun encodeValue(value: Any) {\n        list.add(value)\n    }                               \n\n    override fun beginCollection(descriptor: SerialDescriptor, collectionSize: Int): CompositeEncoder {\n        encodeInt(collectionSize)\n        return this\n    }                                                \n}\n</code></pre> <p>The decoder, for our case, needs to only implement the\u00a0CompositeDecoder.decodeCollectionSize\u00a0function in addition to the previous code. \u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\uff0c\u89e3\u7801\u5668\u9664\u4e86\u524d\u9762\u7684\u4ee3\u7801\u5916\uff0c\u53ea\u9700\u8981\u5b9e\u73b0 CompositeDecoder.decodeCollectionSize \u51fd\u6570\u3002</p> <p>The formats that store collection size in advance have to return\u00a0<code>true</code>\u00a0from\u00a0<code>decodeSequentially</code>. \u63d0\u524d\u5b58\u50a8\u96c6\u5408\u5927\u5c0f\u7684\u683c\u5f0f\u5fc5\u987b\u00a0<code>true</code>\u00a0\u4ece\u00a0<code>decodeSequentially</code>\u00a0\u8fd4\u56de\u3002</p> <pre><code>class ListDecoder(val list: ArrayDeque&lt;Any&gt;, var elementsCount: Int = 0) : AbstractDecoder() {\n    private var elementIndex = 0\n\n    override val serializersModule: SerializersModule = EmptySerializersModule()\n\n    override fun decodeValue(): Any = list.removeFirst()\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int {\n        if (elementIndex == elementsCount) return CompositeDecoder.DECODE_DONE\n        return elementIndex++\n    }\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder =\n        ListDecoder(list, descriptor.elementsCount)\n\n    override fun decodeSequentially(): Boolean = true\n\n    override fun decodeCollectionSize(descriptor: SerialDescriptor): Int =\n        decodeInt().also { elementsCount = it }\n}\n</code></pre> <p>That is all that is needed to support collections and maps. \u8fd9\u5c31\u662f\u652f\u6301\u9986\u85cf\u548c\u5730\u56fe\u6240\u9700\u7684\u5168\u90e8\u5185\u5bb9\u3002</p> <pre><code>@Serializable\ndata class Project(val name: String, val owners: List&lt;User&gt;, val votes: Int)\n\n@Serializable\ndata class User(val name: String)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\",  listOf(User(\"kotlin\"), User(\"jetbrains\")), 9000)\n    val list = encodeToList(data)\n    println(list)\n    val obj = decodeFromList&lt;Project&gt;(list)\n    println(obj)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>We see the size of the list added to the result, letting the decoder know where to stop. \u6211\u4eec\u770b\u5230\u5217\u8868\u7684\u5927\u5c0f\u6dfb\u52a0\u5230\u7ed3\u679c\u4e2d\uff0c\u8ba9\u89e3\u7801\u5668\u77e5\u9053\u5728\u54ea\u91cc\u505c\u6b62\u3002</p> <pre><code>[kotlinx.serialization, 2, kotlin, jetbrains, 9000]\nProject(name=kotlinx.serialization, owners=[User(name=kotlin), User(name=jetbrains)], votes=9000)\n</code></pre>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#adding-null-support-null","title":"Adding null support\u00a0\u6dfb\u52a0 null \u652f\u6301","text":"<p>Our trivial format does not support\u00a0<code>null</code>\u00a0values so far. For nullable types we need to add some kind of \u201cnull indicator\u201d, telling whether the upcoming value is null or not. \u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u7684\u7b80\u5355\u683c\u5f0f\u4e0d\u652f\u6301\u00a0<code>null</code>\u00a0\u503c\u3002\u5bf9\u4e8e\u53ef\u4e3a null \u7684\u7c7b\u578b\uff0c\u6211\u4eec\u9700\u8981\u6dfb\u52a0\u67d0\u79cd\u201c\u7a7a\u6307\u793a\u7b26\u201d\uff0c\u544a\u8bc9\u5373\u5c06\u5230\u6765\u7684\u503c\u662f\u5426\u4e3a null\u3002</p> <p>In the encoder implementation we override\u00a0Encoder.encodeNull\u00a0and\u00a0Encoder.encodeNotNullMark. \u5728\u7f16\u7801\u5668\u5b9e\u73b0\u4e2d\uff0c\u6211\u4eec\u91cd\u5199 Encoder.encodeNull \u548c Encoder.encodeNotNullMark\u3002</p> <pre><code>    override fun encodeNull() = encodeValue(\"NULL\")\n    override fun encodeNotNullMark() = encodeValue(\"!!\")\n</code></pre> <p>In the decoder implementation we override\u00a0Decoder.decodeNotNullMark. \u5728\u89e3\u7801\u5668\u5b9e\u73b0\u4e2d\uff0c\u6211\u4eec\u91cd\u5199 Decoder.decodeNotNullMark\u3002</p> <pre><code>    override fun decodeNotNullMark(): Boolean = decodeString() != \"NULL\"\n</code></pre> <p>Let us test nullable properties both with not-null and null values. \u8ba9\u6211\u4eec\u6d4b\u8bd5\u5177\u6709\u975e null \u548c null \u503c\u7684\u53ef null \u5c5e\u6027\u3002</p> <pre><code>@Serializable\ndata class Project(val name: String, val owner: User?, val votes: Int?)\n\n@Serializable\ndata class User(val name: String)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\",  User(\"kotlin\") , null)\n    val list = encodeToList(data)\n    println(list)\n    val obj = decodeFromList&lt;Project&gt;(list)\n    println(obj)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>In the output we see how not-null<code>!!</code>\u00a0and\u00a0<code>NULL</code>\u00a0marks are used. \u5728\u8f93\u51fa\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u5982\u4f55\u4f7f\u7528 not-null\u00a0<code>!!</code>\u00a0\u548c\u00a0<code>NULL</code>\u00a0marks\u3002</p> <pre><code>[kotlinx.serialization, !!, kotlin, NULL]\nProject(name=kotlinx.serialization, owner=User(name=kotlin), votes=null)\n</code></pre>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#efficient-binary-format","title":"Efficient binary format\u00a0\u9ad8\u6548\u7684\u4e8c\u8fdb\u5236\u683c\u5f0f","text":"<p>Now we are ready for an example of an efficient binary format. We are going to write data to the\u00a0java.io.DataOutput\u00a0implementation. Instead of\u00a0<code>encodeValue</code>\u00a0we must override the individual\u00a0<code>encodeXxx</code>\u00a0functions for each of ten\u00a0primitives\u00a0in the encoder. \u73b0\u5728\uff0c\u6211\u4eec\u5df2\u7ecf\u51c6\u5907\u597d\u4e86\u4e00\u4e2a\u9ad8\u6548\u7684\u4e8c\u8fdb\u5236\u683c\u5f0f\u793a\u4f8b\u3002\u6211\u4eec\u5c06\u628a\u6570\u636e\u5199\u5165 java.io.DataOutput \u5b9e\u73b0\u3002\u76f8\u53cd\uff0c\u00a0<code>encodeValue</code>\u00a0\u6211\u4eec\u5fc5\u987b\u8986\u76d6\u7f16\u7801\u5668\u4e2d\u5341\u4e2a\u57fa\u5143\u4e2d\u6bcf\u4e2a\u57fa\u5143\u7684\u5355\u4e2a\u00a0<code>encodeXxx</code>\u00a0\u51fd\u6570\u3002</p> <pre><code>class DataOutputEncoder(val output: DataOutput) : AbstractEncoder() {\n    override val serializersModule: SerializersModule = EmptySerializersModule()\n    override fun encodeBoolean(value: Boolean) = output.writeByte(if (value) 1 else 0)\n    override fun encodeByte(value: Byte) = output.writeByte(value.toInt())\n    override fun encodeShort(value: Short) = output.writeShort(value.toInt())\n    override fun encodeInt(value: Int) = output.writeInt(value)\n    override fun encodeLong(value: Long) = output.writeLong(value)\n    override fun encodeFloat(value: Float) = output.writeFloat(value)\n    override fun encodeDouble(value: Double) = output.writeDouble(value)\n    override fun encodeChar(value: Char) = output.writeChar(value.code)\n    override fun encodeString(value: String) = output.writeUTF(value)\n    override fun encodeEnum(enumDescriptor: SerialDescriptor, index: Int) = output.writeInt(index)\n\n    override fun beginCollection(descriptor: SerialDescriptor, collectionSize: Int): CompositeEncoder {\n        encodeInt(collectionSize)\n        return this\n    }\n\n    override fun encodeNull() = encodeBoolean(false)\n    override fun encodeNotNullMark() = encodeBoolean(true)\n}\n</code></pre> <p>The decoder implementation mirrors encoder\u2019s implementation overriding all the primitive\u00a0<code>decodeXxx</code>\u00a0functions. \u89e3\u7801\u5668\u5b9e\u73b0\u955c\u50cf\u7f16\u7801\u5668\u7684\u5b9e\u73b0\uff0c\u8986\u76d6\u6240\u6709\u57fa\u5143\u00a0<code>decodeXxx</code>\u00a0\u51fd\u6570\u3002</p> <pre><code>class DataInputDecoder(val input: DataInput, var elementsCount: Int = 0) : AbstractDecoder() {\n    private var elementIndex = 0\n    override val serializersModule: SerializersModule = EmptySerializersModule()\n    override fun decodeBoolean(): Boolean = input.readByte().toInt() != 0\n    override fun decodeByte(): Byte = input.readByte()\n    override fun decodeShort(): Short = input.readShort()\n    override fun decodeInt(): Int = input.readInt()\n    override fun decodeLong(): Long = input.readLong()\n    override fun decodeFloat(): Float = input.readFloat()\n    override fun decodeDouble(): Double = input.readDouble()\n    override fun decodeChar(): Char = input.readChar()\n    override fun decodeString(): String = input.readUTF()\n    override fun decodeEnum(enumDescriptor: SerialDescriptor): Int = input.readInt()\n\n    override fun decodeElementIndex(descriptor: SerialDescriptor): Int {\n        if (elementIndex == elementsCount) return CompositeDecoder.DECODE_DONE\n        return elementIndex++\n    }\n\n    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder =\n        DataInputDecoder(input, descriptor.elementsCount)\n\n    override fun decodeSequentially(): Boolean = true\n\n    override fun decodeCollectionSize(descriptor: SerialDescriptor): Int =\n        decodeInt().also { elementsCount = it }\n\n    override fun decodeNotNullMark(): Boolean = decodeBoolean()\n}\n</code></pre> <p>We can now serialize and deserialize arbitrary data. For example, the same classes as were used in the\u00a0CBOR (experimental)\u00a0and\u00a0ProtoBuf (experimental)\u00a0sections. \u73b0\u5728\uff0c\u6211\u4eec\u53ef\u4ee5\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u4efb\u610f\u6570\u636e\u3002\u4f8b\u5982\uff0c\u4e0e CBOR\uff08\u5b9e\u9a8c\uff09\u548c ProtoBuf\uff08\u5b9e\u9a8c\uff09\u90e8\u5206\u4e2d\u4f7f\u7528\u7684\u7c7b\u76f8\u540c\u3002</p> <pre><code>@Serializable\ndata class Project(val name: String, val language: String)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\", \"Kotlin\")\n    val output = ByteArrayOutputStream()\n    encodeTo(DataOutputStream(output), data)\n    val bytes = output.toByteArray()\n    println(bytes.toAsciiHexString())\n    val input = ByteArrayInputStream(bytes)\n    val obj = decodeFrom&lt;Project&gt;(DataInputStream(input))\n    println(obj)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>As we can see, the result is a dense binary format that only contains the data that is being serialized. It can be easily tweaked for any kind of domain-specific compact encoding. \u6b63\u5982\u6211\u4eec\u6240\u770b\u5230\u7684\uff0c\u7ed3\u679c\u662f\u4e00\u4e2a\u5bc6\u96c6\u7684\u4e8c\u8fdb\u5236\u683c\u5f0f\uff0c\u53ea\u5305\u542b\u6b63\u5728\u5e8f\u5217\u5316\u7684\u6570\u636e\u3002\u5b83\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u8c03\u6574\u4e3a\u4efb\u4f55\u7c7b\u578b\u7684\u7279\u5b9a\u4e8e\u57df\u7684\u7d27\u51d1\u7f16\u7801\u3002</p> <pre><code>{00}{15}kotlinx.serialization{00}{06}Kotlin\nProject(name=kotlinx.serialization, language=Kotlin)\n</code></pre>"},{"location":"%E6%9B%BF%E4%BB%A3%E6%A0%BC%E5%BC%8F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89-6/#format-specific-types","title":"Format-specific types\u00a0\u7279\u5b9a\u4e8e\u683c\u5f0f\u7684\u7c7b\u578b","text":"<p>A format implementation might provide special support for data types that are not among the list of primitive types in Kotlin Serialization, and do not have a corresponding\u00a0<code>encodeXxx</code>/<code>decodeXxx</code>\u00a0function. In the encoder this is achieved by overriding the\u00a0<code>encodeSerializableValue(serializer, value)</code>\u00a0function. \u683c\u5f0f\u5b9e\u73b0\u53ef\u80fd\u4f1a\u4e3a\u4e0d\u5728 Kotlin \u5e8f\u5217\u5316\u4e2d\u7684\u57fa\u5143\u7c7b\u578b\u5217\u8868\u4e2d\u4e14\u6ca1\u6709\u76f8\u5e94\u7684\u00a0<code>encodeXxx</code>\u00a0/\u00a0<code>decodeXxx</code>\u00a0\u51fd\u6570\u7684\u6570\u636e\u7c7b\u578b\u63d0\u4f9b\u7279\u6b8a\u652f\u6301\u3002\u5728\u7f16\u7801\u5668\u4e2d\uff0c\u8fd9\u662f\u901a\u8fc7\u8986\u76d6\u00a0<code>encodeSerializableValue(serializer, value)</code>\u00a0\u51fd\u6570\u6765\u5b9e\u73b0\u7684\u3002</p> <p>In our\u00a0<code>DataOutput</code>\u00a0format example we might want to provide a specialized efficient data path for serializing an array of bytes since\u00a0DataOutput\u00a0has a special method for this purpose. \u5728\u6211\u4eec\u7684\u00a0<code>DataOutput</code>\u00a0\u683c\u5f0f\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u53ef\u80fd\u5e0c\u671b\u63d0\u4f9b\u4e00\u4e2a\u4e13\u95e8\u7684\u9ad8\u6548\u6570\u636e\u8def\u5f84\u6765\u5e8f\u5217\u5316\u5b57\u8282\u6570\u7ec4\uff0c\u56e0\u4e3a DataOutput \u5177\u6709\u7528\u4e8e\u6b64\u76ee\u7684\u7684\u7279\u6b8a\u65b9\u6cd5\u3002</p> <p>Detection of the type is performed by looking at the\u00a0<code>serializer.descriptor</code>, not by checking the type of the\u00a0<code>value</code>\u00a0being serialized, so we fetch the builtin\u00a0KSerializer\u00a0instance for\u00a0<code>ByteArray</code>\u00a0type. \u7c7b\u578b\u7684\u68c0\u6d4b\u662f\u901a\u8fc7\u67e5\u770b\u00a0<code>serializer.descriptor</code>\u00a0\u6765\u6267\u884c\u7684\uff0c\u800c\u4e0d\u662f\u901a\u8fc7\u68c0\u67e5\u00a0<code>value</code>\u00a0\u8981\u5e8f\u5217\u5316\u7684\u7c7b\u578b\u6765\u6267\u884c\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u83b7\u53d6\u00a0<code>ByteArray</code>\u00a0\u7c7b\u578b\u7684\u5185\u7f6e KSerializer \u5b9e\u4f8b\u3002</p> <p>This an important difference. This way our format implementation properly supports\u00a0Custom serializers\u00a0that a user might specify for a type that just happens to be internally represented as a byte array, but need a different serial representation. \u8fd9\u662f\u4e00\u4e2a\u91cd\u8981\u7684\u533a\u522b\u3002\u8fd9\u6837\uff0c\u6211\u4eec\u7684\u683c\u5f0f\u5b9e\u73b0\u53ef\u4ee5\u6b63\u786e\u5730\u652f\u6301\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u7528\u6237\u53ef\u4ee5\u4e3a\u6070\u597d\u5728\u5185\u90e8\u8868\u793a\u4e3a\u5b57\u8282\u6570\u7ec4\u4f46\u9700\u8981\u4e0d\u540c\u4e32\u884c\u8868\u793a\u7684\u7c7b\u578b\u6307\u5b9a\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002</p> <pre><code>private val byteArraySerializer = serializer&lt;ByteArray&gt;()\n</code></pre> <p>Specifically for byte arrays, we could have also used the builtin\u00a0ByteArraySerializer\u00a0function. \u7279\u522b\u662f\u5bf9\u4e8e\u5b57\u8282\u6570\u7ec4\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u4f7f\u7528\u5185\u7f6e\u7684 ByteArraySerializer \u51fd\u6570\u3002</p> <p>We add the corresponding code to the\u00a0Encoder\u00a0implementation of our\u00a0Efficient binary format. To make our\u00a0<code>ByteArray</code>\u00a0encoding even more efficient, we add a trivial implementation of\u00a0<code>encodeCompactSize</code>\u00a0function that uses only one byte to represent a size of up to 254 bytes. \u6211\u4eec\u5c06\u76f8\u5e94\u7684\u4ee3\u7801\u6dfb\u52a0\u5230\u9ad8\u6548\u4e8c\u8fdb\u5236\u683c\u5f0f\u7684 Encoder \u5b9e\u73b0\u4e2d\u3002\u4e3a\u4e86\u4f7f\u6211\u4eec\u00a0<code>ByteArray</code>\u00a0\u7684\u7f16\u7801\u66f4\u52a0\u9ad8\u6548\uff0c\u6211\u4eec\u6dfb\u52a0\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\u00a0<code>encodeCompactSize</code>\u00a0\u51fd\u6570\u5b9e\u73b0\uff0c\u8be5\u51fd\u6570\u4ec5\u4f7f\u7528\u4e00\u4e2a\u5b57\u8282\u6765\u8868\u793a\u6700\u591a 254 \u5b57\u8282\u7684\u5927\u5c0f\u3002</p> <pre><code>    override fun &lt;T&gt; encodeSerializableValue(serializer: SerializationStrategy&lt;T&gt;, value: T) {\n        if (serializer.descriptor == byteArraySerializer.descriptor)\n            encodeByteArray(value as ByteArray)\n        else\n            super.encodeSerializableValue(serializer, value)\n    }\n\n    private fun encodeByteArray(bytes: ByteArray) {\n        encodeCompactSize(bytes.size)\n        output.write(bytes)\n    }\n\n    private fun encodeCompactSize(value: Int) {\n        if (value &lt; 0xff) {\n            output.writeByte(value)\n        } else {\n            output.writeByte(0xff)\n            output.writeInt(value)\n        }\n    }            \n</code></pre> <p>A similar code is added to the\u00a0Decoder\u00a0implementation. Here we override the\u00a0decodeSerializableValue\u00a0function. \u7c7b\u4f3c\u7684\u4ee3\u7801\u5c06\u6dfb\u52a0\u5230\u89e3\u7801\u5668\u5b9e\u73b0\u4e2d\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u91cd\u5199 decodeSerializableValue \u51fd\u6570\u3002</p> <pre><code>    @Suppress(\"UNCHECKED_CAST\")\n    override fun &lt;T&gt; decodeSerializableValue(deserializer: DeserializationStrategy&lt;T&gt;, previousValue: T?): T =\n        if (deserializer.descriptor == byteArraySerializer.descriptor)\n            decodeByteArray() as T\n        else\n            super.decodeSerializableValue(deserializer, previousValue)\n\n    private fun decodeByteArray(): ByteArray {\n        val bytes = ByteArray(decodeCompactSize())\n        input.readFully(bytes)\n        return bytes\n    }\n\n    private fun decodeCompactSize(): Int {\n        val byte = input.readByte().toInt() and 0xff\n        if (byte &lt; 0xff) return byte\n        return input.readInt()\n    }\n</code></pre> <p>Now everything is ready to perform serialization of some byte arrays. \u73b0\u5728\u4e00\u5207\u51c6\u5907\u5c31\u7eea\uff0c\u53ef\u4ee5\u5bf9\u67d0\u4e9b\u5b57\u8282\u6570\u7ec4\u8fdb\u884c\u5e8f\u5217\u5316\u3002</p> <pre><code>@Serializable\ndata class Project(val name: String, val attachment: ByteArray)\n\nfun main() {\n    val data = Project(\"kotlinx.serialization\", byteArrayOf(0x0A, 0x0B, 0x0C, 0x0D))\n    val output = ByteArrayOutputStream()\n    encodeTo(DataOutputStream(output), data)\n    val bytes = output.toByteArray()\n    println(bytes.toAsciiHexString())\n    val input = ByteArrayInputStream(bytes)\n    val obj = decodeFrom&lt;Project&gt;(DataInputStream(input))\n    println(obj)\n}\n</code></pre> <p>You can get the full code\u00a0here. \u60a8\u53ef\u4ee5\u5728\u6b64\u5904\u83b7\u53d6\u5b8c\u6574\u4ee3\u7801\u3002</p> <p>As we can see, our custom byte array format is being used, with the compact encoding of its size in one byte. \u6b63\u5982\u6211\u4eec\u6240\u770b\u5230\u7684\uff0c\u6211\u4eec\u6b63\u5728\u4f7f\u7528\u81ea\u5b9a\u4e49\u5b57\u8282\u6570\u7ec4\u683c\u5f0f\uff0c\u5176\u5927\u5c0f\u7684\u7d27\u51d1\u7f16\u7801\u5728\u4e00\u4e2a\u5b57\u8282\u4e2d\u3002</p> <pre><code>{00}{15}kotlinx.serialization{04}{0A}{0B}{0C}{0D}\nProject(name=kotlinx.serialization, attachment=[10, 11, 12, 13])\n</code></pre> <p>This chapter concludes\u00a0Kotlin Serialization Guide. \u672c\u7ae0\u662f\u300aKotlin \u5e8f\u5217\u5316\u6307\u5357\u300b\u7684\u603b\u7ed3\u3002</p>"},{"location":"%E7%9B%AE%E5%BD%95-0/","title":"Kotlin Serialization Guide","text":"<p>Kotlin \u5e8f\u5217\u5316\u6307\u5357</p> <p></p> <p>Kotlin Serialization is a cross-platform and multi-format framework for data serialization\u2014converting trees of objects to strings, byte arrays, or other\u00a0serial\u00a0representations and back. Kotlin Serialization fully supports and enforces the Kotlin type system, making sure only valid objects can be deserialized. Kotlin \u5e8f\u5217\u5316\u662f\u4e00\u79cd\u7528\u4e8e\u6570\u636e\u5e8f\u5217\u5316\u7684\u8de8\u5e73\u53f0\u548c\u591a\u683c\u5f0f\u6846\u67b6\uff0c\u53ef\u5c06\u5bf9\u8c61\u6811\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u3001\u5b57\u8282\u6570\u7ec4\u6216\u5176\u4ed6\u4e32\u884c\u8868\u793a\u5f62\u5f0f\u5e76\u8fd4\u56de\u3002Kotlin \u5e8f\u5217\u5316\u5b8c\u5168\u652f\u6301\u5e76\u5f3a\u5236\u6267\u884c Kotlin \u7c7b\u578b\u7cfb\u7edf\uff0c\u786e\u4fdd\u53ea\u6709\u6709\u6548\u7684\u5bf9\u8c61\u624d\u80fd\u53cd\u5e8f\u5217\u5316\u3002</p> <p>Kotlin Serialization is not just a library. It is a compiler plugin that is bundled with the Kotlin compiler distribution itself. Build configuration is explained in\u00a0README.md. Once the project is set up, we can start serializing some classes. Kotlin Serialization \u4e0d\u4ec5\u4ec5\u662f\u4e00\u4e2a\u5e93\u3002\u5b83\u662f\u4e00\u4e2a\u7f16\u8bd1\u5668\u63d2\u4ef6\uff0c\u4e0e Kotlin \u7f16\u8bd1\u5668\u53d1\u884c\u7248\u672c\u8eab\u6346\u7ed1\u5728\u4e00\u8d77\u3002\u751f\u6210\u914d\u7f6e\u5728 README.md \u4e2d\u8bf4\u660e\u3002\u4e00\u65e6\u9879\u76ee\u8bbe\u7f6e\u597d\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u59cb\u5e8f\u5217\u5316\u4e00\u4e9b\u7c7b\u4e86\u3002</p>"},{"location":"%E7%9B%AE%E5%BD%95-0/#table-of-contents","title":"Table of contents\u00a0\u76ee\u5f55","text":""},{"location":"%E7%9B%AE%E5%BD%95-0/#1-basic-serialization","title":"\u7b2c1\u7ae0.\u00a0Basic Serialization\u00a0 \u57fa\u672c\u5e8f\u5217\u5316","text":"<ul> <li>Basics\u00a0\u57fa\u672c<ul> <li>JSON encoding\u00a0JSON \u7f16\u7801</li> <li>JSON decoding\u00a0JSON\u89e3\u7801</li> </ul> </li> <li>Serializable classes\u00a0\u53ef\u5e8f\u5217\u5316\u7c7b<ul> <li>Backing fields are serialized     \u652f\u6301\u5b57\u6bb5\u5df2\u5e8f\u5217\u5316</li> <li>Constructor properties requirement     \u6784\u9020\u51fd\u6570\u5c5e\u6027\u8981\u6c42</li> <li>Data validation\u00a0\u6570\u636e\u9a8c\u8bc1</li> <li>Optional properties\u00a0\u53ef\u9009\u5c5e\u6027</li> <li>Optional property initializer call     \u53ef\u9009\u5c5e\u6027\u521d\u59cb\u503c\u8bbe\u5b9a\u9879\u8c03\u7528</li> <li>Required properties\u00a0\u5fc5\u9700\u7684\u5c5e\u6027</li> <li>Transient properties\u00a0\u77ac\u6001\u7279\u6027</li> <li>Defaults are not encoded by default     \u9ed8\u8ba4\u60c5\u51b5\u4e0b\u4e0d\u5bf9\u9ed8\u8ba4\u503c\u8fdb\u884c\u7f16\u7801</li> <li>Nullable properties\u00a0\u53ef\u4e3a null \u7684\u5c5e\u6027</li> <li>Type safety is enforced     \u5f3a\u5236\u6267\u884c\u578b\u5f0f\u5b89\u5168</li> <li>Referenced objects\u00a0\u5f15\u7528\u7684\u5bf9\u8c61</li> <li>No compression of repeated references     \u4e0d\u538b\u7f29\u91cd\u590d\u5f15\u7528</li> <li>Generic classes\u00a0\u6cdb\u578b\u7c7b</li> <li>Serial field names\u00a0\u4e32\u884c\u5b57\u6bb5\u540d\u79f0</li> </ul> </li> </ul>"},{"location":"%E7%9B%AE%E5%BD%95-0/#2-builtin-classes","title":"\u7b2c 2 \u7ae0\u3002\u00a0Builtin Classes  \u5185\u7f6e\u7c7b","text":"<ul> <li>Primitives\u00a0\u539f<ul> <li>Numbers\u00a0\u6570\u5b57</li> <li>Long numbers\u00a0\u957f\u6570\u5b57</li> <li>Long numbers as strings     \u957f\u6570\u5b57\u4f5c\u4e3a\u5b57\u7b26\u4e32</li> <li>Enum classes\u00a0\u683c\u6d1b\u65af</li> <li>Serial names of enum entries     \u679a\u4e3e\u6761\u76ee\u7684\u5e8f\u5217\u5316\u540d\u79f0</li> </ul> </li> <li>Composites\u00a0\u590d\u5408\u6750\u6599<ul> <li>Pair and triple\u00a0\u6210\u5bf9\u548c\u4e09\u4eba</li> <li>Lists\u00a0\u5217\u8868</li> <li>Sets and other collections     \u5957\u88c5\u548c\u5176\u4ed6\u96c6\u5408</li> <li>Deserializing collections     \u53cd\u5e8f\u5217\u5316\u96c6\u5408</li> <li>Maps\u00a0\u5730\u56fe</li> <li>Unit and singleton objects     \u5355\u4f4d\u548c\u5355\u4e00\u5b9e\u4f8b\u5bf9\u8c61</li> <li>Duration\u00a0\u671f\u95f4</li> </ul> </li> <li>Nothing\u00a0\u65e0</li> </ul>"},{"location":"%E7%9B%AE%E5%BD%95-0/#3-serializers","title":"\u7b2c 3 \u7ae0 Serializers\u00a0\u5e8f\u5217\u5316\u7a0b\u5e8f","text":"<ul> <li>Introduction to serializers     \u5e8f\u5217\u5316\u7a0b\u5e8f\u7b80\u4ecb<ul> <li>Plugin-generated serializer     \u63d2\u4ef6\u751f\u6210\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Plugin-generated generic serializer     \u63d2\u4ef6\u751f\u6210\u7684\u6cdb\u578b\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Builtin primitive serializers     \u5185\u7f6e\u57fa\u5143\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Constructing collection serializers     \u6784\u9020\u96c6\u5408\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Using top-level serializer function     \u4f7f\u7528\u9876\u7ea7\u5e8f\u5217\u5316\u7a0b\u5e8f\u529f\u80fd</li> </ul> </li> <li>Custom serializers\u00a0\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f<ul> <li>Primitive serializer\u00a0\u57fa\u5143\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Delegating serializers\u00a0\u59d4\u6d3e\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Composite serializer via surrogate     \u901a\u8fc7\u4ee3\u7406\u9879\u7684\u590d\u5408\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Hand-written composite serializer     \u624b\u5199\u590d\u5408\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Sequential decoding protocol (experimental)     \u987a\u5e8f\u89e3\u7801\u534f\u8bae\uff08\u5b9e\u9a8c\u6027\uff09</li> <li>Serializing 3rd party classes     \u5e8f\u5217\u5316\u7b2c\u4e09\u65b9\u7c7b</li> <li>Passing a serializer manually     \u624b\u52a8\u4f20\u9012\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Specifying serializer on a property     \u5728\u5c5e\u6027\u4e0a\u6307\u5b9a\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Specifying serializer for a particular type     \u4e3a\u7279\u5b9a\u7c7b\u578b\u6307\u5b9a\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Specifying serializers for a file     \u6307\u5b9a\u6587\u4ef6\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Specifying serializer globally using typealias     \u4f7f\u7528 typealias \u5168\u5c40\u6307\u5b9a\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Custom serializers for a generic type     \u6cdb\u578b\u7c7b\u578b\u7684\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f</li> <li>Format-specific serializers     \u7279\u5b9a\u4e8e\u683c\u5f0f\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f</li> </ul> </li> <li>Contextual serialization     \u4e0a\u4e0b\u6587\u5e8f\u5217\u5316<ul> <li>Serializers module\u00a0\u4e32\u884c\u7a0b\u5e8f\u6a21\u5757</li> <li>Contextual serialization and generic classes     \u4e0a\u4e0b\u6587\u5e8f\u5217\u5316\u548c\u6cdb\u578b\u7c7b</li> </ul> </li> <li>Deriving external serializer for another Kotlin class (experimental)     \u4e3a\u53e6\u4e00\u4e2a Kotlin \u7c7b\u6d3e\u751f\u5916\u90e8\u5e8f\u5217\u5316\u7a0b\u5e8f\uff08\u5b9e\u9a8c\u6027\uff09<ul> <li>External serialization uses properties     \u5916\u90e8\u5e8f\u5217\u5316\u4f7f\u7528\u5c5e\u6027</li> </ul> </li> </ul>"},{"location":"%E7%9B%AE%E5%BD%95-0/#4-polymorphism","title":"\u7b2c 4 \u7ae0\u00a0Polymorphism\u00a0\u591a\u6001\u6027","text":"<ul> <li>Closed polymorphism\u00a0\u95ed\u5408\u591a\u6001\u6027<ul> <li>Static types\u00a0\u9759\u6001\u7c7b\u578b</li> <li>Designing serializable hierarchy     \u8bbe\u8ba1\u53ef\u5e8f\u5217\u5316\u7684\u5c42\u6b21\u7ed3\u6784</li> <li>Sealed classes\u00a0\u5bc6\u5c01\u7c7b</li> <li>Custom subclass serial name     \u81ea\u5b9a\u4e49\u5b50\u7c7b\u5e8f\u5217\u5316\u540d\u79f0</li> <li>Concrete properties in a base class     \u57fa\u7c7b\u4e2d\u7684\u5177\u4f53\u5c5e\u6027</li> <li>Objects\u00a0\u5bf9\u8c61</li> </ul> </li> <li>Open polymorphism\u00a0\u5f00\u653e\u591a\u6001\u6027<ul> <li>Registered subclasses\u00a0\u5df2\u6ce8\u518c\u7684\u5b50\u7c7b</li> <li>Serializing interfaces\u00a0\u5e8f\u5217\u5316\u63a5\u53e3</li> <li>Property of an interface type     \u63a5\u53e3\u7c7b\u578b\u7684\u5c5e\u6027</li> <li>Static parent type lookup for polymorphism     \u591a\u6001\u6027\u7684\u9759\u6001\u7236\u7c7b\u578b\u67e5\u627e</li> <li>Explicitly marking polymorphic class properties     \u663e\u5f0f\u6807\u8bb0\u591a\u6001\u7c7b\u5c5e\u6027</li> <li>Registering multiple superclasses     \u6ce8\u518c\u591a\u4e2a\u8d85\u7c7b</li> <li>Polymorphism and generic classes     \u591a\u6001\u6027\u548c\u6cdb\u578b\u7c7b</li> <li>Merging library serializers modules     \u5408\u5e76\u5e93\u5e8f\u5217\u5316\u7a0b\u5e8f\u6a21\u5757</li> <li>Default polymorphic type handler for deserialization     \u7528\u4e8e\u53cd\u5e8f\u5217\u5316\u7684\u9ed8\u8ba4\u591a\u6001\u7c7b\u578b\u5904\u7406\u7a0b\u5e8f</li> <li>Default polymorphic type handler for serialization     \u7528\u4e8e\u5e8f\u5217\u5316\u7684\u9ed8\u8ba4\u591a\u6001\u7c7b\u578b\u5904\u7406\u7a0b\u5e8f</li> </ul> </li> </ul>"},{"location":"%E7%9B%AE%E5%BD%95-0/#5-json-features-json","title":"\u7b2c 5 \u7ae0 JSON Features\u00a0JSON \u529f\u80fd","text":"<ul> <li>Json configuration\u00a0Json \u914d\u7f6e<ul> <li>Pretty printing\u00a0\u6f02\u4eae\u7684\u5370\u5237</li> <li>Lenient parsing\u00a0\u5bbd\u677e\u89e3\u6790</li> <li>Ignoring unknown keys\u00a0\u5ffd\u7565\u672a\u77e5\u952e</li> <li>Alternative Json names\u00a0\u5907\u7528 Json \u540d\u79f0</li> <li>Coercing input values\u00a0\u5f3a\u5236\u8f93\u5165\u503c</li> <li>Encoding defaults\u00a0\u7f16\u7801\u9ed8\u8ba4\u503c</li> <li>Explicit nulls\u00a0\u663e\u5f0f null</li> <li>Allowing structured map keys     \u5141\u8bb8\u7ed3\u6784\u5316\u6620\u5c04\u952e</li> <li>Allowing special floating-point values     \u5141\u8bb8\u7279\u6b8a\u7684\u6d6e\u70b9\u503c</li> <li>Class discriminator for polymorphism     \u591a\u6001\u6027\u7684\u7c7b\u9274\u522b\u5668</li> <li>Class discriminator output mode     \u7c7b\u9274\u522b\u5668\u8f93\u51fa\u65b9\u5f0f</li> <li>Decoding enums in a case-insensitive manner     \u4ee5\u4e0d\u533a\u5206\u5927\u5c0f\u5199\u7684\u65b9\u5f0f\u89e3\u7801\u679a\u4e3e</li> <li>Global naming strategy\u00a0\u5168\u5c40\u547d\u540d\u7b56\u7565</li> </ul> </li> <li>Json elements\u00a0Json \u5143\u7d20<ul> <li>Parsing to Json element     \u89e3\u6790\u4e3a Json \u5143\u7d20</li> <li>Types of Json elements     Json \u5143\u7d20\u7684\u7c7b\u578b</li> <li>Json element builders\u00a0Json \u5143\u7d20\u751f\u6210\u5668</li> <li>Decoding Json elements\u00a0\u89e3\u7801 Json \u5143\u7d20</li> <li>Encoding literal Json content (experimental)     \u5bf9\u6587\u5b57 Json \u5185\u5bb9\u8fdb\u884c\u7f16\u7801\uff08\u5b9e\u9a8c\u6027\uff09<ul> <li>Serializing large decimal numbers     \u5e8f\u5217\u5316\u5927\u5341\u8fdb\u5236\u6570</li> <li>Using\u00a0<code>JsonUnquotedLiteral</code>\u00a0to create a literal unquoted value of\u00a0<code>null</code>\u00a0is forbidden     \u7981\u6b62\u7528\u4e8e\u00a0<code>JsonUnquotedLiteral</code>\u00a0\u521b\u5efa \u7684\u00a0<code>null</code>\u00a0\u6587\u5b57\u672a\u52a0\u5f15\u53f7\u7684\u503c</li> </ul> </li> </ul> </li> <li>Json transformations\u00a0Json \u8f6c\u6362<ul> <li>Array wrapping\u00a0\u6570\u7ec4\u5305\u88c5</li> <li>Array unwrapping\u00a0\u6570\u7ec4\u89e3\u5305</li> <li>Manipulating default values     \u64cd\u4f5c\u9ed8\u8ba4\u503c</li> <li>Content-based polymorphic deserialization     \u57fa\u4e8e\u5185\u5bb9\u7684\u591a\u6001\u53cd\u5e8f\u5217\u5316</li> <li>Under the hood (experimental)     \u5f15\u64ce\u76d6\u4e0b\uff08\u5b9e\u9a8c\u6027\uff09</li> <li>Maintaining custom JSON attributes     \u7ef4\u62a4\u81ea\u5b9a\u4e49 JSON \u5c5e\u6027</li> </ul> </li> </ul>"},{"location":"%E7%9B%AE%E5%BD%95-0/#6-alternative-and-custom-formats-experimental","title":"\u7b2c 6 \u7ae0\u00a0Alternative and custom formats (experimental)","text":"<p>\u66ff\u4ee3\u683c\u5f0f\u548c\u81ea\u5b9a\u4e49\u683c\u5f0f\uff08\u5b9e\u9a8c\u6027\uff09</p> <ul> <li>CBOR (experimental)\u00a0CBOR\uff08\u5b9e\u9a8c\u6027\uff09<ul> <li>Ignoring unknown keys\u00a0\u5ffd\u7565\u672a\u77e5\u952e</li> <li>Byte arrays and CBOR data types     \u5b57\u8282\u6570\u7ec4\u548c CBOR \u6570\u636e\u7c7b\u578b</li> </ul> </li> <li>ProtoBuf (experimental)     ProtoBuf\uff08\u5b9e\u9a8c\u6027\uff09<ul> <li>Field numbers\u00a0\u5b57\u6bb5\u7f16\u53f7</li> <li>Integer types\u00a0\u6574\u6570\u7c7b\u578b</li> <li>Lists as repeated fields     \u4f5c\u4e3a\u91cd\u590d\u5b57\u6bb5\u5217\u51fa</li> <li>Packed fields\u00a0\u586b\u5145\u5b57\u6bb5</li> <li>ProtoBuf schema generator (experimental)     ProtoBuf \u6a21\u5f0f\u751f\u6210\u5668\uff08\u5b9e\u9a8c\u6027\uff09</li> </ul> </li> <li>Properties (experimental)     \u5c5e\u6027\uff08\u5b9e\u9a8c\u6027\uff09</li> <li>Custom formats (experimental)     \u81ea\u5b9a\u4e49\u683c\u5f0f\uff08\u5b9e\u9a8c\u6027\uff09<ul> <li>Basic encoder\u00a0\u57fa\u672c\u7f16\u7801\u5668</li> <li>Basic decoder\u00a0\u57fa\u672c\u89e3\u7801\u5668</li> <li>Sequential decoding\u00a0\u987a\u5e8f\u89e3\u7801</li> <li>Adding collection support     \u6dfb\u52a0\u96c6\u5408\u652f\u6301</li> <li>Adding null support\u00a0\u6dfb\u52a0 null \u652f\u6301</li> <li>Efficient binary format\u00a0\u9ad8\u6548\u7684\u4e8c\u8fdb\u5236\u683c\u5f0f</li> <li>Format-specific types\u00a0\u7279\u5b9a\u4e8e\u683c\u5f0f\u7684\u7c7b\u578b</li> </ul> </li> </ul>"},{"location":"%E7%9B%AE%E5%BD%95-0/#a-serialization-and-value-classes-ir-only-ir","title":"\u9644\u5f55 A.\u00a0Serialization and value classes (IR-only)  \u5e8f\u5217\u5316\u548c\u503c\u7c7b\uff08\u4ec5\u9650 IR\uff09","text":"<ul> <li>Serializable value classes     \u53ef\u5e8f\u5217\u5316\u503c\u7c7b</li> <li>Unsigned types support (JSON only)     \u65e0\u7b26\u53f7\u7c7b\u578b\u652f\u6301\uff08\u4ec5\u9650 JSON\uff09</li> <li>Using value classes in your custom serializers     \u5728\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u4e2d\u4f7f\u7528\u503c\u7c7b</li> </ul>"},{"location":"%E9%99%84%E5%BD%95%20A.%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%80%BC%E7%B1%BB%EF%BC%88%E4%BB%85%E9%99%90%20IR%EF%BC%89/","title":"Serialization and value classes (IR-specific)","text":"<p>\u5e8f\u5217\u5316\u548c\u503c\u7c7b\uff08\u7279\u5b9a\u4e8e IR\uff09</p> <p></p> <p>This appendix describes how value classes are handled by kotlinx.serialization. \u672c\u9644\u5f55\u63cf\u8ff0\u4e86 kotlinx.serialization \u5982\u4f55\u5904\u7406\u503c\u7c7b\u3002</p> <p>Features described are available on JVM/IR (enabled by default), JS/IR and Native backends. \u6240\u63cf\u8ff0\u7684\u529f\u80fd\u5728 JVM/IR\uff08\u9ed8\u8ba4\u542f\u7528\uff09\u3001JS/IR \u548c\u672c\u673a\u540e\u7aef\u4e0a\u53ef\u7528\u3002</p> <p>Table of contents\u00a0\u76ee\u5f55</p> <ul> <li>Serializable value classes     \u53ef\u5e8f\u5217\u5316\u503c\u7c7b</li> <li>Unsigned types support (JSON only)     \u65e0\u7b26\u53f7\u7c7b\u578b\u652f\u6301\uff08\u4ec5\u9650 JSON\uff09</li> <li>Using value classes in your custom serializers     \u5728\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u4e2d\u4f7f\u7528\u503c\u7c7b</li> </ul>"},{"location":"%E9%99%84%E5%BD%95%20A.%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%80%BC%E7%B1%BB%EF%BC%88%E4%BB%85%E9%99%90%20IR%EF%BC%89/#serializable-value-classes","title":"Serializable value classes","text":"<p>\u53ef\u5e8f\u5217\u5316\u503c\u7c7b</p> <p></p> <p>We can mark value class as serializable: \u6211\u4eec\u53ef\u4ee5\u5c06\u503c\u7c7b\u6807\u8bb0\u4e3a\u53ef\u5e8f\u5217\u5316\uff1a</p> <pre><code>@Serializable\n@JvmInline\nvalue class Color(val rgb: Int)\n</code></pre> <p>Value class in Kotlin is stored as its underlying type when possible (i.e. no boxing is required). Serialization framework does not impose any additional restrictions and uses the underlying type where possible as well. \u5728\u53ef\u80fd\u7684\u60c5\u51b5\u4e0b\uff0cKotlin \u4e2d\u7684\u503c\u7c7b\u5b58\u50a8\u4e3a\u5176\u57fa\u7840\u7c7b\u578b\uff08\u5373\u4e0d\u9700\u8981\u88c5\u7bb1\uff09\u3002\u5e8f\u5217\u5316\u6846\u67b6\u4e0d\u65bd\u52a0\u4efb\u4f55\u989d\u5916\u7684\u9650\u5236\uff0c\u5e76\u4e14\u5c3d\u53ef\u80fd\u4f7f\u7528\u57fa\u7840\u7c7b\u578b\u3002</p> <pre><code>@Serializable\ndata class NamedColor(val color: Color, val name: String)\n\nfun main() {\n  println(Json.encodeToString(NamedColor(Color(0), \"black\")))\n}\n</code></pre> <p>In this example,\u00a0<code>NamedColor</code>\u00a0is serialized as two primitives:\u00a0<code>color: Int</code>\u00a0and\u00a0<code>name: String</code>\u00a0without an allocation of\u00a0<code>Color</code>\u00a0class. When we run the example, encoding data with JSON format, we get the following output: \u5728\u6b64\u793a\u4f8b\u4e2d\uff0c\u00a0<code>NamedColor</code>\u00a0\u88ab\u5e8f\u5217\u5316\u4e3a\u4e24\u4e2a\u57fa\u5143\uff1a\u00a0<code>color: Int</code>\u00a0\u5e76\u4e14\u00a0<code>name: String</code>\u00a0\u6ca1\u6709\u00a0<code>Color</code>\u00a0\u7c7b\u7684\u5206\u914d\u3002\u5f53\u6211\u4eec\u8fd0\u884c\u793a\u4f8b\u65f6\uff0c\u4f7f\u7528 JSON \u683c\u5f0f\u5bf9\u6570\u636e\u8fdb\u884c\u7f16\u7801\uff0c\u6211\u4eec\u5f97\u5230\u4ee5\u4e0b\u8f93\u51fa\uff1a</p> <pre><code>{\"color\": 0, \"name\": \"black\"}\n</code></pre> <p>As we see,\u00a0<code>Color</code>\u00a0class is not included during the encoding, only its underlying data. This invariant holds even if the actual value class is\u00a0allocated\u00a0\u2014 for example, when value class is used as a generic type argument: \u6b63\u5982\u6211\u4eec\u6240\u770b\u5230\u7684\uff0c\u00a0<code>Color</code>\u00a0\u5728\u7f16\u7801\u8fc7\u7a0b\u4e2d\u4e0d\u5305\u62ec\u7c7b\uff0c\u53ea\u5305\u542b\u5176\u57fa\u7840\u6570\u636e\u3002\u5373\u4f7f\u5206\u914d\u4e86\u5b9e\u9645\u7684\u503c\u7c7b\uff0c\u6b64\u4e0d\u53d8\u91cf\u4e5f\u6210\u7acb\uff0c\u4f8b\u5982\uff0c\u5f53\u503c\u7c7b\u7528\u4f5c\u6cdb\u578b\u7c7b\u578b\u53c2\u6570\u65f6\uff1a</p> <pre><code>@Serializable\nclass Palette(val colors: List&lt;Color&gt;)\n\nfun main() {\n  println(Json.encodeToString(Palette(listOf(Color(0), Color(255), Color(128)))))\n}\n</code></pre> <p>The snippet produces the following output: \u4ee3\u7801\u6bb5\u751f\u6210\u4ee5\u4e0b\u8f93\u51fa\uff1a</p> <pre><code>{\"colors\":[0, 255, 128]}\n</code></pre>"},{"location":"%E9%99%84%E5%BD%95%20A.%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%80%BC%E7%B1%BB%EF%BC%88%E4%BB%85%E9%99%90%20IR%EF%BC%89/#unsigned-types-support-json-only","title":"Unsigned types support (JSON only)","text":"<p>\u65e0\u7b26\u53f7\u7c7b\u578b\u652f\u6301\uff08\u4ec5\u9650 JSON\uff09</p> <p></p> <p>Kotlin standard library provides ready-to-use unsigned arithmetics, leveraging value classes to represent unsigned types:\u00a0<code>UByte</code>,\u00a0<code>UShort</code>,\u00a0<code>UInt</code>\u00a0and\u00a0<code>ULong</code>.\u00a0Json\u00a0format has built-in support for them: these types are serialized as theirs string representations in unsigned form. These types are handled as regular serializable types by the compiler plugin and can be freely used in serializable classes: Kotlin \u6807\u51c6\u5e93\u63d0\u4f9b\u73b0\u6210\u7684\u65e0\u7b26\u53f7\u7b97\u672f\uff0c\u5229\u7528\u503c\u7c7b\u6765\u8868\u793a\u65e0\u7b26\u53f7\u7c7b\u578b\uff1a\u00a0<code>UByte</code>\u00a0\u3001\u00a0<code>UShort</code>\u00a0\u548c\u00a0<code>UInt</code> <code>ULong</code>\u00a0\u3002Json \u683c\u5f0f\u5bf9\u5b83\u4eec\u6709\u5185\u7f6e\u7684\u652f\u6301\uff1a\u8fd9\u4e9b\u7c7b\u578b\u4ee5\u65e0\u7b26\u53f7\u5f62\u5f0f\u5e8f\u5217\u5316\u4e3a\u5b83\u4eec\u7684\u5b57\u7b26\u4e32\u8868\u793a\u5f62\u5f0f\u3002\u8fd9\u4e9b\u7c7b\u578b\u7531\u7f16\u8bd1\u5668\u63d2\u4ef6\u4f5c\u4e3a\u5e38\u89c4\u7684\u53ef\u5e8f\u5217\u5316\u7c7b\u578b\u8fdb\u884c\u5904\u7406\uff0c\u5e76\u4e14\u53ef\u4ee5\u5728\u53ef\u5e8f\u5217\u5316\u7c7b\u4e2d\u81ea\u7531\u4f7f\u7528\uff1a</p> <pre><code>@Serializable\nclass Counter(val counted: UByte, val description: String)\n\nfun main() {\n    val counted = 239.toUByte()\n    println(Json.encodeToString(Counter(counted, \"tries\")))\n}\n</code></pre> <p>The output is following: \u8f93\u51fa\u5982\u4e0b\uff1a</p> <pre><code>{\"counted\":239,\"description\":\"tries\"}\n</code></pre> <p>Unsigned types are currently supported only in JSON format. Other formats such as ProtoBuf and CBOR use built-in serializers that use an underlying signed representation for unsigned types. \u76ee\u524d\u4ec5\u652f\u6301 JSON \u683c\u5f0f\u7684\u65e0\u7b26\u53f7\u7c7b\u578b\u3002\u5176\u4ed6\u683c\u5f0f\uff08\u5982 ProtoBuf \u548c CBOR\uff09\u4f7f\u7528\u5185\u7f6e\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u8fd9\u4e9b\u5e8f\u5217\u5316\u7a0b\u5e8f\u5bf9\u65e0\u7b26\u53f7\u7c7b\u578b\u4f7f\u7528\u57fa\u7840\u6709\u7b26\u53f7\u8868\u793a\u5f62\u5f0f\u3002</p>"},{"location":"%E9%99%84%E5%BD%95%20A.%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%80%BC%E7%B1%BB%EF%BC%88%E4%BB%85%E9%99%90%20IR%EF%BC%89/#using-value-classes-in-your-custom-serializers","title":"Using value classes in your custom serializers","text":"<p>\u5728\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u4e2d\u4f7f\u7528\u503c\u7c7b</p> <p></p> <p>Let\u2019s return to our\u00a0<code>NamedColor</code>\u00a0example and try to write a custom serializer for it. Normally, as shown in\u00a0Hand-written composite serializer, we would write the following code in\u00a0<code>serialize</code>\u00a0method: \u8ba9\u6211\u4eec\u56de\u5230\u6211\u4eec\u7684\u00a0<code>NamedColor</code>\u00a0\u793a\u4f8b\uff0c\u5e76\u5c1d\u8bd5\u4e3a\u5b83\u7f16\u5199\u4e00\u4e2a\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u5982\u624b\u5199\u590d\u5408\u5e8f\u5217\u5316\u5668\u4e2d\u6240\u793a\uff0c\u6211\u4eec\u4f1a\u5728\u65b9\u6cd5\u4e2d\u00a0<code>serialize</code>\u00a0\u7f16\u5199\u4ee5\u4e0b\u4ee3\u7801\uff1a</p> <pre><code>override fun serialize(encoder: Encoder, value: NamedColor) {\n  encoder.encodeStructure(descriptor) {\n    encodeSerializableElement(descriptor, 0, Color.serializer(), value.color)\n    encodeStringElement(descriptor, 1, value.name)\n  }\n}\n</code></pre> <p>However, since\u00a0<code>Color</code>\u00a0is used as a type argument in\u00a0encodeSerializableElement\u00a0function,\u00a0<code>value.color</code>\u00a0will be boxed to\u00a0<code>Color</code>\u00a0wrapper before passing it to the function, preventing the value class optimization. To avoid this, we can use special\u00a0encodeInlineElement\u00a0function instead. It uses\u00a0serial descriptor\u00a0of\u00a0<code>Color</code>\u00a0(retrieved\u00a0from serial descriptor of\u00a0<code>NamedColor</code>) instead of\u00a0KSerializer, does not have type parameters and does not accept any values. Instead, it returns\u00a0Encoder. Using it, we can encode unboxed value: \u4f46\u662f\uff0c\u7531\u4e8e\u00a0<code>Color</code>\u00a0\u5728 encodeSerializableElement \u51fd\u6570\u4e2d\u7528\u4f5c\u7c7b\u578b\u53c2\u6570\uff0c\u00a0<code>value.color</code>\u00a0\u56e0\u6b64\u5728\u5c06\u5176\u4f20\u9012\u7ed9\u51fd\u6570\u4e4b\u524d\u5c06\u88ab\u88c5\u7bb1\u5230\u00a0<code>Color</code>\u00a0\u5305\u88c5\u5668\uff0c\u4ece\u800c\u963b\u6b62\u503c\u7c7b\u4f18\u5316\u3002\u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\uff0c\u6211\u4eec\u53ef\u4ee5\u6539\u7528\u7279\u6b8a\u7684 encodeInlineElement \u51fd\u6570\u3002\u5b83\u4f7f\u7528 \uff08\u00a0<code>Color</code>\u00a0\u4ece\u00a0<code>NamedColor</code>\u00a0\u7684 \u7684 \u4e32\u884c\u63cf\u8ff0\u7b26 \u68c0\u7d22 \uff09\u800c\u4e0d\u662f KSerializer \u7684\u4e32\u884c\u63cf\u8ff0\u7b26\uff0c\u6ca1\u6709\u7c7b\u578b\u53c2\u6570\uff0c\u4e5f\u4e0d\u63a5\u53d7\u4efb\u4f55\u503c\u3002\u76f8\u53cd\uff0c\u5b83\u8fd4\u56de Encoder\u3002\u4f7f\u7528\u5b83\uff0c\u6211\u4eec\u53ef\u4ee5\u5bf9\u672a\u88c5\u7bb1\u7684\u503c\u8fdb\u884c\u7f16\u7801\uff1a</p> <pre><code>override fun serialize(encoder: Encoder, value: NamedColor) {\n  encoder.encodeStructure(descriptor) {\n    encodeInlineElement(descriptor, 0).encodeInt(value.color)\n    encodeStringElement(descriptor, 1, value.name)\n  }\n}\n</code></pre> <p>The same principle goes also with\u00a0CompositeDecoder: it has\u00a0decodeInlineElement\u00a0function that returns\u00a0Decoder. CompositeDecoder \u4e5f\u6709\u540c\u6837\u7684\u539f\u7406\uff1a\u5b83\u5177\u6709\u8fd4\u56de Decoder \u7684 decodeInlineElement \u51fd\u6570\u3002</p> <p>If your class should be represented as a primitive (as shown in\u00a0Primitive serializer\u00a0section), and you cannot use\u00a0encodeStructure\u00a0function, there is a complementary function in\u00a0Encoder\u00a0called\u00a0encodeInline. We will use it to show an example how one can represent a class as an unsigned integer. \u5982\u679c\u7c7b\u5e94\u8868\u793a\u4e3a\u57fa\u5143\uff08\u5982\u57fa\u5143\u5e8f\u5217\u5316\u7a0b\u5e8f\u90e8\u5206\u6240\u793a\uff09\uff0c\u5e76\u4e14\u4e0d\u80fd\u4f7f\u7528 encodeStructure \u51fd\u6570\uff0c\u5219 Encoder \u4e2d\u6709\u4e00\u4e2a\u540d\u4e3a encodeInline \u7684\u8865\u5145\u51fd\u6570\u3002\u6211\u4eec\u5c06\u7528\u5b83\u6765\u5c55\u793a\u4e00\u4e2a\u793a\u4f8b\uff0c\u5982\u4f55\u5c06\u7c7b\u8868\u793a\u4e3a\u65e0\u7b26\u53f7\u6574\u6570\u3002</p> <p>Let\u2019s start with a UID class: \u8ba9\u6211\u4eec\u4ece\u4e00\u4e2a UID \u7c7b\u5f00\u59cb\uff1a</p> <pre><code>@Serializable(UIDSerializer::class)\nclass UID(val uid: Int)\n</code></pre> <p><code>uid</code>\u00a0type is\u00a0<code>Int</code>, but suppose we want it to be an unsigned integer in JSON. We can start writing the following custom serializer: <code>uid</code>\u00a0type \u662f\u00a0<code>Int</code>\u00a0\uff0c\u4f46\u5047\u8bbe\u6211\u4eec\u5e0c\u671b\u5b83\u662f JSON \u4e2d\u7684\u65e0\u7b26\u53f7\u6574\u6570\u3002\u6211\u4eec\u53ef\u4ee5\u5f00\u59cb\u7f16\u5199\u4ee5\u4e0b\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\uff1a</p> <pre><code>object UIDSerializer: KSerializer&lt;UID&gt; {\n  override val descriptor = UInt.serializer().descriptor\n}\n</code></pre> <p>Note that we are using here descriptor from\u00a0<code>UInt.serializer()</code>\u00a0\u2014 it means that the class\u2019 representation looks like a UInt\u2019s one. \u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fd9\u91cc\u4f7f\u7528\u7684\u63cf\u8ff0\u7b26 from\u00a0<code>UInt.serializer()</code>\u00a0\u2014 \u8fd9\u610f\u5473\u7740\u7c7b\u7684\u8868\u793a\u5f62\u5f0f\u770b\u8d77\u6765\u50cf UInt \u7684\u8868\u793a\u5f62\u5f0f\u3002</p> <p>Then the\u00a0<code>serialize</code>\u00a0method: \u7136\u540e\u65b9\u6cd5\u00a0<code>serialize</code>\u00a0\uff1a</p> <pre><code>override fun serialize(encoder: Encoder, value: UID) {\n  encoder.encodeInline(descriptor).encodeInt(value.uid)\n}\n</code></pre> <p>That\u2019s where the magic happens \u2014 despite we called a regular\u00a0encodeInt\u00a0with a\u00a0<code>uid: Int</code>\u00a0argument, the output will contain an unsigned int because of the special encoder from\u00a0<code>encodeInline</code>\u00a0function. Since JSON format supports unsigned integers, it recognizes theirs descriptors when they\u2019re passed into\u00a0<code>encodeInline</code>\u00a0and handles consecutive calls as for unsigned integers. \u8fd9\u5c31\u662f\u795e\u5947\u7684\u5730\u65b9\u2014\u2014\u5c3d\u7ba1\u6211\u4eec\u7528\u00a0<code>uid: Int</code>\u00a0\u53c2\u6570\u8c03\u7528\u4e86\u5e38\u89c4 encodeInt\uff0c\u4f46\u7531\u4e8e\u00a0<code>encodeInline</code>\u00a0\u51fd\u6570\u7684\u7279\u6b8a\u7f16\u7801\u5668\uff0c\u8f93\u51fa\u5c06\u5305\u542b\u4e00\u4e2a\u65e0\u7b26\u53f7\u7684 int\u3002\u7531\u4e8e JSON \u683c\u5f0f\u652f\u6301\u65e0\u7b26\u53f7\u6574\u6570\uff0c\u56e0\u6b64\u5f53\u5b83\u4eec\u88ab\u4f20\u5165\u00a0<code>encodeInline</code>\u00a0\u65f6\uff0c\u5b83\u4f1a\u8bc6\u522b\u5b83\u4eec\u7684\u63cf\u8ff0\u7b26\uff0c\u5e76\u50cf\u5904\u7406\u65e0\u7b26\u53f7\u6574\u6570\u4e00\u6837\u5904\u7406\u8fde\u7eed\u8c03\u7528\u3002</p> <p>The\u00a0<code>deserialize</code>\u00a0method looks symmetrically: \u8be5\u00a0<code>deserialize</code>\u00a0\u65b9\u6cd5\u770b\u8d77\u6765\u5bf9\u79f0\uff1a</p> <pre><code>override fun deserialize(decoder: Decoder): UID {\n  return UID(decoder.decodeInline(descriptor).decodeInt())\n}\n</code></pre> <p>Disclaimer: You can also write such a serializer for value class itself (imagine UID being the value class \u2014 there\u2019s no need to change anything in the serializer). However, do not use anything in custom serializers for value classes besides\u00a0<code>encodeInline</code>. As we discussed, calls to value class serializer may be optimized and replaced with a\u00a0<code>encodeInlineElement</code>\u00a0calls.\u00a0<code>encodeInline</code>\u00a0and\u00a0<code>encodeInlineElement</code>\u00a0calls with the same descriptor are considered equivalent and can be replaced with each other \u2014 formats should return the same\u00a0<code>Encoder</code>. If you embed custom logic in custom value class serializer, you may get different results depending on whether this serializer was called at all (and this, in turn, depends on whether value class was boxed or not). \u514d\u8d23\u58f0\u660e\uff1a\u60a8\u4e5f\u53ef\u4ee5\u4e3a\u503c\u7c7b\u672c\u8eab\u7f16\u5199\u8fd9\u6837\u7684\u5e8f\u5217\u5316\u7a0b\u5e8f\uff08\u5047\u8bbe UID \u662f\u503c\u7c7b - \u65e0\u9700\u66f4\u6539\u5e8f\u5217\u5316\u7a0b\u5e8f\u4e2d\u7684\u4efb\u4f55\u5185\u5bb9\uff09\u3002\u4f46\u662f\uff0c\u9664\u4e86\u00a0<code>encodeInline</code>\u00a0\u4e4b\u5916\uff0c\u4e0d\u8981\u5728\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7a0b\u5e8f\u4e2d\u5bf9\u503c\u7c7b\u4f7f\u7528\u4efb\u4f55\u5185\u5bb9\u3002\u6b63\u5982\u6211\u4eec\u6240\u8ba8\u8bba\u7684\uff0c\u5bf9\u503c\u7c7b\u5e8f\u5217\u5316\u7a0b\u5e8f\u7684\u8c03\u7528\u53ef\u80fd\u4f1a\u88ab\u4f18\u5316\u5e76\u66ff\u6362\u4e3a\u8c03\u7528\u00a0<code>encodeInlineElement</code>\u00a0\u3002\u00a0<code>encodeInline</code>\u00a0\u5177\u6709\u76f8\u540c\u63cf\u8ff0\u7b26\u7684\u00a0<code>encodeInlineElement</code>\u00a0\u8c03\u7528\u88ab\u8ba4\u4e3a\u662f\u7b49\u6548\u7684\uff0c\u53ef\u4ee5\u76f8\u4e92\u66ff\u6362 \u2014 \u683c\u5f0f\u5e94\u8fd4\u56de\u76f8\u540c\u7684\u00a0<code>Encoder</code>\u00a0\u3002\u5982\u679c\u5728\u81ea\u5b9a\u4e49\u503c\u7c7b\u5e8f\u5217\u5316\u7a0b\u5e8f\u4e2d\u5d4c\u5165\u81ea\u5b9a\u4e49\u903b\u8f91\uff0c\u5219\u53ef\u80fd\u4f1a\u5f97\u5230\u4e0d\u540c\u7684\u7ed3\u679c\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u662f\u5426\u8c03\u7528\u4e86\u6b64\u5e8f\u5217\u5316\u7a0b\u5e8f\uff08\u800c\u8fd9\u53cd\u8fc7\u6765\u53c8\u53d6\u51b3\u4e8e\u503c\u7c7b\u662f\u5426\u88c5\u7bb1\uff09\u3002****</p>"}]}